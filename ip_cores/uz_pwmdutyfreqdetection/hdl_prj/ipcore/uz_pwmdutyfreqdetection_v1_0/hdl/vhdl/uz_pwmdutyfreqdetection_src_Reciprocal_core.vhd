-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\uz_pwmdutyfreqdetection\uz_pwmdutyfreqdetection_src_Reciprocal_core.vhd
-- Created: 2023-03-14 13:55:30
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: uz_pwmdutyfreqdetection_src_Reciprocal_core
-- Source Path: uz_pwmdutyfreqdetection/uz_pwmdutyfreqdetection/Reciprocal/Reciprocal_core
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.uz_pwmdutyfreqdetection_src_uz_pwmdutyfreqdetection_pkg.ALL;

ENTITY uz_pwmdutyfreqdetection_src_Reciprocal_core IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb_1_23_0                        :   IN    std_logic;
        xin                               :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        ain                               :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En32
        xout                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- sfix32_En28
        aout                              :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32_En32
        );
END uz_pwmdutyfreqdetection_src_Reciprocal_core;


ARCHITECTURE rtl OF uz_pwmdutyfreqdetection_src_Reciprocal_core IS

  -- Signals
  SIGNAL const3                           : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL ain_unsigned                     : unsigned(31 DOWNTO 0);  -- ufix32_En32
  SIGNAL amul                             : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL xin_signed                       : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL mul1_mul_temp                    : signed(67 DOWNTO 0);  -- sfix68_En60
  SIGNAL mulout1                          : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL mulout1delay                     : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL delaymul                         : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL xindelay1                        : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL mul2_mul_temp                    : signed(67 DOWNTO 0);  -- sfix68_En60
  SIGNAL mulout2                          : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL mulout2delay                     : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL subout                           : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL shiftout                         : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL shiftoutdelay                    : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL shiftmul                         : signed(35 DOWNTO 0);  -- sfix36_En32
  SIGNAL xindelay3_reg_reg                : vector_of_signed32(0 TO 1);  -- sfix32 [2]
  SIGNAL xindelay3                        : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL mul2_mul_temp_1                  : signed(67 DOWNTO 0);  -- sfix68_En60
  SIGNAL mulout3                          : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL xout_tmp                         : signed(31 DOWNTO 0);  -- sfix32_En28
  SIGNAL aout_reg_reg                     : vector_of_unsigned32(0 TO 3);  -- ufix32 [4]
  SIGNAL aout_tmp                         : unsigned(31 DOWNTO 0);  -- ufix32_En32

BEGIN
  -- Iteration Core of the RecipSqrt Implementation using Newton Method

  const3 <= to_signed(805306368, 32);

  ain_unsigned <= unsigned(ain);

  amul <= signed(resize(ain_unsigned, 36));

  xin_signed <= signed(xin);

  mul1_mul_temp <= amul * xin_signed;
  mulout1 <= mul1_mul_temp(63 DOWNTO 32) + ('0' & mul1_mul_temp(31));

  xinterm1_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mulout1delay <= to_signed(0, 32);
      ELSIF enb_1_23_0 = '1' THEN
        mulout1delay <= mulout1;
      END IF;
    END IF;
  END PROCESS xinterm1_reg_process;


  delaymul <= mulout1delay & '0' & '0' & '0' & '0';

  xindelay1_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        xindelay1 <= to_signed(0, 32);
      ELSIF enb_1_23_0 = '1' THEN
        xindelay1 <= xin_signed;
      END IF;
    END IF;
  END PROCESS xindelay1_reg_process;


  mul2_mul_temp <= delaymul * xindelay1;
  mulout2 <= mul2_mul_temp(63 DOWNTO 32) + ('0' & mul2_mul_temp(31));

  xinterm2_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        mulout2delay <= to_signed(0, 32);
      ELSIF enb_1_23_0 = '1' THEN
        mulout2delay <= mulout2;
      END IF;
    END IF;
  END PROCESS xinterm2_reg_process;


  subout <= const3 - mulout2delay;

  shiftout <= SHIFT_RIGHT(subout, 1);

  xinterm3_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shiftoutdelay <= to_signed(0, 32);
      ELSIF enb_1_23_0 = '1' THEN
        shiftoutdelay <= shiftout;
      END IF;
    END IF;
  END PROCESS xinterm3_reg_process;


  shiftmul <= shiftoutdelay & '0' & '0' & '0' & '0';

  xindelay3_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        xindelay3_reg_reg <= (OTHERS => to_signed(0, 32));
      ELSIF enb_1_23_0 = '1' THEN
        xindelay3_reg_reg(0) <= xindelay1;
        xindelay3_reg_reg(1) <= xindelay3_reg_reg(0);
      END IF;
    END IF;
  END PROCESS xindelay3_reg_process;

  xindelay3 <= xindelay3_reg_reg(1);

  mul2_mul_temp_1 <= shiftmul * xindelay3;
  mulout3 <= mul2_mul_temp_1(63 DOWNTO 32) + ('0' & mul2_mul_temp_1(31));

  xout_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        xout_tmp <= to_signed(0, 32);
      ELSIF enb_1_23_0 = '1' THEN
        xout_tmp <= mulout3;
      END IF;
    END IF;
  END PROCESS xout_reg_process;


  xout <= std_logic_vector(xout_tmp);

  aout_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        aout_reg_reg <= (OTHERS => to_unsigned(0, 32));
      ELSIF enb_1_23_0 = '1' THEN
        aout_reg_reg(0) <= ain_unsigned;
        aout_reg_reg(1 TO 3) <= aout_reg_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS aout_reg_process;

  aout_tmp <= aout_reg_reg(3);

  aout <= std_logic_vector(aout_tmp);

END rtl;

