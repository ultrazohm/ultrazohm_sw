-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\Encoder_Zynq\IncreEncoder_V19_ipcore_src_IncreEncoder_V19.vhd
-- Created: 2017-10-15 22:12:37
-- 
-- Generated by MATLAB 9.0 and HDL Coder 3.8
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1e-08
-- Target subsystem base rate: 2e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- omega_rps                     ce_out        2e-08
-- omega_rps_AXI4                ce_out        2e-08
-- thete_el                      ce_out        2e-08
-- thete_el_AXI4                 ce_out        2e-08
-- theta_mech_AXI4               ce_out        2e-08
-- edge_rsvd                     ce_out        2e-08
-- count                         ce_out        2e-08
-- direction_AXI4                ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: IncreEncoder_V19_ipcore_src_IncreEncoder_V19
-- Source Path: Encoder_Zynq/IncreEncoder_V19
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.IncreEncoder_V19_ipcore_src_IncreEncoder_V19_pkg.ALL;

ENTITY IncreEncoder_V19_ipcore_src_IncreEncoder_V19 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        A                                 :   IN    std_logic;
        B                                 :   IN    std_logic;
        I                                 :   IN    std_logic;
        PI2_Inc_AXI4                      :   IN    std_logic_vector(23 DOWNTO 0);  -- ufix24_En24
        IncPerTurn_AXI4                   :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        Timer_FPGA_ms_AXI4                :   IN    std_logic_vector(29 DOWNTO 0);  -- ufix30_En24
        IncPerTurn_mech_AXI4              :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        Inc_PerTurn_mech_2PI_AXI4         :   IN    std_logic_vector(23 DOWNTO 0);  -- ufix24_En24
        IncrementePerTurn_elek_AXI4       :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        ce_out                            :   OUT   std_logic;
        omega_rps                         :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En8
        omega_rps_AXI4                    :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En8
        thete_el                          :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        thete_el_AXI4                     :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        theta_mech_AXI4                   :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        edge_rsvd                         :   OUT   std_logic;
        count                             :   OUT   std_logic;
        direction_AXI4                    :   OUT   std_logic_vector(3 DOWNTO 0)  -- sfix4
        );
END IncreEncoder_V19_ipcore_src_IncreEncoder_V19;


ARCHITECTURE rtl OF IncreEncoder_V19_ipcore_src_IncreEncoder_V19 IS

  -- Component Declarations
  COMPONENT IncreEncoder_V19_ipcore_src_Counter_speed
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          Enable_ctr                      :   IN    std_logic;
          Reset_1                         :   IN    std_logic;
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- uint16
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V19_ipcore_src_n_aus_theta
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          count                           :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          T                               :   IN    std_logic_vector(29 DOWNTO 0);  -- ufix30_En24
          rps                             :   OUT   std_logic_vector(29 DOWNTO 0)  -- ufix30_En24
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V19_ipcore_src_Check_Direction
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          A                               :   IN    std_logic;
          B                               :   IN    std_logic;
          Dir                             :   OUT   std_logic_vector(3 DOWNTO 0)  -- sfix4
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V19_ipcore_src_Counter_theta_ele
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          Enable_ctr                      :   IN    std_logic;
          Reset_1                         :   IN    std_logic;
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V19_ipcore_src_Counter_theta
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          Enable_ctr                      :   IN    std_logic;
          Reset_1                         :   IN    std_logic;
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : IncreEncoder_V19_ipcore_src_Counter_speed
    USE ENTITY work.IncreEncoder_V19_ipcore_src_Counter_speed(rtl);

  FOR ALL : IncreEncoder_V19_ipcore_src_n_aus_theta
    USE ENTITY work.IncreEncoder_V19_ipcore_src_n_aus_theta(rtl);

  FOR ALL : IncreEncoder_V19_ipcore_src_Check_Direction
    USE ENTITY work.IncreEncoder_V19_ipcore_src_Check_Direction(rtl);

  FOR ALL : IncreEncoder_V19_ipcore_src_Counter_theta_ele
    USE ENTITY work.IncreEncoder_V19_ipcore_src_Counter_theta_ele(rtl);

  FOR ALL : IncreEncoder_V19_ipcore_src_Counter_theta
    USE ENTITY work.IncreEncoder_V19_ipcore_src_Counter_theta(rtl);

  -- Constants
  CONSTANT One                            : unsigned(32 DOWNTO 0) := 
    unsigned'("100000000000000000000000000000000");  -- ufix33
  CONSTANT C_divbyzero_p                  : unsigned(32 DOWNTO 0) := 
    unsigned'("111111111111111111111111111111111");  -- ufix33

  -- Signals
  SIGNAL enb_1_2_0                        : std_logic;
  SIGNAL Logical2_out1                    : std_logic;
  SIGNAL Logical2_out1_1                  : std_logic;
  SIGNAL Counter_speed_out1               : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL n_aus_theta_out1                 : std_logic_vector(29 DOWNTO 0);  -- ufix30
  SIGNAL n_aus_theta_out1_unsigned        : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL Divide_div_temp                  : unsigned(32 DOWNTO 0);  -- ufix33_En8
  SIGNAL Divide_out1                      : signed(17 DOWNTO 0);  -- sfix18_En8
  SIGNAL hold_out1                        : signed(17 DOWNTO 0);  -- sfix18_En8
  SIGNAL reduced_reg                      : vector_of_signed18(0 TO 2);  -- sfix18 [3]
  SIGNAL hold_out1_1                      : signed(17 DOWNTO 0);  -- sfix18_En8
  SIGNAL Logical1_out1                    : std_logic;
  SIGNAL Logical1_out1_1                  : std_logic;
  SIGNAL Check_Direction_out1             : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL Check_Direction_out1_signed      : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL hold1_out1                       : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL Counter_theta_ele_out1           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Counter_theta_ele_out1_signed    : signed(15 DOWNTO 0);  -- int16
  SIGNAL Data_Type_Conversion1_out1       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL reset_old2_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL PI2_Inc_AXI4_unsigned            : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL PI2_Inc_AXI4_1                   : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL Product_mul_temp                 : unsigned(39 DOWNTO 0);  -- ufix40_En24
  SIGNAL Product_out1                     : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL reset_old4_out1                  : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL reduced_reg_1                    : vector_of_signed24(0 TO 2);  -- sfix24 [3]
  SIGNAL reset_old4_out1_1                : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Counter_theta_out1               : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Counter_theta_out1_signed        : signed(15 DOWNTO 0);  -- int16
  SIGNAL Data_Type_Conversion9_out1       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL reset_old5_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Inc_PerTurn_mech_2PI_AXI4_unsigned : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL Inc_PerTurn_mech_2PI_AXI4_1      : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL Product1_mul_temp                : unsigned(39 DOWNTO 0);  -- ufix40_En24
  SIGNAL Product1_out1                    : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL out_4_pipe_reg                   : vector_of_signed24(0 TO 3);  -- sfix24 [4]
  SIGNAL reset_old3_out1                  : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Detec_edge_out1                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL reset_old1_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL reset_old_switch1_out1           : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Constant1_out1                   : std_logic;
  SIGNAL Constant_out1                    : std_logic;
  SIGNAL reset_old_switch3_out1           : std_logic;
  SIGNAL out_5_pipe_reg                   : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL reset_old_switch3_out1_1         : std_logic;
  SIGNAL out_6_pipe_reg                   : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL Logical1_out1_2                  : std_logic;
  SIGNAL delayMatch2_reg                  : vector_of_signed4(0 TO 3);  -- sfix4 [4]
  SIGNAL hold1_out1_1                     : signed(3 DOWNTO 0);  -- sfix4

BEGIN
  -- <S3>/Counter_speed
  u_Counter_speed : IncreEncoder_V19_ipcore_src_Counter_speed
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2_0 => clk_enable,
              Enable_ctr => Logical2_out1_1,
              Reset_1 => I,
              IncsPerTurn => IncPerTurn_AXI4,  -- uint16
              count => Counter_speed_out1  -- uint16
              );

  -- <S3>/n_aus_theta
  u_n_aus_theta : IncreEncoder_V19_ipcore_src_n_aus_theta
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2_0 => clk_enable,
              count => Counter_speed_out1,  -- uint16
              IncsPerTurn => IncPerTurn_AXI4,  -- uint16
              T => Timer_FPGA_ms_AXI4,  -- ufix30_En24
              rps => n_aus_theta_out1  -- ufix30_En24
              );

  -- <S3>/Check_Direction
  u_Check_Direction : IncreEncoder_V19_ipcore_src_Check_Direction
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2_0 => clk_enable,
              A => A,
              B => B,
              Dir => Check_Direction_out1  -- sfix4
              );

  -- <S3>/Counter_theta_ele
  u_Counter_theta_ele : IncreEncoder_V19_ipcore_src_Counter_theta_ele
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2_0 => clk_enable,
              Enable_ctr => Logical1_out1_1,
              Reset_1 => I,
              IncsPerTurn => IncrementePerTurn_elek_AXI4,  -- uint16
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              count => Counter_theta_ele_out1  -- int16
              );

  -- <S3>/Counter_theta
  u_Counter_theta : IncreEncoder_V19_ipcore_src_Counter_theta
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2_0 => clk_enable,
              Enable_ctr => Logical1_out1_1,
              Reset_1 => I,
              IncsPerTurn => IncPerTurn_mech_AXI4,  -- uint16
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              count => Counter_theta_out1  -- int16
              );

  -- <S3>/Logical2
  Logical2_out1 <=  NOT A;

  enb_1_2_0 <= clk_enable;

  Logical2_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Logical2_out1_1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Logical2_out1_1 <= Logical2_out1;
      END IF;
    END IF;
  END PROCESS Logical2_out_pipe_process;


  n_aus_theta_out1_unsigned <= unsigned(n_aus_theta_out1);

  -- <S3>/Divide
  
  Divide_div_temp <= C_divbyzero_p WHEN n_aus_theta_out1_unsigned = 0 ELSE
      One / n_aus_theta_out1_unsigned;
  
  Divide_out1 <= "011111111111111111" WHEN Divide_div_temp(32 DOWNTO 17) /= X"0000" ELSE
      signed(Divide_div_temp(17 DOWNTO 0));

  -- <S3>/hold
  hold_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hold_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        hold_out1 <= Divide_out1;
      END IF;
    END IF;
  END PROCESS hold_process;


  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb_1_2_0 = '1' THEN
        reduced_reg(0) <= hold_out1;
        reduced_reg(1 TO 2) <= reduced_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS reduced_process;

  hold_out1_1 <= reduced_reg(2);

  omega_rps <= std_logic_vector(hold_out1_1);

  omega_rps_AXI4 <= std_logic_vector(hold_out1_1);

  -- <S3>/Logical1
  Logical1_out1 <= A XOR B;

  Logical1_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Logical1_out1_1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Logical1_out1_1 <= Logical1_out1;
      END IF;
    END IF;
  END PROCESS Logical1_out_pipe_process;


  Check_Direction_out1_signed <= signed(Check_Direction_out1);

  -- <S3>/hold1
  hold1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hold1_out1 <= to_signed(16#0#, 4);
      ELSIF enb_1_2_0 = '1' THEN
        hold1_out1 <= Check_Direction_out1_signed;
      END IF;
    END IF;
  END PROCESS hold1_process;


  Counter_theta_ele_out1_signed <= signed(Counter_theta_ele_out1);

  -- <S3>/Data Type Conversion1
  Data_Type_Conversion1_out1 <= unsigned(Counter_theta_ele_out1_signed);

  -- <S3>/reset_old2
  reset_old2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old2_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        reset_old2_out1 <= Data_Type_Conversion1_out1;
      END IF;
    END IF;
  END PROCESS reset_old2_process;


  PI2_Inc_AXI4_unsigned <= unsigned(PI2_Inc_AXI4);

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        PI2_Inc_AXI4_1 <= to_unsigned(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        PI2_Inc_AXI4_1 <= PI2_Inc_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  -- <S3>/Product
  Product_mul_temp <= reset_old2_out1 * PI2_Inc_AXI4_1;
  Product_out1 <= signed(Product_mul_temp(27 DOWNTO 4));

  -- <S3>/reset_old4
  reset_old4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old4_out1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        reset_old4_out1 <= Product_out1;
      END IF;
    END IF;
  END PROCESS reset_old4_process;


  reduced_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg_1 <= (OTHERS => to_signed(16#000000#, 24));
      ELSIF enb_1_2_0 = '1' THEN
        reduced_reg_1(0) <= reset_old4_out1;
        reduced_reg_1(1 TO 2) <= reduced_reg_1(0 TO 1);
      END IF;
    END IF;
  END PROCESS reduced_1_process;

  reset_old4_out1_1 <= reduced_reg_1(2);

  thete_el <= std_logic_vector(reset_old4_out1_1);

  thete_el_AXI4 <= std_logic_vector(reset_old4_out1_1);

  Counter_theta_out1_signed <= signed(Counter_theta_out1);

  -- <S3>/Data Type Conversion9
  Data_Type_Conversion9_out1 <= unsigned(Counter_theta_out1_signed);

  -- <S3>/reset_old5
  reset_old5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old5_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        reset_old5_out1 <= Data_Type_Conversion9_out1;
      END IF;
    END IF;
  END PROCESS reset_old5_process;


  Inc_PerTurn_mech_2PI_AXI4_unsigned <= unsigned(Inc_PerTurn_mech_2PI_AXI4);

  delayMatch1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Inc_PerTurn_mech_2PI_AXI4_1 <= to_unsigned(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        Inc_PerTurn_mech_2PI_AXI4_1 <= Inc_PerTurn_mech_2PI_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS delayMatch1_process;


  -- <S3>/Product1
  Product1_mul_temp <= reset_old5_out1 * Inc_PerTurn_mech_2PI_AXI4_1;
  Product1_out1 <= signed(Product1_mul_temp(27 DOWNTO 4));

  -- <S3>/reset_old3
  out_4_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        out_4_pipe_reg <= (OTHERS => to_signed(16#000000#, 24));
      ELSIF enb_1_2_0 = '1' THEN
        out_4_pipe_reg(0) <= Product1_out1;
        out_4_pipe_reg(1 TO 3) <= out_4_pipe_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS out_4_pipe_process;

  reset_old3_out1 <= out_4_pipe_reg(3);

  theta_mech_AXI4 <= std_logic_vector(reset_old3_out1);

  -- <S3>/reset_old_switch1
  
  reset_old_switch1_out1 <= reset_old1_out1 WHEN Detec_edge_out1 = to_unsigned(16#00#, 8) ELSE
      Data_Type_Conversion9_out1;

  -- <S3>/reset_old1
  reset_old1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old1_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        reset_old1_out1 <= reset_old_switch1_out1;
      END IF;
    END IF;
  END PROCESS reset_old1_process;


  -- <S3>/Detec_edge
  Detec_edge_out1 <= resize(Data_Type_Conversion9_out1, 8) - resize(reset_old1_out1, 8);

  -- <S3>/Constant1
  Constant1_out1 <= '0';

  -- <S3>/Constant
  Constant_out1 <= '1';

  -- <S3>/reset_old_switch3
  
  reset_old_switch3_out1 <= Constant1_out1 WHEN Detec_edge_out1 = to_unsigned(16#00#, 8) ELSE
      Constant_out1;

  out_5_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        out_5_pipe_reg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        out_5_pipe_reg(0) <= reset_old_switch3_out1;
        out_5_pipe_reg(1 TO 2) <= out_5_pipe_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS out_5_pipe_process;

  reset_old_switch3_out1_1 <= out_5_pipe_reg(2);

  out_6_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        out_6_pipe_reg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        out_6_pipe_reg(0) <= Logical1_out1_1;
        out_6_pipe_reg(1 TO 2) <= out_6_pipe_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS out_6_pipe_process;

  Logical1_out1_2 <= out_6_pipe_reg(2);

  delayMatch2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch2_reg <= (OTHERS => to_signed(16#0#, 4));
      ELSIF enb_1_2_0 = '1' THEN
        delayMatch2_reg(0) <= hold1_out1;
        delayMatch2_reg(1 TO 3) <= delayMatch2_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS delayMatch2_process;

  hold1_out1_1 <= delayMatch2_reg(3);

  direction_AXI4 <= std_logic_vector(hold1_out1_1);

  ce_out <= clk_enable;

  edge_rsvd <= reset_old_switch3_out1_1;

  count <= Logical1_out1_2;

END rtl;

