-- -------------------------------------------------------------
-- 
-- File Name: C:\ultrazohm_sw\ip_cores\FCS_MPC_3Phase_SPMSM\hdlsrc\FCS_MPC_3Phase_SPMSM_V1\FCS_MPC_3Phase_SPMSM_V1_src_Subsystem1.vhd
-- Created: 2022-07-12 13:33:01
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1e-10
-- Target subsystem base rate: 1e-10
-- Explicit user oversample request: 100x
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- Index                         ce_out        1e-08
-- done_MPC                      ce_out        1e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: FCS_MPC_3Phase_SPMSM_V1_src_Subsystem1
-- Source Path: FCS_MPC_3Phase_SPMSM_V1/Microcontroller Software/Subsystem1
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.FCS_MPC_3Phase_SPMSM_V1_src_Subsystem1_pkg.ALL;

ENTITY FCS_MPC_3Phase_SPMSM_V1_src_Subsystem1 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        dq_Done_123_alphabeta_dq          :   IN    std_logic;
        ialpha                            :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        ibeta                             :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        u_dc_link_AXI                     :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        SampleTime_AXI                    :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        theta_el                          :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        omega_m                           :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        Rs_AXI                            :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        reciprocal_Ls_AXI                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        psiPM_AXI                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        ialpha_ref                        :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        ibeta_ref                         :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        pole_pairs_AXI                    :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        ce_out                            :   OUT   std_logic;
        Index                             :   OUT   std_logic_vector(31 DOWNTO 0);  -- int32
        done_MPC                          :   OUT   std_logic
        );
END FCS_MPC_3Phase_SPMSM_V1_src_Subsystem1;


ARCHITECTURE rtl OF FCS_MPC_3Phase_SPMSM_V1_src_Subsystem1 IS

  -- Component Declarations
  COMPONENT FCS_MPC_3Phase_SPMSM_V1_src_Subsystem1_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb                             :   OUT   std_logic;
          enb_1_100_0                     :   OUT   std_logic;
          enb_1_100_1                     :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT FCS_MPC_3Phase_SPMSM_V1_src_Detect_Rise_Positive
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          U                               :   IN    std_logic;
          Y                               :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_18_En11_to_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_24_En11_to_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT FCS_MPC_3Phase_SPMSM_V1_src_nfp_mul_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_24_En20_to_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in                          :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT FCS_MPC_3Phase_SPMSM_V1_src_MATLAB_Function
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          u_dc_link                       :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          i_ph_ctrl_alpha                 :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          i_ph_ctrl_beta                  :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          omega_el                        :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          theta_el                        :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          Rs                              :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          reciprocal_Ls                   :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          psiPM                           :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          ialpha_ref                      :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          ibeta_ref                       :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          SampleTime                      :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          vk                              :   IN    vector_of_std_logic_vector32(0 TO 1);  -- single [2]
          J                               :   OUT   vector_of_std_logic_vector32(0 TO 7);  -- single [8]
          v                               :   OUT   matrix_of_std_logic_vector32(0 TO 1, 0 TO 7)  -- single [2x8]
          );
  END COMPONENT;

  COMPONENT FCS_MPC_3Phase_SPMSM_V1_src_MATLAB_Function1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          J                               :   IN    vector_of_std_logic_vector32(0 TO 7);  -- single [8]
          v                               :   IN    matrix_of_std_logic_vector32(0 TO 1, 0 TO 7);  -- single [2x8]
          I                               :   OUT   std_logic_vector(31 DOWNTO 0);  -- int32
          v_opt                           :   OUT   vector_of_std_logic_vector32(0 TO 1)  -- single [2]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : FCS_MPC_3Phase_SPMSM_V1_src_Subsystem1_tc
    USE ENTITY work.FCS_MPC_3Phase_SPMSM_V1_src_Subsystem1_tc(rtl);

  FOR ALL : FCS_MPC_3Phase_SPMSM_V1_src_Detect_Rise_Positive
    USE ENTITY work.FCS_MPC_3Phase_SPMSM_V1_src_Detect_Rise_Positive(rtl);

  FOR ALL : FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_18_En11_to_single
    USE ENTITY work.FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_18_En11_to_single(rtl);

  FOR ALL : FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_24_En11_to_single
    USE ENTITY work.FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_24_En11_to_single(rtl);

  FOR ALL : FCS_MPC_3Phase_SPMSM_V1_src_nfp_mul_single
    USE ENTITY work.FCS_MPC_3Phase_SPMSM_V1_src_nfp_mul_single(rtl);

  FOR ALL : FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_24_En20_to_single
    USE ENTITY work.FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_24_En20_to_single(rtl);

  FOR ALL : FCS_MPC_3Phase_SPMSM_V1_src_MATLAB_Function
    USE ENTITY work.FCS_MPC_3Phase_SPMSM_V1_src_MATLAB_Function(rtl);

  FOR ALL : FCS_MPC_3Phase_SPMSM_V1_src_MATLAB_Function1
    USE ENTITY work.FCS_MPC_3Phase_SPMSM_V1_src_MATLAB_Function1(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL enb_1_100_1                      : std_logic;
  SIGNAL enb_1_100_0                      : std_logic;
  SIGNAL Detect_Rise_Positive_out1        : std_logic;
  SIGNAL Detect_Rise_Positive_out1_1      : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL u_dc_link_AXI_1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on2_out1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on2_out1_1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay2_bypass_reg                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay2_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay2_out1_1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Detect_Rise_Positive_out1_2      : std_logic;
  SIGNAL switch_compare_1_1               : std_logic;
  SIGNAL nfp_in                           : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL nfp_out_1_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on1_out1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on1_out1_1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay1_bypass_reg                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay1_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay1_out1_1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay1_out1_2                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL switch_compare_1_2               : std_logic;
  SIGNAL nfp_in_1                         : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL nfp_out_2_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on3_out1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on3_out1_1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay3_bypass_reg                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay3_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay3_out1_1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay3_out1_2                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL switch_compare_1_3               : std_logic;
  SIGNAL pole_pairs_AXI_1                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL pole_pairs_AXI_2                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL omega_m_1                        : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL Data_Type_Conversion1_out1       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL omega_el                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL omega_el_1                       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on4_out1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on4_out1_1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay4_bypass_reg                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay4_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay4_out1_1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay4_out1_2                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL switch_compare_1_4               : std_logic;
  SIGNAL theta_el_1                       : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL Data_Type_Conversion4_out1       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on5_out1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on5_out1_1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay5_bypass_reg                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay5_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay5_out1_1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay5_out1_2                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL switch_compare_1_5               : std_logic;
  SIGNAL Rs_AXI_1                         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on6_out1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on6_out1_1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay6_bypass_reg                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay6_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay6_out1_1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL switch_compare_1_6               : std_logic;
  SIGNAL reciprocal_Ls_AXI_1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on7_out1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on7_out1_1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay7_bypass_reg                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay7_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay7_out1_1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL switch_compare_1_7               : std_logic;
  SIGNAL psiPM_AXI_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on9_out1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on9_out1_1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay9_bypass_reg                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay9_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay9_out1_1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL switch_compare_1_8               : std_logic;
  SIGNAL ialpha_ref_1                     : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL Data_Type_Conversion12_out1      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on10_out1                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on10_out1_1               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay10_bypass_reg               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay10_out1                     : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay10_out1_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay10_out1_2                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL switch_compare_1_9               : std_logic;
  SIGNAL ibeta_ref_1                      : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL Data_Type_Conversion2_out1       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on11_out1                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on11_out1_1               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay11_bypass_reg               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay11_out1                     : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay11_out1_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay11_out1_2                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL switch_compare_1_10              : std_logic;
  SIGNAL SampleTime_AXI_1                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on12_out1                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_on12_out1_1               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay12_bypass_reg               : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay12_out1                     : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay12_out1_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL switch_compare_1_11              : std_logic;
  SIGNAL v_opt                            : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL DelayValue1_bypass_reg           : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL DelayValue1_bypass_reg_next      : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL DelayValue1_out1                 : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL DelayValue1_out1_1               : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Switch_on13_out1                 : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Switch_on13_out1_1               : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Delay13_bypass_reg               : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Delay13_bypass_reg_next          : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Delay13_out1                     : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Delay13_out1_1                   : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL J                                : vector_of_std_logic_vector32(0 TO 7);  -- ufix32 [8]
  SIGNAL v                                : matrix_of_std_logic_vector32(0 TO 1, 0 TO 7);  -- ufix32 [2x8]
  SIGNAL I                                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL I_signed                         : signed(31 DOWNTO 0);  -- int32
  SIGNAL t1_bypass_reg                    : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL I_1                              : signed(31 DOWNTO 0);  -- int32
  SIGNAL Detect_Rise_Positive_out1_3      : std_logic;

BEGIN
  u_Subsystem1_tc : FCS_MPC_3Phase_SPMSM_V1_src_Subsystem1_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              enb => enb,
              enb_1_100_0 => enb_1_100_0,
              enb_1_100_1 => enb_1_100_1
              );

  u_Detect_Rise_Positive : FCS_MPC_3Phase_SPMSM_V1_src_Detect_Rise_Positive
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              U => dq_Done_123_alphabeta_dq,
              Y => Detect_Rise_Positive_out1
              );

  u_FCS_MPC_3Phase_SPMSM_V1_Microcontroller_Software_Subsystem1_nfp_convert_sfix_18_En11_to_single : FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_18_En11_to_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => nfp_in,  -- sfix18_En11
              nfp_out => nfp_out_1_1  -- single
              );

  u_FCS_MPC_3Phase_SPMSM_V1_Microcontroller_Software_Subsystem1_nfp_convert_sfix_18_En11_to_single_1 : FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_18_En11_to_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => nfp_in_1,  -- sfix18_En11
              nfp_out => nfp_out_2_1  -- single
              );

  u_FCS_MPC_3Phase_SPMSM_V1_Microcontroller_Software_Subsystem1_nfp_convert_sfix_24_En11_to_single : FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_24_En11_to_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => omega_m_1,  -- sfix24_En11
              nfp_out => Data_Type_Conversion1_out1  -- single
              );

  u_nfp_mul_comp : FCS_MPC_3Phase_SPMSM_V1_src_nfp_mul_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => pole_pairs_AXI_2,  -- single
              nfp_in2 => Data_Type_Conversion1_out1,  -- single
              nfp_out => omega_el  -- single
              );

  u_FCS_MPC_3Phase_SPMSM_V1_Microcontroller_Software_Subsystem1_nfp_convert_sfix_24_En20_to_single : FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_24_En20_to_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => theta_el_1,  -- sfix24_En20
              nfp_out => Data_Type_Conversion4_out1  -- single
              );

  u_FCS_MPC_3Phase_SPMSM_V1_Microcontroller_Software_Subsystem1_nfp_convert_sfix_18_En11_to_single_2 : FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_18_En11_to_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => ialpha_ref_1,  -- sfix18_En11
              nfp_out => Data_Type_Conversion12_out1  -- single
              );

  u_FCS_MPC_3Phase_SPMSM_V1_Microcontroller_Software_Subsystem1_nfp_convert_sfix_18_En11_to_single_3 : FCS_MPC_3Phase_SPMSM_V1_src_nfp_convert_sfix_18_En11_to_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in => ibeta_ref_1,  -- sfix18_En11
              nfp_out => Data_Type_Conversion2_out1  -- single
              );

  u_MATLAB_Function : FCS_MPC_3Phase_SPMSM_V1_src_MATLAB_Function
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              u_dc_link => Switch_on2_out1,  -- single
              i_ph_ctrl_alpha => Switch_on1_out1,  -- single
              i_ph_ctrl_beta => Switch_on3_out1,  -- single
              omega_el => Switch_on4_out1,  -- single
              theta_el => Switch_on5_out1,  -- single
              Rs => Switch_on6_out1,  -- single
              reciprocal_Ls => Switch_on7_out1,  -- single
              psiPM => Switch_on9_out1,  -- single
              ialpha_ref => Switch_on10_out1,  -- single
              ibeta_ref => Switch_on11_out1,  -- single
              SampleTime => Switch_on12_out1,  -- single
              vk => Switch_on13_out1,  -- single [2]
              J => J,  -- single [8]
              v => v  -- single [2x8]
              );

  u_MATLAB_Function1 : FCS_MPC_3Phase_SPMSM_V1_src_MATLAB_Function1
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              J => J,  -- single [8]
              v => v,  -- single [2x8]
              I => I,  -- int32
              v_opt => v_opt  -- single [2]
              );

  Detect_Rise_Positive_out1_1 <= Detect_Rise_Positive_out1;

  
  switch_compare_1 <= '1' WHEN Detect_Rise_Positive_out1_1 = '1' ELSE
      '0';

  u_dc_link_AXI_1 <= u_dc_link_AXI;

  crp_out_delay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on2_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on2_out1_1 <= Switch_on2_out1;
      END IF;
    END IF;
  END PROCESS crp_out_delay1_process;


  Delay2_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay2_bypass_reg <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay2_bypass_reg <= Switch_on2_out1_1;
      END IF;
    END IF;
  END PROCESS Delay2_bypass_process;

  
  Delay2_out1 <= Switch_on2_out1_1 WHEN enb_1_100_1 = '1' ELSE
      Delay2_bypass_reg;

  Delay2_out1_1 <= Delay2_out1;

  
  Switch_on2_out1 <= Delay2_out1_1 WHEN switch_compare_1 = '0' ELSE
      u_dc_link_AXI_1;

  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Detect_Rise_Positive_out1_2 <= '0';
      ELSIF enb = '1' THEN
        Detect_Rise_Positive_out1_2 <= Detect_Rise_Positive_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_process;


  
  switch_compare_1_1 <= '1' WHEN Detect_Rise_Positive_out1_2 = '1' ELSE
      '0';

  nfp_in <= std_logic_vector(signed(ialpha));

  crp_out_delay2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on1_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on1_out1_1 <= Switch_on1_out1;
      END IF;
    END IF;
  END PROCESS crp_out_delay2_process;


  Delay1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay1_bypass_reg <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay1_bypass_reg <= Switch_on1_out1_1;
      END IF;
    END IF;
  END PROCESS Delay1_bypass_process;

  
  Delay1_out1 <= Switch_on1_out1_1 WHEN enb_1_100_1 = '1' ELSE
      Delay1_bypass_reg;

  Delay1_out1_1 <= Delay1_out1;

  delayMatch4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay1_out1_2 <= X"00000000";
      ELSIF enb = '1' THEN
        Delay1_out1_2 <= Delay1_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch4_process;


  
  Switch_on1_out1 <= Delay1_out1_2 WHEN switch_compare_1_1 = '0' ELSE
      nfp_out_1_1;

  
  switch_compare_1_2 <= '1' WHEN Detect_Rise_Positive_out1_2 = '1' ELSE
      '0';

  nfp_in_1 <= std_logic_vector(signed(ibeta));

  crp_out_delay3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on3_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on3_out1_1 <= Switch_on3_out1;
      END IF;
    END IF;
  END PROCESS crp_out_delay3_process;


  Delay3_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_bypass_reg <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay3_bypass_reg <= Switch_on3_out1_1;
      END IF;
    END IF;
  END PROCESS Delay3_bypass_process;

  
  Delay3_out1 <= Switch_on3_out1_1 WHEN enb_1_100_1 = '1' ELSE
      Delay3_bypass_reg;

  Delay3_out1_1 <= Delay3_out1;

  delayMatch6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_out1_2 <= X"00000000";
      ELSIF enb = '1' THEN
        Delay3_out1_2 <= Delay3_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch6_process;


  
  Switch_on3_out1 <= Delay3_out1_2 WHEN switch_compare_1_2 = '0' ELSE
      nfp_out_2_1;

  
  switch_compare_1_3 <= '1' WHEN Detect_Rise_Positive_out1_2 = '1' ELSE
      '0';

  pole_pairs_AXI_1 <= pole_pairs_AXI;

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        pole_pairs_AXI_2 <= X"00000000";
      ELSIF enb = '1' THEN
        pole_pairs_AXI_2 <= pole_pairs_AXI_1;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  omega_m_1 <= std_logic_vector(signed(omega_m));

  omega_el_1 <= omega_el;

  crp_out_delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on4_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on4_out1_1 <= Switch_on4_out1;
      END IF;
    END IF;
  END PROCESS crp_out_delay_process;


  Delay4_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay4_bypass_reg <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay4_bypass_reg <= Switch_on4_out1_1;
      END IF;
    END IF;
  END PROCESS Delay4_bypass_process;

  
  Delay4_out1 <= Switch_on4_out1_1 WHEN enb_1_100_1 = '1' ELSE
      Delay4_bypass_reg;

  Delay4_out1_1 <= Delay4_out1;

  delayMatch2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay4_out1_2 <= X"00000000";
      ELSIF enb = '1' THEN
        Delay4_out1_2 <= Delay4_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch2_process;


  
  Switch_on4_out1 <= Delay4_out1_2 WHEN switch_compare_1_3 = '0' ELSE
      omega_el_1;

  
  switch_compare_1_4 <= '1' WHEN Detect_Rise_Positive_out1_2 = '1' ELSE
      '0';

  theta_el_1 <= std_logic_vector(signed(theta_el));

  crp_out_delay4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on5_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on5_out1_1 <= Switch_on5_out1;
      END IF;
    END IF;
  END PROCESS crp_out_delay4_process;


  Delay5_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay5_bypass_reg <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay5_bypass_reg <= Switch_on5_out1_1;
      END IF;
    END IF;
  END PROCESS Delay5_bypass_process;

  
  Delay5_out1 <= Switch_on5_out1_1 WHEN enb_1_100_1 = '1' ELSE
      Delay5_bypass_reg;

  Delay5_out1_1 <= Delay5_out1;

  delayMatch8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay5_out1_2 <= X"00000000";
      ELSIF enb = '1' THEN
        Delay5_out1_2 <= Delay5_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch8_process;


  
  Switch_on5_out1 <= Delay5_out1_2 WHEN switch_compare_1_4 = '0' ELSE
      Data_Type_Conversion4_out1;

  
  switch_compare_1_5 <= '1' WHEN Detect_Rise_Positive_out1_1 = '1' ELSE
      '0';

  Rs_AXI_1 <= Rs_AXI;

  crp_out_delay5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on6_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on6_out1_1 <= Switch_on6_out1;
      END IF;
    END IF;
  END PROCESS crp_out_delay5_process;


  Delay6_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay6_bypass_reg <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay6_bypass_reg <= Switch_on6_out1_1;
      END IF;
    END IF;
  END PROCESS Delay6_bypass_process;

  
  Delay6_out1 <= Switch_on6_out1_1 WHEN enb_1_100_1 = '1' ELSE
      Delay6_bypass_reg;

  Delay6_out1_1 <= Delay6_out1;

  
  Switch_on6_out1 <= Delay6_out1_1 WHEN switch_compare_1_5 = '0' ELSE
      Rs_AXI_1;

  
  switch_compare_1_6 <= '1' WHEN Detect_Rise_Positive_out1_1 = '1' ELSE
      '0';

  reciprocal_Ls_AXI_1 <= reciprocal_Ls_AXI;

  crp_out_delay6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on7_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on7_out1_1 <= Switch_on7_out1;
      END IF;
    END IF;
  END PROCESS crp_out_delay6_process;


  Delay7_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay7_bypass_reg <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay7_bypass_reg <= Switch_on7_out1_1;
      END IF;
    END IF;
  END PROCESS Delay7_bypass_process;

  
  Delay7_out1 <= Switch_on7_out1_1 WHEN enb_1_100_1 = '1' ELSE
      Delay7_bypass_reg;

  Delay7_out1_1 <= Delay7_out1;

  
  Switch_on7_out1 <= Delay7_out1_1 WHEN switch_compare_1_6 = '0' ELSE
      reciprocal_Ls_AXI_1;

  
  switch_compare_1_7 <= '1' WHEN Detect_Rise_Positive_out1_1 = '1' ELSE
      '0';

  psiPM_AXI_1 <= psiPM_AXI;

  crp_out_delay7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on9_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on9_out1_1 <= Switch_on9_out1;
      END IF;
    END IF;
  END PROCESS crp_out_delay7_process;


  Delay9_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay9_bypass_reg <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay9_bypass_reg <= Switch_on9_out1_1;
      END IF;
    END IF;
  END PROCESS Delay9_bypass_process;

  
  Delay9_out1 <= Switch_on9_out1_1 WHEN enb_1_100_1 = '1' ELSE
      Delay9_bypass_reg;

  Delay9_out1_1 <= Delay9_out1;

  
  Switch_on9_out1 <= Delay9_out1_1 WHEN switch_compare_1_7 = '0' ELSE
      psiPM_AXI_1;

  
  switch_compare_1_8 <= '1' WHEN Detect_Rise_Positive_out1_2 = '1' ELSE
      '0';

  ialpha_ref_1 <= std_logic_vector(signed(ialpha_ref));

  crp_out_delay8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on10_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on10_out1_1 <= Switch_on10_out1;
      END IF;
    END IF;
  END PROCESS crp_out_delay8_process;


  Delay10_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay10_bypass_reg <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay10_bypass_reg <= Switch_on10_out1_1;
      END IF;
    END IF;
  END PROCESS Delay10_bypass_process;

  
  Delay10_out1 <= Switch_on10_out1_1 WHEN enb_1_100_1 = '1' ELSE
      Delay10_bypass_reg;

  Delay10_out1_1 <= Delay10_out1;

  delayMatch10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay10_out1_2 <= X"00000000";
      ELSIF enb = '1' THEN
        Delay10_out1_2 <= Delay10_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch10_process;


  
  Switch_on10_out1 <= Delay10_out1_2 WHEN switch_compare_1_8 = '0' ELSE
      Data_Type_Conversion12_out1;

  
  switch_compare_1_9 <= '1' WHEN Detect_Rise_Positive_out1_2 = '1' ELSE
      '0';

  ibeta_ref_1 <= std_logic_vector(signed(ibeta_ref));

  crp_out_delay9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on11_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on11_out1_1 <= Switch_on11_out1;
      END IF;
    END IF;
  END PROCESS crp_out_delay9_process;


  Delay11_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay11_bypass_reg <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay11_bypass_reg <= Switch_on11_out1_1;
      END IF;
    END IF;
  END PROCESS Delay11_bypass_process;

  
  Delay11_out1 <= Switch_on11_out1_1 WHEN enb_1_100_1 = '1' ELSE
      Delay11_bypass_reg;

  Delay11_out1_1 <= Delay11_out1;

  delayMatch12_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay11_out1_2 <= X"00000000";
      ELSIF enb = '1' THEN
        Delay11_out1_2 <= Delay11_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch12_process;


  
  Switch_on11_out1 <= Delay11_out1_2 WHEN switch_compare_1_9 = '0' ELSE
      Data_Type_Conversion2_out1;

  
  switch_compare_1_10 <= '1' WHEN Detect_Rise_Positive_out1_1 = '1' ELSE
      '0';

  SampleTime_AXI_1 <= SampleTime_AXI;

  crp_out_delay10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on12_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on12_out1_1 <= Switch_on12_out1;
      END IF;
    END IF;
  END PROCESS crp_out_delay10_process;


  Delay12_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay12_bypass_reg <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay12_bypass_reg <= Switch_on12_out1_1;
      END IF;
    END IF;
  END PROCESS Delay12_bypass_process;

  
  Delay12_out1 <= Switch_on12_out1_1 WHEN enb_1_100_1 = '1' ELSE
      Delay12_bypass_reg;

  Delay12_out1_1 <= Delay12_out1;

  
  Switch_on12_out1 <= Delay12_out1_1 WHEN switch_compare_1_10 = '0' ELSE
      SampleTime_AXI_1;

  
  switch_compare_1_11 <= '1' WHEN Detect_Rise_Positive_out1_1 = '1' ELSE
      '0';

  DelayValue1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        DelayValue1_bypass_reg(0) <= X"00000000";
        DelayValue1_bypass_reg(1) <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        DelayValue1_bypass_reg(0) <= DelayValue1_bypass_reg_next(0);
        DelayValue1_bypass_reg(1) <= DelayValue1_bypass_reg_next(1);
      END IF;
    END IF;
  END PROCESS DelayValue1_bypass_process;

  
  DelayValue1_out1(0) <= v_opt(0) WHEN enb_1_100_1 = '1' ELSE
      DelayValue1_bypass_reg(0);
  
  DelayValue1_out1(1) <= v_opt(1) WHEN enb_1_100_1 = '1' ELSE
      DelayValue1_bypass_reg(1);
  DelayValue1_bypass_reg_next(0) <= v_opt(0);
  DelayValue1_bypass_reg_next(1) <= v_opt(1);

  DelayValue1_out1_1 <= DelayValue1_out1;

  crp_out_delay11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on13_out1_1(0) <= X"00000000";
        Switch_on13_out1_1(1) <= X"00000000";
      ELSIF enb = '1' THEN
        Switch_on13_out1_1(0) <= Switch_on13_out1(0);
        Switch_on13_out1_1(1) <= Switch_on13_out1(1);
      END IF;
    END IF;
  END PROCESS crp_out_delay11_process;


  Delay13_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay13_bypass_reg(0) <= X"00000000";
        Delay13_bypass_reg(1) <= X"00000000";
      ELSIF enb_1_100_1 = '1' THEN
        Delay13_bypass_reg(0) <= Delay13_bypass_reg_next(0);
        Delay13_bypass_reg(1) <= Delay13_bypass_reg_next(1);
      END IF;
    END IF;
  END PROCESS Delay13_bypass_process;

  
  Delay13_out1(0) <= Switch_on13_out1_1(0) WHEN enb_1_100_1 = '1' ELSE
      Delay13_bypass_reg(0);
  
  Delay13_out1(1) <= Switch_on13_out1_1(1) WHEN enb_1_100_1 = '1' ELSE
      Delay13_bypass_reg(1);
  Delay13_bypass_reg_next(0) <= Switch_on13_out1_1(0);
  Delay13_bypass_reg_next(1) <= Switch_on13_out1_1(1);

  Delay13_out1_1 <= Delay13_out1;

  
  Switch_on13_out1(0) <= Delay13_out1_1(0) WHEN switch_compare_1_11 = '0' ELSE
      DelayValue1_out1_1(0);
  
  Switch_on13_out1(1) <= Delay13_out1_1(1) WHEN switch_compare_1_11 = '0' ELSE
      DelayValue1_out1_1(1);

  I_signed <= signed(I);

  t1_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        t1_bypass_reg <= to_signed(0, 32);
      ELSIF enb_1_100_1 = '1' THEN
        t1_bypass_reg <= I_signed;
      END IF;
    END IF;
  END PROCESS t1_bypass_process;

  
  I_1 <= I_signed WHEN enb_1_100_1 = '1' ELSE
      t1_bypass_reg;

  Index <= std_logic_vector(I_1);

  delayMatch13_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Detect_Rise_Positive_out1_3 <= '0';
      ELSIF enb_1_100_0 = '1' THEN
        Detect_Rise_Positive_out1_3 <= Detect_Rise_Positive_out1;
      END IF;
    END IF;
  END PROCESS delayMatch13_process;


  done_MPC <= Detect_Rise_Positive_out1_3;

  ce_out <= enb_1_100_1;

END rtl;

