-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\Encoder_Zynq\IncreEncoder_V18_ipcore_src_IncreEncoder_V18.vhd
-- Created: 2017-07-30 17:53:19
-- 
-- Generated by MATLAB 9.0 and HDL Coder 3.8
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1e-08
-- Target subsystem base rate: 2e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- rps                           ce_out        2e-08
-- rps_AXI4                      ce_out        2e-08
-- thete_el                      ce_out        2e-08
-- thete_el_AXI4                 ce_out        2e-08
-- theta_mech_AXI4               ce_out        2e-08
-- edge_rsvd                     ce_out        2e-08
-- count                         ce_out        2e-08
-- direction_AXI4                ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: IncreEncoder_V18_ipcore_src_IncreEncoder_V18
-- Source Path: Encoder_Zynq/IncreEncoder_V18
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.IncreEncoder_V18_ipcore_src_IncreEncoder_V18_pkg.ALL;

ENTITY IncreEncoder_V18_ipcore_src_IncreEncoder_V18 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        A                                 :   IN    std_logic;
        B                                 :   IN    std_logic;
        I                                 :   IN    std_logic;
        PI2_Inc_AXI4                      :   IN    std_logic_vector(23 DOWNTO 0);  -- ufix24_En24
        IncPerTurn_AXI4                   :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        Timer_FPGA_ms_AXI4                :   IN    std_logic_vector(29 DOWNTO 0);  -- ufix30_En24
        IncPerTurn_mech_AXI4              :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        Inc_PerTurn_mech_2PI_AXI4         :   IN    std_logic_vector(23 DOWNTO 0);  -- ufix24_En24
        IncrementePerTurn_elek_AXI4       :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        ce_out                            :   OUT   std_logic;
        rps                               :   OUT   std_logic_vector(29 DOWNTO 0);  -- ufix30_En24
        rps_AXI4                          :   OUT   std_logic_vector(29 DOWNTO 0);  -- ufix30_En24
        thete_el                          :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        thete_el_AXI4                     :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        theta_mech_AXI4                   :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        edge_rsvd                         :   OUT   std_logic;
        count                             :   OUT   std_logic;
        direction_AXI4                    :   OUT   std_logic_vector(3 DOWNTO 0)  -- sfix4
        );
END IncreEncoder_V18_ipcore_src_IncreEncoder_V18;


ARCHITECTURE rtl OF IncreEncoder_V18_ipcore_src_IncreEncoder_V18 IS

  -- Component Declarations
  COMPONENT IncreEncoder_V18_ipcore_src_Counter_speed
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          Enable_ctr                      :   IN    std_logic;
          Reset_1                         :   IN    std_logic;
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- uint16
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V18_ipcore_src_n_aus_theta
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          count                           :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          T                               :   IN    std_logic_vector(29 DOWNTO 0);  -- ufix30_En24
          rps                             :   OUT   std_logic_vector(29 DOWNTO 0)  -- ufix30_En24
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V18_ipcore_src_Check_Direction
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          A                               :   IN    std_logic;
          B                               :   IN    std_logic;
          Dir                             :   OUT   std_logic_vector(3 DOWNTO 0)  -- sfix4
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V18_ipcore_src_Counter_theta_ele
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          Enable_ctr                      :   IN    std_logic;
          Reset_1                         :   IN    std_logic;
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V18_ipcore_src_Counter_theta
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2_0                       :   IN    std_logic;
          Enable_ctr                      :   IN    std_logic;
          Reset_1                         :   IN    std_logic;
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : IncreEncoder_V18_ipcore_src_Counter_speed
    USE ENTITY work.IncreEncoder_V18_ipcore_src_Counter_speed(rtl);

  FOR ALL : IncreEncoder_V18_ipcore_src_n_aus_theta
    USE ENTITY work.IncreEncoder_V18_ipcore_src_n_aus_theta(rtl);

  FOR ALL : IncreEncoder_V18_ipcore_src_Check_Direction
    USE ENTITY work.IncreEncoder_V18_ipcore_src_Check_Direction(rtl);

  FOR ALL : IncreEncoder_V18_ipcore_src_Counter_theta_ele
    USE ENTITY work.IncreEncoder_V18_ipcore_src_Counter_theta_ele(rtl);

  FOR ALL : IncreEncoder_V18_ipcore_src_Counter_theta
    USE ENTITY work.IncreEncoder_V18_ipcore_src_Counter_theta(rtl);

  -- Signals
  SIGNAL enb_1_2_0                        : std_logic;
  SIGNAL Logical2_out1                    : std_logic;
  SIGNAL Logical2_out1_1                  : std_logic;
  SIGNAL Counter_speed_out1               : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL n_aus_theta_out1                 : std_logic_vector(29 DOWNTO 0);  -- ufix30
  SIGNAL n_aus_theta_out1_unsigned        : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL hold_out1                        : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL hold_out1_1                      : unsigned(29 DOWNTO 0);  -- ufix30_En24
  SIGNAL Logical1_out1                    : std_logic;
  SIGNAL Logical1_out1_1                  : std_logic;
  SIGNAL Check_Direction_out1             : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL Check_Direction_out1_signed      : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL hold1_out1                       : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL Counter_theta_ele_out1           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Counter_theta_ele_out1_signed    : signed(15 DOWNTO 0);  -- int16
  SIGNAL Data_Type_Conversion1_out1       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL reset_old2_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL PI2_Inc_AXI4_unsigned            : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL PI2_Inc_AXI4_1                   : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL Product_mul_temp                 : unsigned(39 DOWNTO 0);  -- ufix40_En24
  SIGNAL Product_out1                     : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL reset_old4_out1                  : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL reset_old4_out1_1                : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Counter_theta_out1               : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Counter_theta_out1_signed        : signed(15 DOWNTO 0);  -- int16
  SIGNAL Data_Type_Conversion9_out1       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL reset_old5_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Inc_PerTurn_mech_2PI_AXI4_unsigned : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL Inc_PerTurn_mech_2PI_AXI4_1      : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL Product1_mul_temp                : unsigned(39 DOWNTO 0);  -- ufix40_En24
  SIGNAL Product1_out1                    : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL out_4_pipe_reg                   : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL reset_old3_out1                  : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Detec_edge_out1                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL reset_old1_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL reset_old_switch1_out1           : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Constant1_out1                   : std_logic;
  SIGNAL Constant_out1                    : std_logic;
  SIGNAL reset_old_switch3_out1           : std_logic;
  SIGNAL reset_old_switch3_out1_1         : std_logic;
  SIGNAL Logical1_out1_2                  : std_logic;
  SIGNAL delayMatch2_reg                  : vector_of_signed4(0 TO 1);  -- sfix4 [2]
  SIGNAL hold1_out1_1                     : signed(3 DOWNTO 0);  -- sfix4

BEGIN
  -- <S2>/Counter_speed
  u_Counter_speed : IncreEncoder_V18_ipcore_src_Counter_speed
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2_0 => clk_enable,
              Enable_ctr => Logical2_out1_1,
              Reset_1 => I,
              IncsPerTurn => IncPerTurn_AXI4,  -- uint16
              count => Counter_speed_out1  -- uint16
              );

  -- <S2>/n_aus_theta
  u_n_aus_theta : IncreEncoder_V18_ipcore_src_n_aus_theta
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2_0 => clk_enable,
              count => Counter_speed_out1,  -- uint16
              IncsPerTurn => IncPerTurn_AXI4,  -- uint16
              T => Timer_FPGA_ms_AXI4,  -- ufix30_En24
              rps => n_aus_theta_out1  -- ufix30_En24
              );

  -- <S2>/Check_Direction
  u_Check_Direction : IncreEncoder_V18_ipcore_src_Check_Direction
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2_0 => clk_enable,
              A => A,
              B => B,
              Dir => Check_Direction_out1  -- sfix4
              );

  -- <S2>/Counter_theta_ele
  u_Counter_theta_ele : IncreEncoder_V18_ipcore_src_Counter_theta_ele
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2_0 => clk_enable,
              Enable_ctr => Logical1_out1_1,
              Reset_1 => I,
              IncsPerTurn => IncrementePerTurn_elek_AXI4,  -- uint16
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              count => Counter_theta_ele_out1  -- int16
              );

  -- <S2>/Counter_theta
  u_Counter_theta : IncreEncoder_V18_ipcore_src_Counter_theta
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2_0 => clk_enable,
              Enable_ctr => Logical1_out1_1,
              Reset_1 => I,
              IncsPerTurn => IncPerTurn_mech_AXI4,  -- uint16
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              count => Counter_theta_out1  -- int16
              );

  -- <S2>/Logical2
  Logical2_out1 <=  NOT A;

  enb_1_2_0 <= clk_enable;

  Logical2_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Logical2_out1_1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Logical2_out1_1 <= Logical2_out1;
      END IF;
    END IF;
  END PROCESS Logical2_out_pipe_process;


  n_aus_theta_out1_unsigned <= unsigned(n_aus_theta_out1);

  -- <S2>/hold
  hold_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hold_out1 <= to_unsigned(16#00000000#, 30);
      ELSIF enb_1_2_0 = '1' THEN
        hold_out1 <= n_aus_theta_out1_unsigned;
      END IF;
    END IF;
  END PROCESS hold_process;


  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hold_out1_1 <= to_unsigned(16#00000000#, 30);
      ELSIF enb_1_2_0 = '1' THEN
        hold_out1_1 <= hold_out1;
      END IF;
    END IF;
  END PROCESS reduced_process;


  rps <= std_logic_vector(hold_out1_1);

  rps_AXI4 <= std_logic_vector(hold_out1_1);

  -- <S2>/Logical1
  Logical1_out1 <= A XOR B;

  Logical1_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Logical1_out1_1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Logical1_out1_1 <= Logical1_out1;
      END IF;
    END IF;
  END PROCESS Logical1_out_pipe_process;


  Check_Direction_out1_signed <= signed(Check_Direction_out1);

  -- <S2>/hold1
  hold1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hold1_out1 <= to_signed(16#0#, 4);
      ELSIF enb_1_2_0 = '1' THEN
        hold1_out1 <= Check_Direction_out1_signed;
      END IF;
    END IF;
  END PROCESS hold1_process;


  Counter_theta_ele_out1_signed <= signed(Counter_theta_ele_out1);

  -- <S2>/Data Type Conversion1
  Data_Type_Conversion1_out1 <= unsigned(Counter_theta_ele_out1_signed);

  -- <S2>/reset_old2
  reset_old2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old2_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        reset_old2_out1 <= Data_Type_Conversion1_out1;
      END IF;
    END IF;
  END PROCESS reset_old2_process;


  PI2_Inc_AXI4_unsigned <= unsigned(PI2_Inc_AXI4);

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        PI2_Inc_AXI4_1 <= to_unsigned(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        PI2_Inc_AXI4_1 <= PI2_Inc_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  -- <S2>/Product
  Product_mul_temp <= reset_old2_out1 * PI2_Inc_AXI4_1;
  Product_out1 <= signed(Product_mul_temp(27 DOWNTO 4));

  -- <S2>/reset_old4
  reset_old4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old4_out1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        reset_old4_out1 <= Product_out1;
      END IF;
    END IF;
  END PROCESS reset_old4_process;


  reduced_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old4_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        reset_old4_out1_1 <= reset_old4_out1;
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  thete_el <= std_logic_vector(reset_old4_out1_1);

  thete_el_AXI4 <= std_logic_vector(reset_old4_out1_1);

  Counter_theta_out1_signed <= signed(Counter_theta_out1);

  -- <S2>/Data Type Conversion9
  Data_Type_Conversion9_out1 <= unsigned(Counter_theta_out1_signed);

  -- <S2>/reset_old5
  reset_old5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old5_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        reset_old5_out1 <= Data_Type_Conversion9_out1;
      END IF;
    END IF;
  END PROCESS reset_old5_process;


  Inc_PerTurn_mech_2PI_AXI4_unsigned <= unsigned(Inc_PerTurn_mech_2PI_AXI4);

  delayMatch1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Inc_PerTurn_mech_2PI_AXI4_1 <= to_unsigned(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        Inc_PerTurn_mech_2PI_AXI4_1 <= Inc_PerTurn_mech_2PI_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS delayMatch1_process;


  -- <S2>/Product1
  Product1_mul_temp <= reset_old5_out1 * Inc_PerTurn_mech_2PI_AXI4_1;
  Product1_out1 <= signed(Product1_mul_temp(27 DOWNTO 4));

  -- <S2>/reset_old3
  out_4_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        out_4_pipe_reg <= (OTHERS => to_signed(16#000000#, 24));
      ELSIF enb_1_2_0 = '1' THEN
        out_4_pipe_reg(0) <= Product1_out1;
        out_4_pipe_reg(1) <= out_4_pipe_reg(0);
      END IF;
    END IF;
  END PROCESS out_4_pipe_process;

  reset_old3_out1 <= out_4_pipe_reg(1);

  theta_mech_AXI4 <= std_logic_vector(reset_old3_out1);

  -- <S2>/reset_old_switch1
  
  reset_old_switch1_out1 <= reset_old1_out1 WHEN Detec_edge_out1 = to_unsigned(16#00#, 8) ELSE
      Data_Type_Conversion9_out1;

  -- <S2>/reset_old1
  reset_old1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old1_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        reset_old1_out1 <= reset_old_switch1_out1;
      END IF;
    END IF;
  END PROCESS reset_old1_process;


  -- <S2>/Detec_edge
  Detec_edge_out1 <= resize(Data_Type_Conversion9_out1, 8) - resize(reset_old1_out1, 8);

  -- <S2>/Constant1
  Constant1_out1 <= '0';

  -- <S2>/Constant
  Constant_out1 <= '1';

  -- <S2>/reset_old_switch3
  
  reset_old_switch3_out1 <= Constant1_out1 WHEN Detec_edge_out1 = to_unsigned(16#00#, 8) ELSE
      Constant_out1;

  out_5_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old_switch3_out1_1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        reset_old_switch3_out1_1 <= reset_old_switch3_out1;
      END IF;
    END IF;
  END PROCESS out_5_pipe_process;


  out_6_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Logical1_out1_2 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Logical1_out1_2 <= Logical1_out1_1;
      END IF;
    END IF;
  END PROCESS out_6_pipe_process;


  delayMatch2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch2_reg <= (OTHERS => to_signed(16#0#, 4));
      ELSIF enb_1_2_0 = '1' THEN
        delayMatch2_reg(0) <= hold1_out1;
        delayMatch2_reg(1) <= delayMatch2_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch2_process;

  hold1_out1_1 <= delayMatch2_reg(1);

  direction_AXI4 <= std_logic_vector(hold1_out1_1);

  ce_out <= clk_enable;

  edge_rsvd <= reset_old_switch3_out1_1;

  count <= Logical1_out1_2;

END rtl;

