-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\inc_enc_v25\Incremental_Encoder_src_IncEnc_V25.vhd
-- Created: 2022-04-20 12:43:13
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1e-08
-- Target subsystem base rate: 1e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- omega                         ce_out        1e-08
-- omega_AXI4                    ce_out        1e-08
-- theta_el                      ce_out        1e-08
-- theta_el_AXI4                 ce_out        1e-08
-- position                      ce_out        1e-08
-- position_AXI4                 ce_out        1e-08
-- edge_rsvd                     ce_out        1e-08
-- count                         ce_out        1e-08
-- direction_AXI4                ce_out        1e-08
-- countPerPeriod_AXI4           ce_out        1e-08
-- OverSamplFactor               ce_out        1e-08
-- omega_MA_N4                   ce_out        1e-08
-- omega_MA_N4_AXI               ce_out        1e-08
-- timeout_active                ce_out        1e-08
-- omegaA                        ce_out        1e-08
-- omegaNOTA                     ce_out        1e-08
-- omegaB                        ce_out        1e-08
-- omegaNOTB                     ce_out        1e-08
-- new_measurement               ce_out        1e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Incremental_Encoder_src_IncEnc_V25
-- Source Path: inc_enc_v25/IncEnc_V25
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY Incremental_Encoder_src_IncEnc_V25 IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        A                                 :   IN    std_logic;
        B                                 :   IN    std_logic;
        I                                 :   IN    std_logic;
        PI2_Inc_AXI4                      :   IN    std_logic_vector(23 DOWNTO 0);  -- ufix24_En24
        Timer_FPGA_ms_AXI4                :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En32
        IncPerTurn_mech_AXI4              :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        IncPerTurn_elek_AXI4              :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        OmegaPerOverSampl_AXI4            :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        PeriodEnd                         :   IN    std_logic;
        timeout_value_AXI4                :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        ce_out                            :   OUT   std_logic;
        omega                             :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        omega_AXI4                        :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        theta_el                          :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        theta_el_AXI4                     :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        position                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
        position_AXI4                     :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
        edge_rsvd                         :   OUT   std_logic;  -- ufix1
        count                             :   OUT   std_logic;
        direction_AXI4                    :   OUT   std_logic_vector(3 DOWNTO 0);  -- sfix4
        countPerPeriod_AXI4               :   OUT   std_logic_vector(15 DOWNTO 0);  -- int16
        OverSamplFactor                   :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
        omega_MA_N4                       :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        omega_MA_N4_AXI                   :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        timeout_active                    :   OUT   std_logic;
        omegaA                            :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        omegaNOTA                         :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        omegaB                            :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        omegaNOTB                         :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        new_measurement                   :   OUT   std_logic
        );
END Incremental_Encoder_src_IncEnc_V25;


ARCHITECTURE rtl OF Incremental_Encoder_src_IncEnc_V25 IS

  -- Component Declarations
  COMPONENT Incremental_Encoder_src_Direction
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          A                               :   IN    std_logic;
          B                               :   IN    std_logic;
          Dir                             :   OUT   std_logic_vector(3 DOWNTO 0)  -- sfix4
          );
  END COMPONENT;

  COMPONENT Incremental_Encoder_src_speed
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          A                               :   IN    std_logic;
          B                               :   IN    std_logic;
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          OmegaPerOverSampl               :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          T                               :   IN    std_logic_vector(37 DOWNTO 0);  -- sfix38_En32
          timeout_value                   :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
          omega                           :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          OverSamplFactor                 :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
          omega_MA_N4                     :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          timeout_active                  :   OUT   std_logic;
          omegaA                          :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          omegaB                          :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          omegaNOTA                       :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          omegaNOTB                       :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          new_measurement                 :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT Incremental_Encoder_src_Counter
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          Enable_ctr                      :   IN    std_logic;
          I_line                          :   IN    std_logic;
          Edge_rsvd                       :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
          Reset                           :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  COMPONENT Incremental_Encoder_src_Counter_theta_ele
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          Edge_rsvd                       :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          Reset                           :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          );
  END COMPONENT;

  COMPONENT Incremental_Encoder_src_Counter_position
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          Edge_rsvd                       :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          Reset                           :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- uint16
          );
  END COMPONENT;

  COMPONENT Incremental_Encoder_src_count_lines
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb                             :   IN    std_logic;
          Edge_rsvd                       :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          Reset                           :   IN    std_logic;
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Incremental_Encoder_src_Direction
    USE ENTITY work.Incremental_Encoder_src_Direction(rtl);

  FOR ALL : Incremental_Encoder_src_speed
    USE ENTITY work.Incremental_Encoder_src_speed(rtl);

  FOR ALL : Incremental_Encoder_src_Counter
    USE ENTITY work.Incremental_Encoder_src_Counter(rtl);

  FOR ALL : Incremental_Encoder_src_Counter_theta_ele
    USE ENTITY work.Incremental_Encoder_src_Counter_theta_ele(rtl);

  FOR ALL : Incremental_Encoder_src_Counter_position
    USE ENTITY work.Incremental_Encoder_src_Counter_position(rtl);

  FOR ALL : Incremental_Encoder_src_count_lines
    USE ENTITY work.Incremental_Encoder_src_count_lines(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL A_1                              : std_logic;
  SIGNAL Delay6_out1                      : std_logic;
  SIGNAL B_1                              : std_logic;
  SIGNAL Delay1_out1                      : std_logic;
  SIGNAL Direction_out1                   : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL Direction_out1_signed            : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL hold1_out1                       : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL OmegaPerOverSampl_AXI4_signed    : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL OmegaPerOverSampl_AXI4_1         : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL Timer_FPGA_ms_AXI4_unsigned      : unsigned(31 DOWNTO 0);  -- ufix32_En32
  SIGNAL Timer_FPGA_ms_AXI4_1             : unsigned(31 DOWNTO 0);  -- ufix32_En32
  SIGNAL Data_Type_Conversion3_out1       : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL Pipeline7_out1                   : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL timeout_value_AXI4_unsigned      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL timeout_value_AXI4_1             : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL x_k                              : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL speed_out2                       : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL omega_moving_average             : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL timeout_active_all_ORed          : std_logic;
  SIGNAL speed_out5                       : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL speed_out6                       : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL speed_out7                       : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL speed_out8                       : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL newMeas_allORed                  : std_logic;
  SIGNAL x_k_signed                       : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL x_k_1                            : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL PI2_Inc_AXI4_unsigned            : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL PI2_Inc_AXI4_1                   : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL Pipeline8_out1                   : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL count_1                          : std_logic;
  SIGNAL count_2                          : std_logic;
  SIGNAL I_1                              : std_logic;
  SIGNAL edge_rsvd_1                      : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL Counter_out2                     : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL IncPerTurn_elek_AXI4_unsigned    : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL IncPerTurn_elek_AXI4_1           : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_el                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL count_el_signed                  : signed(15 DOWNTO 0);  -- int16
  SIGNAL Pipeline9_out1                   : signed(15 DOWNTO 0);  -- int16
  SIGNAL Product_theta_el_cast            : signed(24 DOWNTO 0);  -- sfix25_En24
  SIGNAL Product_theta_el_mul_temp        : signed(40 DOWNTO 0);  -- sfix41_En24
  SIGNAL Product_theta_el_cast_1          : signed(39 DOWNTO 0);  -- sfix40_En24
  SIGNAL theta_el_1                       : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL theta_el_tmp                     : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL IncPerTurn_mech_AXI4_unsigned    : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL IncPerTurn_mech_AXI4_1           : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_mech                       : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL count_mech_unsigned              : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL position_tmp                     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL edge_signed                      : signed(7 DOWNTO 0);  -- int8
  SIGNAL Abs_y                            : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL edge_rsvd_2                      : std_logic;  -- ufix1
  SIGNAL hold1_out1_1                     : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL PeriodEnd_1                      : std_logic;
  SIGNAL countPerPEriod                   : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL countPerPEriod_signed            : signed(15 DOWNTO 0);  -- int16
  SIGNAL countPerPEriod_1                 : signed(15 DOWNTO 0);  -- int16
  SIGNAL speed_out2_unsigned              : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL speed_out2_1                     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL omega_moving_average_signed      : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL omega_moving_average_1           : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL timeout_active_all_ORed_1        : std_logic;
  SIGNAL speed_out5_signed                : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL speed_out5_1                     : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL speed_out7_signed                : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL speed_out7_1                     : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL speed_out6_signed                : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL speed_out6_1                     : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL speed_out8_signed                : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL speed_out8_1                     : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL newMeas_allORed_1                : std_logic;
  SIGNAL position_1                       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL theta_el_2                       : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL x_k_2                            : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL omega_moving_average_2           : signed(23 DOWNTO 0);  -- sfix24_En11

BEGIN
  -- Speed
  -- 
  -- position
  -- This functionality gives the mechanical position of the encoder. The range of the output is "0-Increments", whereby 
  -- the increments depend on the used encoder
  -- - By doing so, the mechanical position is still available. However, the multiplication for scaling to 2PI is avoided 
  -- (resource efficient). The position can be used e.g. for position control
  -- - If the mechanical angle is required, e.g. for an asynchronous machine, theta can be used after parameterization 
  -- with pole pair 1
  -- 
  -- theta
  -- This functionality gives theta of the encoder. The range of the output is "0-2PI".
  -- - The pole pair number and incrments are necessary in order to result the electrical angle (theta).
  -- - If the mechanical angle is required, e.g. for an asynchronous machine, theta can be used after parameterization 
  -- with pole pair 1
  -- 
  -- keep these delays to avoid timing issues,
  -- since A and B are direct inputs and 
  -- not synchronous to any clock.
  -- Otherwise some ugly run-time 
  -- behavior might occur.

  u_Direction : Incremental_Encoder_src_Direction
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => clk_enable,
              A => Delay6_out1,
              B => Delay1_out1,
              Dir => Direction_out1  -- sfix4
              );

  u_speed : Incremental_Encoder_src_speed
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => clk_enable,
              A => Delay6_out1,
              B => Delay1_out1,
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              OmegaPerOverSampl => std_logic_vector(OmegaPerOverSampl_AXI4_1),  -- sfix24_En11
              T => std_logic_vector(Pipeline7_out1),  -- sfix38_En32
              timeout_value => std_logic_vector(timeout_value_AXI4_1),  -- uint32
              omega => x_k,  -- sfix24_En11
              OverSamplFactor => speed_out2,  -- uint16
              omega_MA_N4 => omega_moving_average,  -- sfix24_En11
              timeout_active => timeout_active_all_ORed,
              omegaA => speed_out5,  -- sfix24_En11
              omegaB => speed_out6,  -- sfix24_En11
              omegaNOTA => speed_out7,  -- sfix24_En11
              omegaNOTB => speed_out8,  -- sfix24_En11
              new_measurement => newMeas_allORed
              );

  u_Counter : Incremental_Encoder_src_Counter
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => clk_enable,
              Enable_ctr => count_2,
              I_line => I_1,
              Edge_rsvd => edge_rsvd_1,  -- int8
              Reset => Counter_out2  -- uint8
              );

  u_Counter_theta_ele : Incremental_Encoder_src_Counter_theta_ele
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => clk_enable,
              Edge_rsvd => edge_rsvd_1,  -- int8
              Reset => Counter_out2,  -- uint8
              IncsPerTurn => std_logic_vector(IncPerTurn_elek_AXI4_1),  -- uint16
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              count => count_el  -- int16
              );

  u_Counter_position : Incremental_Encoder_src_Counter_position
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => clk_enable,
              Edge_rsvd => edge_rsvd_1,  -- int8
              Reset => Counter_out2,  -- uint8
              IncsPerTurn => std_logic_vector(IncPerTurn_mech_AXI4_1),  -- uint16
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              count => count_mech  -- uint16
              );

  u_count_lines : Incremental_Encoder_src_count_lines
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb => clk_enable,
              Edge_rsvd => edge_rsvd_1,  -- int8
              Reset => PeriodEnd_1,
              IncsPerTurn => std_logic_vector(IncPerTurn_mech_AXI4_1),  -- uint16
              count => countPerPEriod  -- int16
              );

  enb <= clk_enable;

  in_0_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        A_1 <= '0';
      ELSIF enb = '1' THEN
        A_1 <= A;
      END IF;
    END IF;
  END PROCESS in_0_pipe_process;


  Delay6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay6_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay6_out1 <= A_1;
      END IF;
    END IF;
  END PROCESS Delay6_process;


  in_1_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        B_1 <= '0';
      ELSIF enb = '1' THEN
        B_1 <= B;
      END IF;
    END IF;
  END PROCESS in_1_pipe_process;


  Delay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay1_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay1_out1 <= B_1;
      END IF;
    END IF;
  END PROCESS Delay1_process;


  Direction_out1_signed <= signed(Direction_out1);

  hold1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        hold1_out1 <= to_signed(16#0#, 4);
      ELSIF enb = '1' THEN
        hold1_out1 <= Direction_out1_signed;
      END IF;
    END IF;
  END PROCESS hold1_process;


  OmegaPerOverSampl_AXI4_signed <= signed(OmegaPerOverSampl_AXI4);

  in_7_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        OmegaPerOverSampl_AXI4_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        OmegaPerOverSampl_AXI4_1 <= OmegaPerOverSampl_AXI4_signed;
      END IF;
    END IF;
  END PROCESS in_7_pipe_process;


  Timer_FPGA_ms_AXI4_unsigned <= unsigned(Timer_FPGA_ms_AXI4);

  in_4_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Timer_FPGA_ms_AXI4_1 <= to_unsigned(0, 32);
      ELSIF enb = '1' THEN
        Timer_FPGA_ms_AXI4_1 <= Timer_FPGA_ms_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS in_4_pipe_process;


  Data_Type_Conversion3_out1 <= signed(resize(Timer_FPGA_ms_AXI4_1, 38));

  Pipeline7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Pipeline7_out1 <= to_signed(0, 38);
      ELSIF enb = '1' THEN
        Pipeline7_out1 <= Data_Type_Conversion3_out1;
      END IF;
    END IF;
  END PROCESS Pipeline7_process;


  timeout_value_AXI4_unsigned <= unsigned(timeout_value_AXI4);

  in_9_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        timeout_value_AXI4_1 <= to_unsigned(0, 32);
      ELSIF enb = '1' THEN
        timeout_value_AXI4_1 <= timeout_value_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS in_9_pipe_process;


  x_k_signed <= signed(x_k);

  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        x_k_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        x_k_1 <= x_k_signed;
      END IF;
    END IF;
  END PROCESS reduced_process;


  omega <= std_logic_vector(x_k_1);

  omega_AXI4 <= std_logic_vector(x_k_1);

  PI2_Inc_AXI4_unsigned <= unsigned(PI2_Inc_AXI4);

  in_3_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        PI2_Inc_AXI4_1 <= to_unsigned(16#000000#, 24);
      ELSIF enb = '1' THEN
        PI2_Inc_AXI4_1 <= PI2_Inc_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS in_3_pipe_process;


  Pipeline8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Pipeline8_out1 <= to_unsigned(16#000000#, 24);
      ELSIF enb = '1' THEN
        Pipeline8_out1 <= PI2_Inc_AXI4_1;
      END IF;
    END IF;
  END PROCESS Pipeline8_process;


  count_1 <= Delay6_out1 XOR Delay1_out1;

  Logical1_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        count_2 <= '0';
      ELSIF enb = '1' THEN
        count_2 <= count_1;
      END IF;
    END IF;
  END PROCESS Logical1_out_pipe_process;


  in_2_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        I_1 <= '0';
      ELSIF enb = '1' THEN
        I_1 <= I;
      END IF;
    END IF;
  END PROCESS in_2_pipe_process;


  IncPerTurn_elek_AXI4_unsigned <= unsigned(IncPerTurn_elek_AXI4);

  in_6_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        IncPerTurn_elek_AXI4_1 <= to_unsigned(16#0000#, 16);
      ELSIF enb = '1' THEN
        IncPerTurn_elek_AXI4_1 <= IncPerTurn_elek_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS in_6_pipe_process;


  count_el_signed <= signed(count_el);

  Pipeline9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Pipeline9_out1 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        Pipeline9_out1 <= count_el_signed;
      END IF;
    END IF;
  END PROCESS Pipeline9_process;


  Product_theta_el_cast <= signed(resize(Pipeline8_out1, 25));
  Product_theta_el_mul_temp <= Product_theta_el_cast * Pipeline9_out1;
  Product_theta_el_cast_1 <= Product_theta_el_mul_temp(39 DOWNTO 0);
  theta_el_1 <= Product_theta_el_cast_1(27 DOWNTO 4);

  reduced_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        theta_el_tmp <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        theta_el_tmp <= theta_el_1;
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  theta_el <= std_logic_vector(theta_el_tmp);

  theta_el_AXI4 <= std_logic_vector(theta_el_tmp);

  IncPerTurn_mech_AXI4_unsigned <= unsigned(IncPerTurn_mech_AXI4);

  in_5_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        IncPerTurn_mech_AXI4_1 <= to_unsigned(16#0000#, 16);
      ELSIF enb = '1' THEN
        IncPerTurn_mech_AXI4_1 <= IncPerTurn_mech_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS in_5_pipe_process;


  count_mech_unsigned <= unsigned(count_mech);

  reduced_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        position_tmp <= to_unsigned(16#0000#, 16);
      ELSIF enb = '1' THEN
        position_tmp <= count_mech_unsigned;
      END IF;
    END IF;
  END PROCESS reduced_2_process;


  position <= std_logic_vector(position_tmp);

  position_AXI4 <= std_logic_vector(position_tmp);

  edge_signed <= signed(edge_rsvd_1);

  
  Abs_y <=  - (resize(edge_signed, 9)) WHEN edge_signed < to_signed(16#00#, 8) ELSE
      resize(edge_signed, 9);
  edge_rsvd_2 <= Abs_y(0);

  out_6_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        edge_rsvd <= '0';
      ELSIF enb = '1' THEN
        edge_rsvd <= edge_rsvd_2;
      END IF;
    END IF;
  END PROCESS out_6_pipe_process;


  out_7_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        count <= '0';
      ELSIF enb = '1' THEN
        count <= count_2;
      END IF;
    END IF;
  END PROCESS out_7_pipe_process;


  out_8_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        hold1_out1_1 <= to_signed(16#0#, 4);
      ELSIF enb = '1' THEN
        hold1_out1_1 <= hold1_out1;
      END IF;
    END IF;
  END PROCESS out_8_pipe_process;


  direction_AXI4 <= std_logic_vector(hold1_out1_1);

  in_8_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        PeriodEnd_1 <= '0';
      ELSIF enb = '1' THEN
        PeriodEnd_1 <= PeriodEnd;
      END IF;
    END IF;
  END PROCESS in_8_pipe_process;


  countPerPEriod_signed <= signed(countPerPEriod);

  out_9_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        countPerPEriod_1 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        countPerPEriod_1 <= countPerPEriod_signed;
      END IF;
    END IF;
  END PROCESS out_9_pipe_process;


  countPerPeriod_AXI4 <= std_logic_vector(countPerPEriod_1);

  speed_out2_unsigned <= unsigned(speed_out2);

  out_10_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        speed_out2_1 <= to_unsigned(16#0000#, 16);
      ELSIF enb = '1' THEN
        speed_out2_1 <= speed_out2_unsigned;
      END IF;
    END IF;
  END PROCESS out_10_pipe_process;


  OverSamplFactor <= std_logic_vector(speed_out2_1);

  omega_moving_average_signed <= signed(omega_moving_average);

  reduced_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        omega_moving_average_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        omega_moving_average_1 <= omega_moving_average_signed;
      END IF;
    END IF;
  END PROCESS reduced_3_process;


  omega_MA_N4 <= std_logic_vector(omega_moving_average_1);

  omega_MA_N4_AXI <= std_logic_vector(omega_moving_average_1);

  out_13_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        timeout_active_all_ORed_1 <= '0';
      ELSIF enb = '1' THEN
        timeout_active_all_ORed_1 <= timeout_active_all_ORed;
      END IF;
    END IF;
  END PROCESS out_13_pipe_process;


  speed_out5_signed <= signed(speed_out5);

  out_14_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        speed_out5_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        speed_out5_1 <= speed_out5_signed;
      END IF;
    END IF;
  END PROCESS out_14_pipe_process;


  omegaA <= std_logic_vector(speed_out5_1);

  speed_out7_signed <= signed(speed_out7);

  out_15_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        speed_out7_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        speed_out7_1 <= speed_out7_signed;
      END IF;
    END IF;
  END PROCESS out_15_pipe_process;


  omegaNOTA <= std_logic_vector(speed_out7_1);

  speed_out6_signed <= signed(speed_out6);

  out_16_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        speed_out6_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        speed_out6_1 <= speed_out6_signed;
      END IF;
    END IF;
  END PROCESS out_16_pipe_process;


  omegaB <= std_logic_vector(speed_out6_1);

  speed_out8_signed <= signed(speed_out8);

  out_17_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        speed_out8_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        speed_out8_1 <= speed_out8_signed;
      END IF;
    END IF;
  END PROCESS out_17_pipe_process;


  omegaNOTB <= std_logic_vector(speed_out8_1);

  out_18_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        newMeas_allORed_1 <= '0';
      ELSIF enb = '1' THEN
        newMeas_allORed_1 <= newMeas_allORed;
      END IF;
    END IF;
  END PROCESS out_18_pipe_process;


  ce_out <= clk_enable;

  timeout_active <= timeout_active_all_ORed_1;

  new_measurement <= newMeas_allORed_1;

END rtl;

