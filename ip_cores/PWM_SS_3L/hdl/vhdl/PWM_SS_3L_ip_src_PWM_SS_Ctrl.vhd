-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ThreeL_PWM_direct\PWM_SS_3L_ip_src_PWM_SS_Ctrl.vhd
-- Created: 2020-04-06 17:35:11
-- 
-- Generated by MATLAB 9.7 and HDL Coder 3.15
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1e-08
-- Target subsystem base rate: 1e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- SSa1_OUT                      ce_out        1e-08
-- SSa2_OUT                      ce_out        1e-08
-- SSb1_OUT                      ce_out        1e-08
-- SSb2_OUT                      ce_out        1e-08
-- SSc1_OUT                      ce_out        1e-08
-- SSc2_OUT                      ce_out        1e-08
-- Period_Center                 ce_out        1e-08
-- Period_Start                  ce_out        1e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: PWM_SS_3L_ip_src_PWM_SS_Ctrl
-- Source Path: ThreeL_PWM_direct/PWM_SS_Ctrl
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY PWM_SS_3L_ip_src_PWM_SS_Ctrl IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        PWM_en_AXI                        :   IN    std_logic;
        Mode_AXI                          :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        PWM_counter_max_value_int_AXI     :   IN    std_logic_vector(19 DOWNTO 0);  -- ufix20
        PWM_min_pulse_width_0to1_AXI      :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
        m_u1_norm                         :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
        m_u2_norm                         :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
        m_u3_norm                         :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
        m_u1_norm_AXI                     :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
        m_u2_norm_AXI                     :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
        m_u3_norm_AXI                     :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
        SSa1_IN_External                  :   IN    std_logic;
        SSa2_IN_External                  :   IN    std_logic;
        SSb1_IN_External                  :   IN    std_logic;
        SSb2_IN_External                  :   IN    std_logic;
        SSc1_IN_External                  :   IN    std_logic;
        SSc2_IN_External                  :   IN    std_logic;
        TriState_HB1_AXI                  :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        TriState_HB2_AXI                  :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        TriState_HB3_AXI                  :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        ce_out                            :   OUT   std_logic;
        SSa1_OUT                          :   OUT   std_logic;
        SSa2_OUT                          :   OUT   std_logic;
        SSb1_OUT                          :   OUT   std_logic;
        SSb2_OUT                          :   OUT   std_logic;
        SSc1_OUT                          :   OUT   std_logic;
        SSc2_OUT                          :   OUT   std_logic;
        Period_Center                     :   OUT   std_logic;
        Period_Start                      :   OUT   std_logic
        );
END PWM_SS_3L_ip_src_PWM_SS_Ctrl;


ARCHITECTURE rtl OF PWM_SS_3L_ip_src_PWM_SS_Ctrl IS

  -- Component Declarations
  COMPONENT PWM_SS_3L_ip_src_GenPWM
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          PWM_en_AXI                      :   IN    std_logic;
          max_counter_value               :   IN    std_logic_vector(19 DOWNTO 0);  -- ufix20
          min_pulse_width_AXI             :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
          U1_norm                         :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
          U2_norm                         :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
          U3_norm                         :   IN    std_logic_vector(13 DOWNTO 0);  -- sfix14_En12
          Sa                              :   OUT   std_logic_vector(0 TO 1);  -- ufix1 [2]
          Sb                              :   OUT   std_logic_vector(0 TO 1);  -- ufix1 [2]
          Sc                              :   OUT   std_logic_vector(0 TO 1);  -- ufix1 [2]
          Period_Center                   :   OUT   std_logic;
          Period_Start                    :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT PWM_SS_3L_ip_src_Chose_SS
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          Switch_AXI                      :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
          SSa_IN_PWM                      :   IN    std_logic_vector(0 TO 1);  -- ufix1 [2]
          SSb_IN_PWM                      :   IN    std_logic_vector(0 TO 1);  -- ufix1 [2]
          SSc_IN_PWM                      :   IN    std_logic_vector(0 TO 1);  -- ufix1 [2]
          SSa_IN_External                 :   IN    std_logic_vector(0 TO 1);  -- boolean [2]
          SSb_IN_External                 :   IN    std_logic_vector(0 TO 1);  -- boolean [2]
          SSc_IN_External                 :   IN    std_logic_vector(0 TO 1);  -- boolean [2]
          TriState_HB1_AXI                :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
          TriState_HB2_AXI                :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
          TriState_HB3_AXI                :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
          SSa_OUT                         :   OUT   std_logic_vector(0 TO 1);  -- boolean [2]
          SSb_OUT                         :   OUT   std_logic_vector(0 TO 1);  -- boolean [2]
          SSc_OUT                         :   OUT   std_logic_vector(0 TO 1)  -- boolean [2]
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : PWM_SS_3L_ip_src_GenPWM
    USE ENTITY work.PWM_SS_3L_ip_src_GenPWM(rtl);

  FOR ALL : PWM_SS_3L_ip_src_Chose_SS
    USE ENTITY work.PWM_SS_3L_ip_src_Chose_SS(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL Mode_AXI_unsigned                : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL m_u1_norm_AXI_signed             : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL m_u1_norm_signed                 : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL Switch7_out1                     : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL m_u2_norm_AXI_signed             : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL m_u2_norm_signed                 : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL Switch8_out1                     : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL m_u3_norm_AXI_signed             : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL m_u3_norm_signed                 : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL Switch9_out1                     : signed(13 DOWNTO 0);  -- sfix14_En12
  SIGNAL GenPWM_out1                      : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL GenPWM_out2                      : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL GenPWM_out3                      : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL GenPWM_out4                      : std_logic;
  SIGNAL GenPWM_out5                      : std_logic;
  SIGNAL delayMatch_out_1                 : std_logic;
  SIGNAL delayMatch_1_reg                 : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL delayMatch_out_2                 : std_logic;
  SIGNAL delayMatch_out_3                 : std_logic;
  SIGNAL delayMatch_out_4                 : std_logic;
  SIGNAL delayMatch_out_5                 : std_logic;
  SIGNAL delayMatch_out_6                 : std_logic;
  SIGNAL delayMatch_1_reg_1               : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL delayMatch_1_reg_2               : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL delayMatch_1_reg_3               : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL delayMatch_1_reg_4               : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL delayMatch_1_reg_5               : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL Mux_out1                         : std_logic_vector(0 TO 5);  -- boolean [6]
  SIGNAL Switch1_out1                     : std_logic_vector(0 TO 5);  -- boolean [6]
  SIGNAL Delay_out1                       : std_logic_vector(0 TO 5);  -- boolean [6]
  SIGNAL Demux_out1                       : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL Demux_out2                       : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL Demux_out3                       : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL Chose_SS_out1                    : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL Chose_SS_out2                    : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL Chose_SS_out3                    : std_logic_vector(0 TO 1);  -- boolean [2]
  SIGNAL delayMatch1_reg                  : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL GenPWM_out4_1                    : std_logic;
  SIGNAL delayMatch2_reg                  : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL GenPWM_out5_1                    : std_logic;

BEGIN
  u_GenPWM : PWM_SS_3L_ip_src_GenPWM
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              PWM_en_AXI => PWM_en_AXI,
              max_counter_value => PWM_counter_max_value_int_AXI,  -- ufix20
              min_pulse_width_AXI => PWM_min_pulse_width_0to1_AXI,  -- sfix14_En12
              U1_norm => std_logic_vector(Switch7_out1),  -- sfix14_En12
              U2_norm => std_logic_vector(Switch8_out1),  -- sfix14_En12
              U3_norm => std_logic_vector(Switch9_out1),  -- sfix14_En12
              Sa => GenPWM_out1,  -- ufix1 [2]
              Sb => GenPWM_out2,  -- ufix1 [2]
              Sc => GenPWM_out3,  -- ufix1 [2]
              Period_Center => GenPWM_out4,
              Period_Start => GenPWM_out5
              );

  u_Chose_SS : PWM_SS_3L_ip_src_Chose_SS
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              Switch_AXI => Mode_AXI,  -- ufix2
              SSa_IN_PWM => GenPWM_out1,  -- ufix1 [2]
              SSb_IN_PWM => GenPWM_out2,  -- ufix1 [2]
              SSc_IN_PWM => GenPWM_out3,  -- ufix1 [2]
              SSa_IN_External => Demux_out1,  -- boolean [2]
              SSb_IN_External => Demux_out2,  -- boolean [2]
              SSc_IN_External => Demux_out3,  -- boolean [2]
              TriState_HB1_AXI => TriState_HB1_AXI,  -- ufix2
              TriState_HB2_AXI => TriState_HB2_AXI,  -- ufix2
              TriState_HB3_AXI => TriState_HB3_AXI,  -- ufix2
              SSa_OUT => Chose_SS_out1,  -- boolean [2]
              SSb_OUT => Chose_SS_out2,  -- boolean [2]
              SSc_OUT => Chose_SS_out3  -- boolean [2]
              );

  Mode_AXI_unsigned <= unsigned(Mode_AXI);

  m_u1_norm_AXI_signed <= signed(m_u1_norm_AXI);

  m_u1_norm_signed <= signed(m_u1_norm);

  
  Switch7_out1 <= m_u1_norm_AXI_signed WHEN Mode_AXI_unsigned = to_unsigned(16#0#, 2) ELSE
      m_u1_norm_signed;

  m_u2_norm_AXI_signed <= signed(m_u2_norm_AXI);

  m_u2_norm_signed <= signed(m_u2_norm);

  
  Switch8_out1 <= m_u2_norm_AXI_signed WHEN Mode_AXI_unsigned = to_unsigned(16#0#, 2) ELSE
      m_u2_norm_signed;

  m_u3_norm_AXI_signed <= signed(m_u3_norm_AXI);

  m_u3_norm_signed <= signed(m_u3_norm);

  
  Switch9_out1 <= m_u3_norm_AXI_signed WHEN Mode_AXI_unsigned = to_unsigned(16#0#, 2) ELSE
      m_u3_norm_signed;

  enb <= clk_enable;

  delayMatch_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch_1_reg <= (OTHERS => '0');
        delayMatch_1_reg_1 <= (OTHERS => '0');
        delayMatch_1_reg_2 <= (OTHERS => '0');
        delayMatch_1_reg_3 <= (OTHERS => '0');
        delayMatch_1_reg_4 <= (OTHERS => '0');
        delayMatch_1_reg_5 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch_1_reg(0) <= SSa1_IN_External;
        delayMatch_1_reg(1 TO 2) <= delayMatch_1_reg(0 TO 1);
        delayMatch_1_reg_1(0) <= SSa2_IN_External;
        delayMatch_1_reg_1(1 TO 2) <= delayMatch_1_reg_1(0 TO 1);
        delayMatch_1_reg_2(0) <= SSb1_IN_External;
        delayMatch_1_reg_2(1 TO 2) <= delayMatch_1_reg_2(0 TO 1);
        delayMatch_1_reg_3(0) <= SSb2_IN_External;
        delayMatch_1_reg_3(1 TO 2) <= delayMatch_1_reg_3(0 TO 1);
        delayMatch_1_reg_4(0) <= SSc1_IN_External;
        delayMatch_1_reg_4(1 TO 2) <= delayMatch_1_reg_4(0 TO 1);
        delayMatch_1_reg_5(0) <= SSc2_IN_External;
        delayMatch_1_reg_5(1 TO 2) <= delayMatch_1_reg_5(0 TO 1);
      END IF;
    END IF;
  END PROCESS delayMatch_1_process;

  delayMatch_out_1 <= delayMatch_1_reg(2);
  delayMatch_out_2 <= delayMatch_1_reg_1(2);
  delayMatch_out_3 <= delayMatch_1_reg_2(2);
  delayMatch_out_4 <= delayMatch_1_reg_3(2);
  delayMatch_out_5 <= delayMatch_1_reg_4(2);
  delayMatch_out_6 <= delayMatch_1_reg_5(2);

  Mux_out1(0) <= delayMatch_out_1;
  Mux_out1(1) <= delayMatch_out_2;
  Mux_out1(2) <= delayMatch_out_3;
  Mux_out1(3) <= delayMatch_out_4;
  Mux_out1(4) <= delayMatch_out_5;
  Mux_out1(5) <= delayMatch_out_6;

  Delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay_out1 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        Delay_out1 <= Switch1_out1;
      END IF;
    END IF;
  END PROCESS Delay_process;


  
  Switch1_out1 <= Delay_out1 WHEN GenPWM_out5 = '0' ELSE
      Mux_out1;

  Demux_out1(0) <= Switch1_out1(0);
  Demux_out1(1) <= Switch1_out1(1);

  Demux_out2(0) <= Switch1_out1(2);
  Demux_out2(1) <= Switch1_out1(3);

  Demux_out3(0) <= Switch1_out1(4);
  Demux_out3(1) <= Switch1_out1(5);

  delayMatch1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch1_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch1_reg(0) <= GenPWM_out4;
        delayMatch1_reg(1) <= delayMatch1_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  GenPWM_out4_1 <= delayMatch1_reg(1);

  delayMatch2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch2_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch2_reg(0) <= GenPWM_out5;
        delayMatch2_reg(1) <= delayMatch2_reg(0);
      END IF;
    END IF;
  END PROCESS delayMatch2_process;

  GenPWM_out5_1 <= delayMatch2_reg(1);

  ce_out <= clk_enable;

  SSa1_OUT <= Chose_SS_out1(0);

  SSa2_OUT <= Chose_SS_out1(1);

  SSb1_OUT <= Chose_SS_out2(0);

  SSb2_OUT <= Chose_SS_out2(1);

  SSc1_OUT <= Chose_SS_out3(0);

  SSc2_OUT <= Chose_SS_out3(1);

  Period_Center <= GenPWM_out4_1;

  Period_Start <= GenPWM_out5_1;

END rtl;

