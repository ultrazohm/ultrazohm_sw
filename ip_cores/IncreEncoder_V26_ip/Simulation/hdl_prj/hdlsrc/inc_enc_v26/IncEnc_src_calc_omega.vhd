-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\inc_enc_v26\IncEnc_src_calc_omega.vhd
-- Created: 2023-02-22 14:14:55
-- 
-- Generated by MATLAB 9.13 and HDL Coder 4.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: IncEnc_src_calc_omega
-- Source Path: inc_enc_v26/IncEnc_V25/speed/calc_omega
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY IncEnc_src_calc_omega IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb_1_5987_0                      :   IN    std_logic;
        Encoder_Line                      :   IN    std_logic;
        Dir                               :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
        T                                 :   IN    std_logic_vector(37 DOWNTO 0);  -- sfix38_En32
        oversampling_state                :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        timeout_value                     :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        omega_oversampled                 :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        NewMeasurement                    :   OUT   std_logic;
        state_count_edges                 :   OUT   std_logic_vector(15 DOWNTO 0);  -- int16
        timeout_active                    :   OUT   std_logic
        );
END IncEnc_src_calc_omega;


ARCHITECTURE rtl OF IncEnc_src_calc_omega IS

  -- Component Declarations
  COMPONENT IncEnc_src_invt_mult
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb_1_5987_0                    :   IN    std_logic;
          New_Measurement                 :   IN    std_logic;
          rps                             :   IN    std_logic_vector(37 DOWNTO 0);  -- sfix38_En32
          Oversampling_Factor             :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          omega_oversampled               :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          New_Measurement_delayed         :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : IncEnc_src_invt_mult
    USE ENTITY work.IncEnc_src_invt_mult(rtl);

  -- Signals
  SIGNAL pos_and_negative_edges           : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old1_out1                  : std_logic;
  SIGNAL reset_old_switch1_out1           : std_logic;
  SIGNAL Detec_edge_sub_cast              : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge_sub_cast_1            : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL count_old1_out1                  : signed(7 DOWNTO 0);  -- int8
  SIGNAL Constant3_out1                   : signed(7 DOWNTO 0);  -- int8
  SIGNAL ProtectToUseOmegaIfThetaJump1_relop1 : std_logic;
  SIGNAL ProtectToUseOmegaIfThetaJump1_relop1_dtc : signed(15 DOWNTO 0);  -- int16
  SIGNAL edge_detected                    : signed(15 DOWNTO 0);  -- int16
  SIGNAL edge_detected_1                  : std_logic;
  SIGNAL count_step                       : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count_reset                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL timeout_value_unsigned           : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL speed_timeout_count              : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL count                            : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL speed_timeout_hit                : std_logic;
  SIGNAL Delay5_out1                      : std_logic;
  SIGNAL OR1_out1                         : std_logic;
  SIGNAL count_1                          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Relational_Operator_relop1       : std_logic;
  SIGNAL Constant4_out1                   : signed(7 DOWNTO 0);  -- int8
  SIGNAL Constant4_out1_dtc               : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL oversampling_state_unsigned      : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL OnlyAllowInNewPeriod_out1        : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Delay2_out1                      : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Allow_ToCheckOversampling        : std_logic;
  SIGNAL Delay8_out1                      : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_edges_states               : signed(15 DOWNTO 0);  -- int16
  SIGNAL count_edges_states_dtc           : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL Reset_out1                       : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL Add3_add_cast                    : signed(15 DOWNTO 0);  -- sfix16
  SIGNAL count_edges                      : signed(15 DOWNTO 0);  -- int16
  SIGNAL IfFinalState_1_cast              : signed(16 DOWNTO 0);  -- sfix17
  SIGNAL IfFinalState_relop1              : std_logic;
  SIGNAL OR_out1                          : std_logic;
  SIGNAL timeout_latch                    : std_logic;
  SIGNAL Delay3_out1                      : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Dir_signed                       : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL switch_compare_1_1               : std_logic;
  SIGNAL Constant1_out1                   : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL T_signed                         : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL Constant_out1                    : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL T_count_out1                     : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL Add1_out1                        : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL ABS_out1                         : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL switch_compare_1_2               : std_logic;
  SIGNAL T_count_switch_out1              : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL ProtectOverflow_T_count_out1     : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL Add2_out1                        : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL speed_old_switch2_out1           : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL ABS_y                            : signed(38 DOWNTO 0);  -- sfix39_En32
  SIGNAL ABS_cast                         : signed(38 DOWNTO 0);  -- sfix39_En32
  SIGNAL switch_compare_1_3               : std_logic;
  SIGNAL speed_old_switch_out1            : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL speed_old_out1                   : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL Constant2_out1                   : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL T_count1_reg                     : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL T_count1_out1                    : std_logic;
  SIGNAL rps                              : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL Oversampling_Factor              : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Delay4_out1                      : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL omega_oversampled_1              : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL invt_mult_out2                   : std_logic;
  SIGNAL omega_oversampled_signed         : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL omega_registered_out1            : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL Delay6_out1                      : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL zero_speed_at_timeout_out1       : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL omega_inkl_timeout               : signed(23 DOWNTO 0);  -- sfix24_En11

BEGIN
  -- Oversampling
  -- - At high speed, it may happen that the granularity of the time measurment between 
  -- two edges is to low for a good speed accuracy (e.g. over 2000rpm), therefore, using 
  -- the oversampling factor, not the time between two edges is measured. Instead, the
  -- time between "Oversampling" edges is measured.
  -- - Since at high speed anyway the speed is not necessary at each line edge,
  -- it is totally ok to do this.
  -- - At the moment it is tested until 20 edges time window. However, more is possible.
  -- - At low speed, only two edges are used.
  -- - At maximum speed, the "Oversampling" number of edges are used.
  -- - Between them, a linear factor is used.
  -- - Using the OverSampling number also at low speed is not possible,
  -- since the fixpoint range must be quite high! (fixdt(1,36,30) is used at the moment)
  -- Count up in order to measure the time between "same edge to same edge", e.g. every positive A-Line edge
  -- Reset time measurement
  -- 1 for one cycle if edge recognized
  -- Use new Speed after "same edge to same edge", e.g. every positive A-Line edge
  -- It outputs 1/omega. This is possible, since "T" input is already scaled to rad.
  -- Select direction of counting
  -- If ABS of counted values is bigger than the
  -- fixpoint data format can represent, reset the
  -- value in order to protect for value overflow.
  -- Filter only positive edges
  -- count edges and give pulse after N edges to indicate oversampling period
  -- if(edge_detected){ 
  -- 	count_edges++;
  -- 	if(count_edges>oversampling_factor){
  -- 		count_edges=0;
  -- 		new_oversampling_period = 1;
  -- 	}
  -- }else{new_oversampling_period = 0;}
  -- Synchronize oversampling state with edges
  -- Set speed to zero when no edges occur = timeout
  -- Latched until a new edge occurs

  u_invt_mult : IncEnc_src_invt_mult
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb_1_5987_0 => enb_1_5987_0,
              New_Measurement => T_count1_out1,
              rps => std_logic_vector(rps),  -- sfix38_En32
              Oversampling_Factor => std_logic_vector(Oversampling_Factor),  -- uint16
              omega_oversampled => omega_oversampled_1,  -- sfix24_En11
              New_Measurement_delayed => invt_mult_out2
              );

  
  reset_old_switch1_out1 <= reset_old1_out1 WHEN pos_and_negative_edges = to_signed(16#00#, 8) ELSE
      Encoder_Line;

  reset_old1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        reset_old1_out1 <= '0';
      ELSIF enb_1_5987_0 = '1' THEN
        reset_old1_out1 <= reset_old_switch1_out1;
      END IF;
    END IF;
  END PROCESS reset_old1_process;


  Detec_edge_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & Encoder_Line;
  Detec_edge_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old1_out1;
  pos_and_negative_edges <= Detec_edge_sub_cast - Detec_edge_sub_cast_1;

  count_old1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        count_old1_out1 <= to_signed(16#00#, 8);
      ELSIF enb_1_5987_0 = '1' THEN
        count_old1_out1 <= pos_and_negative_edges;
      END IF;
    END IF;
  END PROCESS count_old1_process;


  Constant3_out1 <= to_signed(16#00#, 8);

  
  ProtectToUseOmegaIfThetaJump1_relop1 <= '1' WHEN count_old1_out1 > Constant3_out1 ELSE
      '0';

  ProtectToUseOmegaIfThetaJump1_relop1_dtc <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & ProtectToUseOmegaIfThetaJump1_relop1;

  edge_detected <= ProtectToUseOmegaIfThetaJump1_relop1_dtc;

  
  edge_detected_1 <= '1' WHEN edge_detected /= to_signed(16#0000#, 16) ELSE
      '0';

  -- Free running, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  count_step <= to_unsigned(1, 32);

  count_reset <= to_unsigned(0, 32);

  timeout_value_unsigned <= unsigned(timeout_value);

  count <= speed_timeout_count + count_step;

  Delay5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay5_out1 <= '0';
      ELSIF enb_1_5987_0 = '1' THEN
        Delay5_out1 <= speed_timeout_hit;
      END IF;
    END IF;
  END PROCESS Delay5_process;


  OR1_out1 <= edge_detected_1 OR Delay5_out1;

  
  count_1 <= count WHEN OR1_out1 = '0' ELSE
      count_reset;

  alpha32bit_counter_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        speed_timeout_count <= to_unsigned(0, 32);
      ELSIF enb_1_5987_0 = '1' THEN
        speed_timeout_count <= count_1;
      END IF;
    END IF;
  END PROCESS alpha32bit_counter_process;


  
  Relational_Operator_relop1 <= '1' WHEN speed_timeout_count = timeout_value_unsigned ELSE
      '0';

  speed_timeout_hit <= Relational_Operator_relop1;

  Constant4_out1 <= to_signed(16#01#, 8);

  Constant4_out1_dtc <= resize(Constant4_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 24);

  oversampling_state_unsigned <= unsigned(oversampling_state);

  Delay2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay2_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_5987_0 = '1' THEN
        Delay2_out1 <= OnlyAllowInNewPeriod_out1;
      END IF;
    END IF;
  END PROCESS Delay2_process;


  
  OnlyAllowInNewPeriod_out1 <= Delay2_out1 WHEN Allow_ToCheckOversampling = '0' ELSE
      oversampling_state_unsigned;

  Delay8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay8_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_5987_0 = '1' THEN
        Delay8_out1 <= OnlyAllowInNewPeriod_out1;
      END IF;
    END IF;
  END PROCESS Delay8_process;


  count_edges_states_dtc <= count_edges_states(12 DOWNTO 0) & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0';

  
  Reset_out1 <= count_edges_states_dtc WHEN Allow_ToCheckOversampling = '0' ELSE
      Constant4_out1_dtc;

  Add3_add_cast <= resize(Reset_out1(23 DOWNTO 11), 16);
  count_edges <= edge_detected + Add3_add_cast;

  Delay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        count_edges_states <= to_signed(16#0000#, 16);
      ELSIF enb_1_5987_0 = '1' THEN
        count_edges_states <= count_edges;
      END IF;
    END IF;
  END PROCESS Delay1_process;


  IfFinalState_1_cast <= signed(resize(Delay8_out1, 17));
  
  IfFinalState_relop1 <= '1' WHEN resize(count_edges_states, 17) > IfFinalState_1_cast ELSE
      '0';

  Allow_ToCheckOversampling <= IfFinalState_relop1;

  OR_out1 <= speed_timeout_hit OR Allow_ToCheckOversampling;

  Delay3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay3_out1 <= '0';
      ELSIF enb_1_5987_0 = '1' THEN
        Delay3_out1 <= timeout_latch;
      END IF;
    END IF;
  END PROCESS Delay3_process;


  
  timeout_latch <= Delay3_out1 WHEN OR_out1 = '0' ELSE
      speed_timeout_hit;

  
  switch_compare_1 <= '1' WHEN Allow_ToCheckOversampling > '0' ELSE
      '0';

  Dir_signed <= signed(Dir);

  
  switch_compare_1_1 <= '1' WHEN Dir_signed >= to_signed(16#1#, 4) ELSE
      '0';

  Constant1_out1 <= to_signed(0, 38);

  T_signed <= signed(T);

  Constant_out1 <= to_signed(0, 38);

  Add1_out1 <= T_count_out1 + T_signed;

  
  switch_compare_1_2 <= '1' WHEN ABS_out1 >= signed'("01111000000000000000000000000000000000") ELSE
      '0';

  
  ProtectOverflow_T_count_out1 <= T_count_switch_out1 WHEN switch_compare_1_2 = '0' ELSE
      Constant1_out1;

  T_count_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        T_count_out1 <= to_signed(0, 38);
      ELSIF enb_1_5987_0 = '1' THEN
        T_count_out1 <= ProtectOverflow_T_count_out1;
      END IF;
    END IF;
  END PROCESS T_count_process;


  Add2_out1 <= T_count_out1 - T_signed;

  
  speed_old_switch2_out1 <= Add2_out1 WHEN switch_compare_1_1 = '0' ELSE
      Add1_out1;

  
  T_count_switch_out1 <= speed_old_switch2_out1 WHEN switch_compare_1 = '0' ELSE
      Constant_out1;

  ABS_cast <= resize(T_count_switch_out1, 39);
  
  ABS_y <=  - (ABS_cast) WHEN T_count_switch_out1 < to_signed(0, 38) ELSE
      resize(T_count_switch_out1, 39);
  ABS_out1 <= ABS_y(37 DOWNTO 0);

  
  switch_compare_1_3 <= '1' WHEN ABS_out1 >= signed'("01111000000000000000000000000000000000") ELSE
      '0';

  speed_old_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        speed_old_out1 <= to_signed(0, 38);
      ELSIF enb_1_5987_0 = '1' THEN
        speed_old_out1 <= speed_old_switch_out1;
      END IF;
    END IF;
  END PROCESS speed_old_process;


  
  speed_old_switch_out1 <= speed_old_out1 WHEN Allow_ToCheckOversampling = '0' ELSE
      speed_old_switch2_out1;

  Constant2_out1 <= to_signed(0, 38);

  T_count1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        T_count1_reg <= (OTHERS => '0');
      ELSIF enb_1_5987_0 = '1' THEN
        T_count1_reg(0) <= OR_out1;
        T_count1_reg(1) <= T_count1_reg(0);
      END IF;
    END IF;
  END PROCESS T_count1_process;

  T_count1_out1 <= T_count1_reg(1);

  
  rps <= speed_old_switch_out1 WHEN switch_compare_1_3 = '0' ELSE
      Constant2_out1;

  Delay4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay4_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_5987_0 = '1' THEN
        Delay4_out1 <= Oversampling_Factor;
      END IF;
    END IF;
  END PROCESS Delay4_process;


  
  Oversampling_Factor <= Delay4_out1 WHEN Allow_ToCheckOversampling = '0' ELSE
      Delay8_out1;

  omega_oversampled_signed <= signed(omega_oversampled_1);

  Delay6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Delay6_out1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_5987_0 = '1' THEN
        Delay6_out1 <= omega_registered_out1;
      END IF;
    END IF;
  END PROCESS Delay6_process;


  
  omega_registered_out1 <= Delay6_out1 WHEN invt_mult_out2 = '0' ELSE
      omega_oversampled_signed;

  zero_speed_at_timeout_out1 <= to_signed(16#000000#, 24);

  
  omega_inkl_timeout <= omega_registered_out1 WHEN timeout_latch = '0' ELSE
      zero_speed_at_timeout_out1;

  omega_oversampled <= std_logic_vector(omega_inkl_timeout);

  state_count_edges <= std_logic_vector(count_edges_states);

  NewMeasurement <= invt_mult_out2;

  timeout_active <= timeout_latch;

END rtl;

