-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\Encoder_Zynq_V24\IncreEncoder_V24_ip_src_HDL_Reciprocal.vhd
-- Created: 2020-06-13 11:16:19
-- 
-- Generated by MATLAB 9.4 and HDL Coder 3.12
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: IncreEncoder_V24_ip_src_HDL_Reciprocal
-- Source Path: Encoder_Zynq_V24/IncreEncoder_V24/HDL Reciprocal
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.IncreEncoder_V24_ip_src_IncreEncoder_V24_pkg.ALL;

ENTITY IncreEncoder_V24_ip_src_HDL_Reciprocal IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb_1_100_0                       :   IN    std_logic;
        enb_2_100_0                       :   IN    std_logic;
        din                               :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En18
        dout                              :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En12
        );
END IncreEncoder_V24_ip_src_HDL_Reciprocal;


ARCHITECTURE rtl OF IncreEncoder_V24_ip_src_HDL_Reciprocal IS

  -- Component Declarations
  COMPONENT IncreEncoder_V24_ip_src_HDL_Reciprocal_core
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          enb_2_100_0                     :   IN    std_logic;
          xin                             :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En30
          ain                             :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En32
          sel                             :   IN    std_logic;  -- ufix1
          xout                            :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32_En30
          aout                            :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32_En32
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : IncreEncoder_V24_ip_src_HDL_Reciprocal_core
    USE ENTITY work.IncreEncoder_V24_ip_src_HDL_Reciprocal_core(rtl);

  -- Signals
  SIGNAL din_signed                       : signed(31 DOWNTO 0);  -- sfix32_En18
  SIGNAL anorm                            : unsigned(31 DOWNTO 0);  -- ufix32_En32
  SIGNAL dynamicshift                     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL onemoreshift                     : std_logic;  -- ufix1
  SIGNAL changesign                       : std_logic;  -- ufix1
  SIGNAL anorm_p                          : unsigned(31 DOWNTO 0);  -- ufix32_En32
  SIGNAL mstwobit                         : std_logic;  -- ufix1
  SIGNAL inzero                           : std_logic;  -- ufix1
  SIGNAL inzero_reg_reg                   : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL inzero_p                         : std_logic;  -- ufix1
  SIGNAL constInf                         : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL changesign_reg_reg               : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL changesign_p                     : std_logic;  -- ufix1
  SIGNAL x0                               : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL sel                              : std_logic;  -- ufix1
  SIGNAL xstage1                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL astage1                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL xstage2                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL astage2                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL xstage3                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL astage3                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL xstage3_unsigned                 : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL ds_reg_reg                       : vector_of_unsigned5(0 TO 3);  -- ufix5 [4]
  SIGNAL dynamicshift_p                   : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL onemoreshift_reg_reg             : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL onemoreshift_p                   : std_logic;  -- ufix1
  SIGNAL absdenormout                     : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL uminus_cast                      : signed(32 DOWNTO 0);  -- sfix33_En12
  SIGNAL uminus_cast_1                    : signed(32 DOWNTO 0);  -- sfix33_En12
  SIGNAL negdenormout                     : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL denormout                        : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL dout_tmp                         : signed(31 DOWNTO 0);  -- sfix32_En12

BEGIN
  -- Multi-rate Reciprocal Implementation using Reciprocal Newton Method

  u_core_stage1_inst : IncreEncoder_V24_ip_src_HDL_Reciprocal_core
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              enb_2_100_0 => enb_2_100_0,
              xin => std_logic_vector(x0),  -- ufix32_En30
              ain => std_logic_vector(anorm_p),  -- ufix32_En32
              sel => sel,  -- ufix1
              xout => xstage1,  -- ufix32_En30
              aout => astage1  -- ufix32_En32
              );

  u_core_stage2_inst : IncreEncoder_V24_ip_src_HDL_Reciprocal_core
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              enb_2_100_0 => enb_2_100_0,
              xin => xstage1,  -- ufix32_En30
              ain => astage1,  -- ufix32_En32
              sel => sel,  -- ufix1
              xout => xstage2,  -- ufix32_En30
              aout => astage2  -- ufix32_En32
              );

  u_core_stage3_inst : IncreEncoder_V24_ip_src_HDL_Reciprocal_core
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              enb_2_100_0 => enb_2_100_0,
              xin => xstage2,  -- ufix32_En30
              ain => astage2,  -- ufix32_En32
              sel => sel,  -- ufix1
              xout => xstage3,  -- ufix32_En30
              aout => astage3  -- ufix32_En32
              );

  din_signed <= signed(din);

  -- Input Normalization
  in_norm_output : PROCESS (din_signed)
    VARIABLE out1 : unsigned(4 DOWNTO 0);
    VARIABLE uain : signed(31 DOWNTO 0);
    VARIABLE areintp : unsigned(31 DOWNTO 0);
    VARIABLE c : unsigned(31 DOWNTO 0);
    VARIABLE c_r : std_logic;
    VARIABLE cast : signed(32 DOWNTO 0);
    VARIABLE cast_0 : signed(32 DOWNTO 0);
    VARIABLE areintp_0 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_1 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_2 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_3 : unsigned(1 DOWNTO 0);
    VARIABLE cast_1 : unsigned(31 DOWNTO 0);
    VARIABLE cast_2 : unsigned(7 DOWNTO 0);
    VARIABLE areintp_4 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_5 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_6 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_7 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_8 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_9 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_10 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_11 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_12 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_13 : unsigned(1 DOWNTO 0);
    VARIABLE areintp_14 : unsigned(1 DOWNTO 0);
  BEGIN
    IF din_signed(31) = '1' THEN 
      cast := resize(din_signed, 33);
      cast_0 :=  - (cast);
      uain := cast_0(31 DOWNTO 0);
      changesign <= '1';
    ELSE 
      uain := din_signed;
      changesign <= '0';
    END IF;
    areintp := unsigned(uain);
    areintp_0 := areintp(31 DOWNTO 30);
    IF (areintp_0(1) OR areintp_0(0)) = '1' THEN 
      out1 := to_unsigned(16#00#, 5);
    ELSE 
      areintp_1 := areintp(29 DOWNTO 28);
      IF (areintp_1(1) OR areintp_1(0)) = '1' THEN 
        out1 := to_unsigned(16#01#, 5);
      ELSE 
        areintp_2 := areintp(27 DOWNTO 26);
        IF (areintp_2(1) OR areintp_2(0)) = '1' THEN 
          out1 := to_unsigned(16#02#, 5);
        ELSE 
          areintp_3 := areintp(25 DOWNTO 24);
          IF (areintp_3(1) OR areintp_3(0)) = '1' THEN 
            out1 := to_unsigned(16#03#, 5);
          ELSE 
            areintp_4 := areintp(23 DOWNTO 22);
            IF (areintp_4(1) OR areintp_4(0)) = '1' THEN 
              out1 := to_unsigned(16#04#, 5);
            ELSE 
              areintp_5 := areintp(21 DOWNTO 20);
              IF (areintp_5(1) OR areintp_5(0)) = '1' THEN 
                out1 := to_unsigned(16#05#, 5);
              ELSE 
                areintp_6 := areintp(19 DOWNTO 18);
                IF (areintp_6(1) OR areintp_6(0)) = '1' THEN 
                  out1 := to_unsigned(16#06#, 5);
                ELSE 
                  areintp_7 := areintp(17 DOWNTO 16);
                  IF (areintp_7(1) OR areintp_7(0)) = '1' THEN 
                    out1 := to_unsigned(16#07#, 5);
                  ELSE 
                    areintp_8 := areintp(15 DOWNTO 14);
                    IF (areintp_8(1) OR areintp_8(0)) = '1' THEN 
                      out1 := to_unsigned(16#08#, 5);
                    ELSE 
                      areintp_9 := areintp(13 DOWNTO 12);
                      IF (areintp_9(1) OR areintp_9(0)) = '1' THEN 
                        out1 := to_unsigned(16#09#, 5);
                      ELSE 
                        areintp_10 := areintp(11 DOWNTO 10);
                        IF (areintp_10(1) OR areintp_10(0)) = '1' THEN 
                          out1 := to_unsigned(16#0A#, 5);
                        ELSE 
                          areintp_11 := areintp(9 DOWNTO 8);
                          IF (areintp_11(1) OR areintp_11(0)) = '1' THEN 
                            out1 := to_unsigned(16#0B#, 5);
                          ELSE 
                            areintp_12 := areintp(7 DOWNTO 6);
                            IF (areintp_12(1) OR areintp_12(0)) = '1' THEN 
                              out1 := to_unsigned(16#0C#, 5);
                            ELSE 
                              areintp_13 := areintp(5 DOWNTO 4);
                              IF (areintp_13(1) OR areintp_13(0)) = '1' THEN 
                                out1 := to_unsigned(16#0D#, 5);
                              ELSE 
                                areintp_14 := areintp(3 DOWNTO 2);
                                IF (areintp_14(1) OR areintp_14(0)) = '1' THEN 
                                  out1 := to_unsigned(16#0E#, 5);
                                ELSE 
                                  out1 := to_unsigned(16#0F#, 5);
                                END IF;
                              END IF;
                            END IF;
                          END IF;
                        END IF;
                      END IF;
                    END IF;
                  END IF;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
    cast_1 := unsigned(uain);
    cast_2 := resize(out1 sll 1, 8);
    c := cast_1 sll to_integer(cast_2);
    c_r :=  NOT c(31);
    IF c_r = '1' THEN 
      c := c sll 1;
    END IF;
    anorm <= c;
    dynamicshift <= out1;
    onemoreshift <= c_r;
  END PROCESS in_norm_output;


  anorm_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        anorm_p <= to_unsigned(0, 32);
      ELSIF enb_1_100_0 = '1' THEN
        anorm_p <= anorm;
      END IF;
    END IF;
  END PROCESS anorm_reg_process;


  mstwobit <= anorm_p(31);

  
  inzero <= '1' WHEN mstwobit = '0' ELSE
      '0';

  -- Pipeline registers
  inzero_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        inzero_reg_reg <= (OTHERS => '0');
      ELSIF enb_1_100_0 = '1' THEN
        inzero_reg_reg(0) <= inzero;
        inzero_reg_reg(1 TO 2) <= inzero_reg_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS inzero_reg_process;

  inzero_p <= inzero_reg_reg(2);

  constInf <= to_signed(2147483647, 32);

  changesign_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        changesign_reg_reg <= (OTHERS => '0');
      ELSIF enb_1_100_0 = '1' THEN
        changesign_reg_reg(0) <= changesign;
        changesign_reg_reg(1 TO 3) <= changesign_reg_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS changesign_reg_process;

  changesign_p <= changesign_reg_reg(3);

  x0 <= to_unsigned(1073741824, 32);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  -- 
  -- Selector signal counter
  sel_cnt_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        sel <= '0';
      ELSIF enb_2_100_0 = '1' THEN
        sel <=  NOT sel;
      END IF;
    END IF;
  END PROCESS sel_cnt_process;


  xstage3_unsigned <= unsigned(xstage3);

  -- Pipeline registers
  ds_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        ds_reg_reg <= (OTHERS => to_unsigned(16#00#, 5));
      ELSIF enb_1_100_0 = '1' THEN
        ds_reg_reg(0) <= dynamicshift;
        ds_reg_reg(1 TO 3) <= ds_reg_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS ds_reg_process;

  dynamicshift_p <= ds_reg_reg(3);

  onemoreshift_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        onemoreshift_reg_reg <= (OTHERS => '0');
      ELSIF enb_1_100_0 = '1' THEN
        onemoreshift_reg_reg(0) <= onemoreshift;
        onemoreshift_reg_reg(1 TO 3) <= onemoreshift_reg_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS onemoreshift_reg_process;

  onemoreshift_p <= onemoreshift_reg_reg(3);

  -- Output Denormalization
  out_denorm_output : PROCESS (xstage3_unsigned, dynamicshift_p, onemoreshift_p)
    VARIABLE xshift : unsigned(31 DOWNTO 0);
    VARIABLE shiftarr : vector_of_unsigned32(0 TO 16);
    VARIABLE c1 : unsigned(5 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(31 DOWNTO 0);
  BEGIN
    shiftarr(0) := SHIFT_RIGHT(xstage3_unsigned, 31);
    shiftarr(1) := SHIFT_RIGHT(xstage3_unsigned, 29);
    shiftarr(2) := SHIFT_RIGHT(xstage3_unsigned, 27);
    shiftarr(3) := SHIFT_RIGHT(xstage3_unsigned, 25);
    shiftarr(4) := SHIFT_RIGHT(xstage3_unsigned, 23);
    shiftarr(5) := SHIFT_RIGHT(xstage3_unsigned, 21);
    shiftarr(6) := SHIFT_RIGHT(xstage3_unsigned, 19);
    shiftarr(7) := SHIFT_RIGHT(xstage3_unsigned, 17);
    shiftarr(8) := SHIFT_RIGHT(xstage3_unsigned, 15);
    shiftarr(9) := SHIFT_RIGHT(xstage3_unsigned, 13);
    shiftarr(10) := SHIFT_RIGHT(xstage3_unsigned, 11);
    shiftarr(11) := SHIFT_RIGHT(xstage3_unsigned, 9);
    shiftarr(12) := SHIFT_RIGHT(xstage3_unsigned, 7);
    shiftarr(13) := SHIFT_RIGHT(xstage3_unsigned, 5);
    shiftarr(14) := SHIFT_RIGHT(xstage3_unsigned, 3);
    shiftarr(15) := SHIFT_RIGHT(xstage3_unsigned, 1);
    shiftarr(16) := xstage3_unsigned;
    c1 := resize(dynamicshift_p, 6) + to_unsigned(16#01#, 6);
    IF onemoreshift_p = '0' THEN 
      sub_cast_0 := signed(resize(c1, 32));
      xshift := SHIFT_RIGHT(shiftarr(to_integer(sub_cast_0 - 1)), 1);
    ELSE 
      sub_cast := signed(resize(c1, 32));
      xshift := shiftarr(to_integer(sub_cast - 1));
    END IF;
    IF xshift(31) /= '0' THEN 
      absdenormout <= X"7FFFFFFF";
    ELSE 
      absdenormout <= signed(xshift);
    END IF;
  END PROCESS out_denorm_output;


  uminus_cast <= resize(absdenormout, 33);
  uminus_cast_1 <=  - (uminus_cast);
  negdenormout <= uminus_cast_1(31 DOWNTO 0);

  -- Change output sign
  
  denormout <= negdenormout WHEN changesign_p = '1' ELSE
      absdenormout;

  -- Zero input logic
  
  dout_tmp <= constInf WHEN inzero_p = '1' ELSE
      denormout;

  dout <= std_logic_vector(dout_tmp);

END rtl;

