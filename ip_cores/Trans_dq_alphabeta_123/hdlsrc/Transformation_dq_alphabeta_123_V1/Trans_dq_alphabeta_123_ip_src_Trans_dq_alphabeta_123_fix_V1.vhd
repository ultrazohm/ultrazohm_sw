-- -------------------------------------------------------------
-- 
-- File Name: C:\ultrazohm_sw\ip_cores\Trans_dq_alphabeta_123\Simulation\hdlsrc\Transformation_dq_alphabeta_123_V1\Trans_dq_alphabeta_123_ip_src_Trans_dq_alphabeta_123_fix_V1.vhd
-- Created: 2022-05-27 15:32:20
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 2e-08
-- Target subsystem base rate: 2e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- dq_Done                       ce_out        2e-08
-- sin                           ce_out        2e-08
-- cos                           ce_out        2e-08
-- ialpha                        ce_out        2e-08
-- ialpha_AXI                    ce_out        2e-08
-- ibeta                         ce_out        2e-08
-- ibeta_AXI                     ce_out        2e-08
-- i1                            ce_out        2e-08
-- i1_AXI                        ce_out        2e-08
-- i2                            ce_out        2e-08
-- i2_AXI                        ce_out        2e-08
-- i3                            ce_out        2e-08
-- i3_AXI                        ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Trans_dq_alphabeta_123_ip_src_Trans_dq_alphabeta_123_fix_V1
-- Source Path: Transformation_dq_alphabeta_123_V1/Trans_dq_alphabeta_123_fix_V1
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Trans_dq_alphabeta_123_ip_src_Trans_dq_alphabeta_123_fix_V1_pkg.ALL;

ENTITY Trans_dq_alphabeta_123_ip_src_Trans_dq_alphabeta_123_fix_V1 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        theta                             :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        theta_offset_AXI                  :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        CurrentValid_in                   :   IN    std_logic;
        Id_ref_AXI                        :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        Iq_ref_AXI                        :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        ce_out                            :   OUT   std_logic;
        dq_Done                           :   OUT   std_logic;
        sin                               :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        cos                               :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        ialpha                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        ialpha_AXI                        :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        ibeta                             :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        ibeta_AXI                         :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i1                                :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i1_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i2                                :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i2_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i3                                :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i3_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0)  -- sfix18_En11
        );
END Trans_dq_alphabeta_123_ip_src_Trans_dq_alphabeta_123_fix_V1;


ARCHITECTURE rtl OF Trans_dq_alphabeta_123_ip_src_Trans_dq_alphabeta_123_fix_V1 IS

  -- Component Declarations
  COMPONENT Trans_dq_alphabeta_123_ip_src_Cosine
    PORT( u                               :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
          sin_2_pi_u                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          cos_2_pi_u                      :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En14
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Trans_dq_alphabeta_123_ip_src_Cosine
    USE ENTITY work.Trans_dq_alphabeta_123_ip_src_Cosine(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL CurrentValid_in_1                : std_logic;
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL alpha1_for_one_cycle_if_edge_recognized : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old2_out1                  : std_logic;
  SIGNAL reset_old_switch1_out1           : std_logic;
  SIGNAL Detec_edge_sub_cast              : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge_sub_cast_1            : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL alpha1_for_one_cycle_if_edge_recognized_1 : signed(7 DOWNTO 0);  -- int8
  SIGNAL dtc_out                          : std_logic;  -- ufix1
  SIGNAL Saturation_out1                  : std_logic;  -- ufix1
  SIGNAL DelayValid_reg                   : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL End_Cycle                        : std_logic;  -- ufix1
  SIGNAL shift6_out1                      : std_logic;  -- ufix1
  SIGNAL shift1_out1                      : std_logic;  -- ufix1
  SIGNAL shift2_out1                      : std_logic;  -- ufix1
  SIGNAL shift3_out1                      : std_logic;  -- ufix1
  SIGNAL Logical_Operator_out1            : std_logic;
  SIGNAL delayMatch17_reg                 : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL Logical_Operator_out1_1          : std_logic;
  SIGNAL theta_signed                     : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL theta_1                          : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL theta_offset_AXI_signed          : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL theta_offset_AXI_1               : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add1_out1                        : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add1_out1_1                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Compare_Limit_Low_out1           : std_logic;
  SIGNAL Compare_Limit_High_out1          : std_logic;
  SIGNAL Compare_Limit_High_out1_1        : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Add1_out1_2                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Constant_out1                    : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add2_out1                        : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Compare_Limit_Low_out1_1         : std_logic;
  SIGNAL switch_compare_1_1               : std_logic;
  SIGNAL Add2_out1_1                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Switch_Limit_High_out1           : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Constant1_out1                   : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add3_out1                        : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add3_out1_1                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Switch_Limit_Low_out1            : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL ScaleTheta_mul_temp              : signed(47 DOWNTO 0);  -- sfix48_En45
  SIGNAL ScaleTheta_out1                  : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL ScaleTheta_out1_1                : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Cosine_out1                      : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Cosine_out2                      : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Cosine_out1_signed               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Cosine_out1_1                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Cosine_out1_2                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Cosine_out2_signed               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Cosine_out2_1                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Cosine_out2_2                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL switch_compare_1_2               : std_logic;
  SIGNAL stateControl_3                   : std_logic;
  SIGNAL stateControl_4                   : std_logic;
  SIGNAL enb_gated_1                      : std_logic;
  SIGNAL Id_ref_AXI_signed                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Id_ref_AXI_1                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on2_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay2_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL reduced_reg                      : vector_of_signed18(0 TO 3);  -- sfix18 [4]
  SIGNAL Switch_on2_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Product_mul_temp                 : signed(33 DOWNTO 0);  -- sfix34_En25
  SIGNAL Product_out1                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL switch_compare_1_3               : std_logic;
  SIGNAL stateControl_5                   : std_logic;
  SIGNAL stateControl_6                   : std_logic;
  SIGNAL enb_gated_2                      : std_logic;
  SIGNAL Iq_ref_AXI_signed                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Iq_ref_AXI_1                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on3_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay1_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL reduced_reg_1                    : vector_of_signed18(0 TO 3);  -- sfix18 [4]
  SIGNAL Switch_on3_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Product1_mul_temp                : signed(33 DOWNTO 0);  -- sfix34_En25
  SIGNAL Product1_out1                    : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Subtract_out1                    : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Subtract_out1_1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Product2_mul_temp                : signed(33 DOWNTO 0);  -- sfix34_En25
  SIGNAL Product2_out1                    : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Product3_mul_temp                : signed(33 DOWNTO 0);  -- sfix34_En25
  SIGNAL Product3_out1                    : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Subtract1_out1                   : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Subtract1_out1_1                 : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL DelayValue3_out1                 : std_logic;  -- ufix1
  SIGNAL Data_Type_Conversion1_out1       : signed(7 DOWNTO 0);  -- int8
  SIGNAL Second_value                     : std_logic;  -- ufix1
  SIGNAL Data_Type_Conversion2_out1       : signed(7 DOWNTO 0);  -- int8
  SIGNAL Gain_out1                        : signed(15 DOWNTO 0);  -- sfix16_En5
  SIGNAL Add4_add_cast                    : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Switch                           : signed(7 DOWNTO 0);  -- int8
  SIGNAL reduced_reg_2                    : vector_of_signed8(0 TO 3);  -- sfix8 [4]
  SIGNAL Switch_1                         : signed(7 DOWNTO 0);  -- int8
  SIGNAL Switch_2                         : signed(7 DOWNTO 0);  -- int8
  SIGNAL switch_compare_1_4               : std_logic;
  SIGNAL stateControl_7                   : std_logic;
  SIGNAL delayMatch12_reg                 : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL stateControl_8                   : std_logic;
  SIGNAL enb_gated_3                      : std_logic;
  SIGNAL Gain2_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Add_stage2_add_cast              : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL Add_stage2_add_cast_1            : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL Add_op_stage1                    : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL Constant2_out1                   : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL delayMatch8_reg                  : vector_of_signed18(0 TO 4);  -- sfix18 [5]
  SIGNAL Gain3_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Add_stage3_add_cast              : signed(19 DOWNTO 0);  -- sfix20_En11
  SIGNAL Add_stage3_add_cast_1            : signed(19 DOWNTO 0);  -- sfix20_En11
  SIGNAL Add_stage3_add_temp              : signed(19 DOWNTO 0);  -- sfix20_En11
  SIGNAL Add_out1                         : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on4_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay4_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on4_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL switch_compare_1_5               : std_logic;
  SIGNAL stateControl_9                   : std_logic;
  SIGNAL delayMatch14_reg                 : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL stateControl_10                  : std_logic;
  SIGNAL enb_gated_4                      : std_logic;
  SIGNAL Gain4_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En29
  SIGNAL Gain4_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain5_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En28
  SIGNAL Gain5_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Add5_stage2_add_cast             : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL Add5_stage2_add_cast_1           : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL Add5_op_stage1                   : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL delayMatch9_reg                  : vector_of_signed18(0 TO 4);  -- sfix18 [5]
  SIGNAL Gain6_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Add5_stage3_add_cast             : signed(19 DOWNTO 0);  -- sfix20_En11
  SIGNAL Add5_stage3_add_cast_1           : signed(19 DOWNTO 0);  -- sfix20_En11
  SIGNAL Add5_stage3_add_temp             : signed(19 DOWNTO 0);  -- sfix20_En11
  SIGNAL Add5_out1                        : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on5_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay5_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on5_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL switch_compare_1_6               : std_logic;
  SIGNAL stateControl_11                  : std_logic;
  SIGNAL delayMatch16_reg                 : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL stateControl_12                  : std_logic;
  SIGNAL enb_gated_5                      : std_logic;
  SIGNAL Gain7_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En29
  SIGNAL Gain7_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain8_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En28
  SIGNAL Gain8_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Add6_stage2_add_cast             : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL Add6_stage2_add_cast_1           : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL Add6_op_stage1                   : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL delayMatch10_reg                 : vector_of_signed18(0 TO 4);  -- sfix18 [5]
  SIGNAL Gain9_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Add6_stage3_add_cast             : signed(19 DOWNTO 0);  -- sfix20_En11
  SIGNAL Add6_stage3_add_cast_1           : signed(19 DOWNTO 0);  -- sfix20_En11
  SIGNAL Add6_stage3_add_temp             : signed(19 DOWNTO 0);  -- sfix20_En11
  SIGNAL Add6_out1                        : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on6_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay6_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on6_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11

BEGIN
  -- Delay to compensate the 1 pipeline before the multiplication.
  -- 1 Pipeline for the second repeating.
  -- 
  -- cosine -> Nur Look-Up,
  -- keine Multiplikatoren
  -- verwendet
  -- 
  -- - Ich lass den ganzen IP Core mit einem langsameren Clock laufen, 
  --  damit ich keine Timingverletzung durch die Trigonometrische 
  --  Funktion in Vivado bekomme.
  -- - Dadurch das ich unnütze Pipeline Stages einspare, sollte 
  --  die notwendige Gesamtzeit konstant bleiben.
  -- - Der cosine braucht bei (2^7)+1 circa 24ns Durchlaufzeit.
  -- - Zwischen (2^7)+1 und (2^13)+1 macht die Genauigkeit Sinn. Je mehr Bits
  --  desto Genauer, aber desto längere Durchlaufzeiten habe ich als auch mehr
  --   Ressourcen brauche ich. (Habe mich aktuell für (2^9)+1 entschieden.
  -- 
  -- Durch den Delay von 5, wird ab erkennen der Flanke,
  -- das Signal für 5 Takte high bleiben.
  -- Hierdurch kann man die Impuls Länge des Enables einstellen.
  -- Da ich diesen IP-Core mit 25MHz laufen lasse, bedeuten 5 Delays -> 20 Clocks at 100MHz
  -- 
  -- 1 for one cycle if edge recognized
  -- 
  -- Wir brauchen hier auf jeden Fall 4 Taktzyklen-Flag (@100MHz),
  -- damit ich es mit dem 25MHZ IP-Core sicher erkennen kann. Das hab 
  -- ich aber, da die Strommessung mit "CurrentValid" ein sehr langes Flag
  -- (345 Takte @100MHz) ausgibt!
  -- 
  -- Because of the subsequent VoltageVectors runs with 25MHz and this
  -- IP Core also runs with 25MHz, we need a DONE-Flag for at least 1 cycle.
  -- Now, since this block runs at 25MHz, i have 20 cycles (at 100MHz) in order
  -- to connect this dq-transformation also with other, slower, IP Cores such as
  -- FOC.

  u_Cosine : Trans_dq_alphabeta_123_ip_src_Cosine
    PORT MAP( u => std_logic_vector(ScaleTheta_out1_1),  -- sfix24_En20
              sin_2_pi_u => Cosine_out1,  -- sfix16_En14
              cos_2_pi_u => Cosine_out2  -- sfix16_En14
              );

  enb <= clk_enable;

  in_2_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        CurrentValid_in_1 <= '0';
      ELSIF enb = '1' THEN
        CurrentValid_in_1 <= CurrentValid_in;
      END IF;
    END IF;
  END PROCESS in_2_pipe_process;


  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        stateControl_2 <= '0';
      ELSIF enb = '1' THEN
        stateControl_2 <= stateControl_1;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  enb_gated <= stateControl_2 AND clk_enable;

  
  reset_old_switch1_out1 <= reset_old2_out1 WHEN alpha1_for_one_cycle_if_edge_recognized = to_signed(16#00#, 8) ELSE
      CurrentValid_in_1;

  reset_old2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old2_out1 <= '0';
      ELSIF enb_gated = '1' THEN
        reset_old2_out1 <= reset_old_switch1_out1;
      END IF;
    END IF;
  END PROCESS reset_old2_process;


  Detec_edge_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & CurrentValid_in_1;
  Detec_edge_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old2_out1;
  alpha1_for_one_cycle_if_edge_recognized <= Detec_edge_sub_cast - Detec_edge_sub_cast_1;

  alpha1_for_one_cycle_if_edge_recognized_1 <= alpha1_for_one_cycle_if_edge_recognized;

  
  dtc_out <= '1' WHEN (alpha1_for_one_cycle_if_edge_recognized_1(7) = '0') AND (alpha1_for_one_cycle_if_edge_recognized_1(6 DOWNTO 1) /= "000000") ELSE
      '0' WHEN alpha1_for_one_cycle_if_edge_recognized_1(7) = '1' ELSE
      alpha1_for_one_cycle_if_edge_recognized_1(0);

  Saturation_out1 <= dtc_out;

  DelayValid_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        DelayValid_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        DelayValid_reg(0) <= Saturation_out1;
        DelayValid_reg(1) <= DelayValid_reg(0);
      END IF;
    END IF;
  END PROCESS DelayValid_process;

  End_Cycle <= DelayValid_reg(1);

  shift6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift6_out1 <= '0';
      ELSIF enb = '1' THEN
        shift6_out1 <= End_Cycle;
      END IF;
    END IF;
  END PROCESS shift6_process;


  shift1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift1_out1 <= '0';
      ELSIF enb = '1' THEN
        shift1_out1 <= shift6_out1;
      END IF;
    END IF;
  END PROCESS shift1_process;


  shift2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift2_out1 <= '0';
      ELSIF enb = '1' THEN
        shift2_out1 <= shift1_out1;
      END IF;
    END IF;
  END PROCESS shift2_process;


  shift3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift3_out1 <= '0';
      ELSIF enb = '1' THEN
        shift3_out1 <= shift2_out1;
      END IF;
    END IF;
  END PROCESS shift3_process;


  Logical_Operator_out1 <= shift3_out1 OR (shift2_out1 OR (shift1_out1 OR (End_Cycle OR shift6_out1)));

  delayMatch17_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch17_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch17_reg(0) <= Logical_Operator_out1;
        delayMatch17_reg(1 TO 4) <= delayMatch17_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch17_process;

  Logical_Operator_out1_1 <= delayMatch17_reg(4);

  theta_signed <= signed(theta);

  in_0_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        theta_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        theta_1 <= theta_signed;
      END IF;
    END IF;
  END PROCESS in_0_pipe_process;


  theta_offset_AXI_signed <= signed(theta_offset_AXI);

  in_1_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        theta_offset_AXI_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        theta_offset_AXI_1 <= theta_offset_AXI_signed;
      END IF;
    END IF;
  END PROCESS in_1_pipe_process;


  Add1_out1 <= theta_1 - theta_offset_AXI_1;

  Add1_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add1_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        Add1_out1_1 <= Add1_out1;
      END IF;
    END IF;
  END PROCESS Add1_out_pipe_process;


  
  Compare_Limit_Low_out1 <= '1' WHEN Add1_out1_1 < to_signed(16#000000#, 24) ELSE
      '0';

  
  Compare_Limit_High_out1 <= '1' WHEN Add1_out1_1 >= to_signed(16#6487ED#, 24) ELSE
      '0';

  Compare_Limit_High_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Compare_Limit_High_out1_1 <= '0';
      ELSIF enb = '1' THEN
        Compare_Limit_High_out1_1 <= Compare_Limit_High_out1;
      END IF;
    END IF;
  END PROCESS Compare_Limit_High_out_pipe_process;


  
  switch_compare_1 <= '1' WHEN Compare_Limit_High_out1_1 > '0' ELSE
      '0';

  delayMatch1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add1_out1_2 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        Add1_out1_2 <= Add1_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch1_process;


  Constant_out1 <= to_signed(16#6487ED#, 24);

  Add2_out1 <= Add1_out1_1 - Constant_out1;

  Compare_Limit_Low_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Compare_Limit_Low_out1_1 <= '0';
      ELSIF enb = '1' THEN
        Compare_Limit_Low_out1_1 <= Compare_Limit_Low_out1;
      END IF;
    END IF;
  END PROCESS Compare_Limit_Low_out_pipe_process;


  
  switch_compare_1_1 <= '1' WHEN Compare_Limit_Low_out1_1 > '0' ELSE
      '0';

  Add2_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add2_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        Add2_out1_1 <= Add2_out1;
      END IF;
    END IF;
  END PROCESS Add2_out_pipe_process;


  
  Switch_Limit_High_out1 <= Add1_out1_2 WHEN switch_compare_1 = '0' ELSE
      Add2_out1_1;

  Constant1_out1 <= to_signed(16#6487ED#, 24);

  Add3_out1 <= Add1_out1_1 + Constant1_out1;

  Add3_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add3_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        Add3_out1_1 <= Add3_out1;
      END IF;
    END IF;
  END PROCESS Add3_out_pipe_process;


  
  Switch_Limit_Low_out1 <= Switch_Limit_High_out1 WHEN switch_compare_1_1 = '0' ELSE
      Add3_out1_1;

  -- CSD Encoding (5340354) : 01010001100001'0011000010; Cost (Adders) = 7
  ScaleTheta_mul_temp <= ((((((resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) - resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0', 48);
  ScaleTheta_out1 <= resize(ScaleTheta_mul_temp(47 DOWNTO 25), 24);

  Cosine_in_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        ScaleTheta_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        ScaleTheta_out1_1 <= ScaleTheta_out1;
      END IF;
    END IF;
  END PROCESS Cosine_in_pipe_process;


  Cosine_out1_signed <= signed(Cosine_out1);

  Cosine_out_pipe0_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Cosine_out1_1 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        Cosine_out1_1 <= Cosine_out1_signed;
      END IF;
    END IF;
  END PROCESS Cosine_out_pipe0_process;


  out_1_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Cosine_out1_2 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        Cosine_out1_2 <= Cosine_out1_1;
      END IF;
    END IF;
  END PROCESS out_1_pipe_process;


  sin <= std_logic_vector(Cosine_out1_2);

  Cosine_out2_signed <= signed(Cosine_out2);

  Cosine_out_pipe1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Cosine_out2_1 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        Cosine_out2_1 <= Cosine_out2_signed;
      END IF;
    END IF;
  END PROCESS Cosine_out_pipe1_process;


  out_2_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Cosine_out2_2 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        Cosine_out2_2 <= Cosine_out2_1;
      END IF;
    END IF;
  END PROCESS out_2_pipe_process;


  cos <= std_logic_vector(Cosine_out2_2);

  
  switch_compare_1_2 <= '1' WHEN Saturation_out1 = '1' ELSE
      '0';

  stateControl_3 <= '1';

  delayMatch2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        stateControl_4 <= '0';
      ELSIF enb = '1' THEN
        stateControl_4 <= stateControl_3;
      END IF;
    END IF;
  END PROCESS delayMatch2_process;


  enb_gated_1 <= stateControl_4 AND clk_enable;

  Id_ref_AXI_signed <= signed(Id_ref_AXI);

  in_3_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Id_ref_AXI_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        Id_ref_AXI_1 <= Id_ref_AXI_signed;
      END IF;
    END IF;
  END PROCESS in_3_pipe_process;


  Delay2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay2_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_1 = '1' THEN
        Delay2_out1 <= Switch_on2_out1;
      END IF;
    END IF;
  END PROCESS Delay2_process;


  
  Switch_on2_out1 <= Delay2_out1 WHEN switch_compare_1_2 = '0' ELSE
      Id_ref_AXI_1;

  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        reduced_reg(0) <= Switch_on2_out1;
        reduced_reg(1 TO 3) <= reduced_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS reduced_process;

  Switch_on2_out1_1 <= reduced_reg(3);

  Product_mul_temp <= Switch_on2_out1_1 * Cosine_out2_1;
  Product_out1 <= Product_mul_temp(31 DOWNTO 14);

  
  switch_compare_1_3 <= '1' WHEN Saturation_out1 = '1' ELSE
      '0';

  stateControl_5 <= '1';

  delayMatch4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        stateControl_6 <= '0';
      ELSIF enb = '1' THEN
        stateControl_6 <= stateControl_5;
      END IF;
    END IF;
  END PROCESS delayMatch4_process;


  enb_gated_2 <= stateControl_6 AND clk_enable;

  Iq_ref_AXI_signed <= signed(Iq_ref_AXI);

  in_4_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Iq_ref_AXI_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        Iq_ref_AXI_1 <= Iq_ref_AXI_signed;
      END IF;
    END IF;
  END PROCESS in_4_pipe_process;


  Delay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay1_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_2 = '1' THEN
        Delay1_out1 <= Switch_on3_out1;
      END IF;
    END IF;
  END PROCESS Delay1_process;


  
  Switch_on3_out1 <= Delay1_out1 WHEN switch_compare_1_3 = '0' ELSE
      Iq_ref_AXI_1;

  reduced_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg_1 <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        reduced_reg_1(0) <= Switch_on3_out1;
        reduced_reg_1(1 TO 3) <= reduced_reg_1(0 TO 2);
      END IF;
    END IF;
  END PROCESS reduced_1_process;

  Switch_on3_out1_1 <= reduced_reg_1(3);

  Product1_mul_temp <= Switch_on3_out1_1 * Cosine_out1_1;
  Product1_out1 <= Product1_mul_temp(31 DOWNTO 14);

  Subtract_out1 <= Product_out1 - Product1_out1;

  reduced_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Subtract_out1_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        Subtract_out1_1 <= Subtract_out1;
      END IF;
    END IF;
  END PROCESS reduced_2_process;


  ialpha <= std_logic_vector(Subtract_out1_1);

  ialpha_AXI <= std_logic_vector(Subtract_out1_1);

  Product2_mul_temp <= Switch_on2_out1_1 * Cosine_out1_1;
  Product2_out1 <= Product2_mul_temp(31 DOWNTO 14);

  Product3_mul_temp <= Switch_on3_out1_1 * Cosine_out2_1;
  Product3_out1 <= Product3_mul_temp(31 DOWNTO 14);

  Subtract1_out1 <= Product2_out1 + Product3_out1;

  reduced_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Subtract1_out1_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        Subtract1_out1_1 <= Subtract1_out1;
      END IF;
    END IF;
  END PROCESS reduced_3_process;


  ibeta <= std_logic_vector(Subtract1_out1_1);

  ibeta_AXI <= std_logic_vector(Subtract1_out1_1);

  DelayValue3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        DelayValue3_out1 <= '0';
      ELSIF enb = '1' THEN
        DelayValue3_out1 <= Saturation_out1;
      END IF;
    END IF;
  END PROCESS DelayValue3_process;


  Data_Type_Conversion1_out1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & DelayValue3_out1;

  Delay36_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Second_value <= '0';
      ELSIF enb = '1' THEN
        Second_value <= DelayValue3_out1;
      END IF;
    END IF;
  END PROCESS Delay36_process;


  Data_Type_Conversion2_out1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & Second_value;

  Gain_out1 <= resize(Data_Type_Conversion2_out1 & '0' & '0' & '0' & '0' & '0' & '0', 16);

  Add4_add_cast <= Gain_out1(12 DOWNTO 5);
  Switch <= Data_Type_Conversion1_out1 + Add4_add_cast;

  reduced_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg_2 <= (OTHERS => to_signed(16#00#, 8));
      ELSIF enb = '1' THEN
        reduced_reg_2(0) <= Switch;
        reduced_reg_2(1 TO 3) <= reduced_reg_2(0 TO 2);
      END IF;
    END IF;
  END PROCESS reduced_4_process;

  Switch_1 <= reduced_reg_2(3);

  Switch_2 <= Switch_1;

  
  switch_compare_1_4 <= '1' WHEN Switch_2 >= to_signed(16#01#, 8) ELSE
      '0';

  stateControl_7 <= '1';

  delayMatch12_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch12_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch12_reg(0) <= stateControl_7;
        delayMatch12_reg(1 TO 4) <= delayMatch12_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch12_process;

  stateControl_8 <= delayMatch12_reg(4);

  enb_gated_3 <= stateControl_8 AND clk_enable;

  Gain2_out1 <= to_signed(16#00000#, 18);

  Add_stage2_add_cast <= resize(Subtract_out1, 19);
  Add_stage2_add_cast_1 <= resize(Gain2_out1, 19);
  Add_op_stage1 <= Add_stage2_add_cast + Add_stage2_add_cast_1;

  Constant2_out1 <= to_signed(16#00000#, 18);

  delayMatch8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch8_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        delayMatch8_reg(0) <= Constant2_out1;
        delayMatch8_reg(1 TO 4) <= delayMatch8_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch8_process;

  Gain3_out1 <= delayMatch8_reg(4);

  Add_stage3_add_cast <= resize(Add_op_stage1, 20);
  Add_stage3_add_cast_1 <= resize(Gain3_out1, 20);
  Add_stage3_add_temp <= Add_stage3_add_cast + Add_stage3_add_cast_1;
  Add_out1 <= Add_stage3_add_temp(17 DOWNTO 0);

  Delay4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay4_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_3 = '1' THEN
        Delay4_out1 <= Switch_on4_out1;
      END IF;
    END IF;
  END PROCESS Delay4_process;


  
  Switch_on4_out1 <= Delay4_out1 WHEN switch_compare_1_4 = '0' ELSE
      Add_out1;

  reduced_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on4_out1_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        Switch_on4_out1_1 <= Switch_on4_out1;
      END IF;
    END IF;
  END PROCESS reduced_5_process;


  i1 <= std_logic_vector(Switch_on4_out1_1);

  i1_AXI <= std_logic_vector(Switch_on4_out1_1);

  
  switch_compare_1_5 <= '1' WHEN Switch_1 >= to_signed(16#01#, 8) ELSE
      '0';

  stateControl_9 <= '1';

  delayMatch14_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch14_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch14_reg(0) <= stateControl_9;
        delayMatch14_reg(1 TO 4) <= delayMatch14_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch14_process;

  stateControl_10 <= delayMatch14_reg(4);

  enb_gated_4 <= stateControl_10 AND clk_enable;

  -- CSD Encoding (131072) : 100000000000000000; Cost (Adders) = 0
  Gain4_mul_temp <=  - (resize(Subtract_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36));
  Gain4_out1 <= Gain4_mul_temp(35 DOWNTO 18);

  Gain5_mul_temp <= to_signed(16#1BB68#, 18) * Subtract1_out1;
  Gain5_out1 <= Gain5_mul_temp(34 DOWNTO 17);

  Add5_stage2_add_cast <= resize(Gain4_out1, 19);
  Add5_stage2_add_cast_1 <= resize(Gain5_out1, 19);
  Add5_op_stage1 <= Add5_stage2_add_cast + Add5_stage2_add_cast_1;

  delayMatch9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch9_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        delayMatch9_reg(0) <= Constant2_out1;
        delayMatch9_reg(1 TO 4) <= delayMatch9_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch9_process;

  Gain6_out1 <= delayMatch9_reg(4);

  Add5_stage3_add_cast <= resize(Add5_op_stage1, 20);
  Add5_stage3_add_cast_1 <= resize(Gain6_out1, 20);
  Add5_stage3_add_temp <= Add5_stage3_add_cast + Add5_stage3_add_cast_1;
  Add5_out1 <= Add5_stage3_add_temp(17 DOWNTO 0);

  Delay5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay5_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_4 = '1' THEN
        Delay5_out1 <= Switch_on5_out1;
      END IF;
    END IF;
  END PROCESS Delay5_process;


  
  Switch_on5_out1 <= Delay5_out1 WHEN switch_compare_1_5 = '0' ELSE
      Add5_out1;

  reduced_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on5_out1_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        Switch_on5_out1_1 <= Switch_on5_out1;
      END IF;
    END IF;
  END PROCESS reduced_6_process;


  i2 <= std_logic_vector(Switch_on5_out1_1);

  i2_AXI <= std_logic_vector(Switch_on5_out1_1);

  
  switch_compare_1_6 <= '1' WHEN Switch_1 >= to_signed(16#01#, 8) ELSE
      '0';

  stateControl_11 <= '1';

  delayMatch16_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch16_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch16_reg(0) <= stateControl_11;
        delayMatch16_reg(1 TO 4) <= delayMatch16_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch16_process;

  stateControl_12 <= delayMatch16_reg(4);

  enb_gated_5 <= stateControl_12 AND clk_enable;

  -- CSD Encoding (131072) : 100000000000000000; Cost (Adders) = 0
  Gain7_mul_temp <=  - (resize(Subtract_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36));
  Gain7_out1 <= Gain7_mul_temp(35 DOWNTO 18);

  Gain8_mul_temp <= to_signed(-16#1BB68#, 18) * Subtract1_out1;
  Gain8_out1 <= Gain8_mul_temp(34 DOWNTO 17);

  Add6_stage2_add_cast <= resize(Gain7_out1, 19);
  Add6_stage2_add_cast_1 <= resize(Gain8_out1, 19);
  Add6_op_stage1 <= Add6_stage2_add_cast + Add6_stage2_add_cast_1;

  delayMatch10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch10_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        delayMatch10_reg(0) <= Constant2_out1;
        delayMatch10_reg(1 TO 4) <= delayMatch10_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch10_process;

  Gain9_out1 <= delayMatch10_reg(4);

  Add6_stage3_add_cast <= resize(Add6_op_stage1, 20);
  Add6_stage3_add_cast_1 <= resize(Gain9_out1, 20);
  Add6_stage3_add_temp <= Add6_stage3_add_cast + Add6_stage3_add_cast_1;
  Add6_out1 <= Add6_stage3_add_temp(17 DOWNTO 0);

  Delay6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay6_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_5 = '1' THEN
        Delay6_out1 <= Switch_on6_out1;
      END IF;
    END IF;
  END PROCESS Delay6_process;


  
  Switch_on6_out1 <= Delay6_out1 WHEN switch_compare_1_6 = '0' ELSE
      Add6_out1;

  reduced_7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on6_out1_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        Switch_on6_out1_1 <= Switch_on6_out1;
      END IF;
    END IF;
  END PROCESS reduced_7_process;


  i3 <= std_logic_vector(Switch_on6_out1_1);

  i3_AXI <= std_logic_vector(Switch_on6_out1_1);

  ce_out <= clk_enable;

  dq_Done <= Logical_Operator_out1_1;

END rtl;

