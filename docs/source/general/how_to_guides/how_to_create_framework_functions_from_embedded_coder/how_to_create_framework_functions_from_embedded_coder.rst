=====================================================
How to create framework functions from Embedded Coder
=====================================================

The functions of the UltraZohm :ref:`software_framework` follow the principles outlined in :ref:`software_development_guidelines`.
Encapsulation and data hiding are important characteristics for these software modules.
C-Code that is generated by using the :ref:``embedded_coder`` is not directly compatible with the software guidelines and require a wrapper module to be included in the software framework.
The guiding principle is that the interface has to be consistent across modules since it is not relevant wether the code is hand written or auto-generated.

The following guide builds on the example model of :ref:`embedded_coder` and highlight how to create an interface that is consistent with the :ref:`software_development_guidelines` (multiple-instance module).


Functional description of the module
====================================


.. _embedded_coder_subsystem_screenshot:

.. figure:: codegen_simulink.png
   :width: 800px
   :align: center

   Screenshot of the subsystem that is used for code generation in the example of :ref:`embedded_coder`

:numref:`embedded_coder_subsystem_screenshot` shows the subsystem that is code generated in :ref:`embedded_coder`.
The following guide only implements an interface for the *sum* functionality of the module.
Thus, the code ought to calculate:

.. math::

    y &= a + b + c \\
    y_2 &=\int y

The Simulink model uses forward euler integration (see `Matlab documentation discrete integrator <https://de.mathworks.com/help/simulink/slref/discretetimeintegrator.html>`_).
The chirp function is not used in this guide but can be implemented with the same principles.

Create framework function
=========================

.. note:: This guide uses the already generated files of the example in :ref:`embedded_coder`. For custom modules, this step has to be adjusted to match the path of the specific embedded coder settings!


1. Open ``ultrazohm_sw`` with VSCode and remote container (see :ref:`vscode_remote_container`)
2. Create a new module ``uz_sum`` using ceedling

::

    cd vitis/software/Baremetal
    ceedling module:create[uz/uz_sum/uz_sum]

3. Ceedling creates the header, source, and test files
4. Copy the generated files to ``uz_sum``, e.g., by using the following command:

::

    cp -R src/Codegen/uz_codegen0_ert_rtw/ src/uz/uz_sum/

5. Create the allocation scheme using the allocation snippet (see :ref:`how_to_create_ipcore_driver`)
6. Call the module ``uz_sum``
7. Add ``UZ_SUM_MAX_INSTANCES`` to ``uz_global_configuration.h`` and set it to 5
8. Add the typedef for the ``uz_sum_t`` to ``uz_sum.h`` as well as the function declaration for the init function:

.. code-block:: c

    typedef struct uz_sum_t uz_sum_t;
    uz_sum_t* uz_sum_init();


9. In ``test_uz_sum.c``, change the existing test to:

.. code-block:: c

    void test_uz_sum_NeedToImplement(void)
    {
        uz_sum_init();
    }

10. Run the tests, they compile but ``test_uz_sum.c`` does not perform any real tests






