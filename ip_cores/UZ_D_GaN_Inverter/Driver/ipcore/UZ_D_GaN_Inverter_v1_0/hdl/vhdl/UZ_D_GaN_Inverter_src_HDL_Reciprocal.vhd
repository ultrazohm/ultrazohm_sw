-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\UZ_D_GaN_Inverter_reduced\UZ_D_GaN_Inverter_src_HDL_Reciprocal.vhd
-- Created: 2021-05-06 13:31:53
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: UZ_D_GaN_Inverter_src_HDL_Reciprocal
-- Source Path: UZ_D_GaN_Inverter_reduced/UZ_D_GaN_Inverter/HDL Reciprocal
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.UZ_D_GaN_Inverter_src_UZ_D_GaN_Inverter_pkg.ALL;

ENTITY UZ_D_GaN_Inverter_src_HDL_Reciprocal IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        din                               :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        dout                              :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32_En31
        );
END UZ_D_GaN_Inverter_src_HDL_Reciprocal;


ARCHITECTURE rtl OF UZ_D_GaN_Inverter_src_HDL_Reciprocal IS

  -- Component Declarations
  COMPONENT UZ_D_GaN_Inverter_src_HDL_Reciprocal_core
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          xin                             :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En30
          ain                             :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En32
          xout                            :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32_En30
          aout                            :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32_En32
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : UZ_D_GaN_Inverter_src_HDL_Reciprocal_core
    USE ENTITY work.UZ_D_GaN_Inverter_src_HDL_Reciprocal_core(rtl);

  -- Signals
  SIGNAL din_unsigned                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL anorm                            : unsigned(31 DOWNTO 0);  -- ufix32_En32
  SIGNAL dynamicshift                     : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL onemoreshift                     : std_logic;  -- ufix1
  SIGNAL anorm_p                          : unsigned(31 DOWNTO 0);  -- ufix32_En32
  SIGNAL mstwobit                         : std_logic;  -- ufix1
  SIGNAL inzero                           : std_logic;  -- ufix1
  SIGNAL inzero_reg_reg                   : std_logic_vector(0 TO 5);  -- ufix1 [6]
  SIGNAL inzero_p                         : std_logic;  -- ufix1
  SIGNAL x0                               : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL xstage1                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL astage1                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL xstage2                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL astage2                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL xstage3                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL astage3                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL xstage3_unsigned                 : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL ds_reg_reg                       : vector_of_unsigned5(0 TO 6);  -- ufix5 [7]
  SIGNAL dynamicshift_p                   : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL constInf                         : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL onemoreshift_reg_reg             : std_logic_vector(0 TO 6);  -- ufix1 [7]
  SIGNAL onemoreshift_p                   : std_logic;  -- ufix1
  SIGNAL denormout                        : unsigned(31 DOWNTO 0);  -- ufix32_En31
  SIGNAL dout_tmp                         : unsigned(31 DOWNTO 0);  -- ufix32_En31

BEGIN
  -- Single-rate Reciprocal Implementation using Reciprocal Newton Method

  u_core_stage1_inst : UZ_D_GaN_Inverter_src_HDL_Reciprocal_core
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              xin => std_logic_vector(x0),  -- ufix32_En30
              ain => std_logic_vector(anorm_p),  -- ufix32_En32
              xout => xstage1,  -- ufix32_En30
              aout => astage1  -- ufix32_En32
              );

  u_core_stage2_inst : UZ_D_GaN_Inverter_src_HDL_Reciprocal_core
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              xin => xstage1,  -- ufix32_En30
              ain => astage1,  -- ufix32_En32
              xout => xstage2,  -- ufix32_En30
              aout => astage2  -- ufix32_En32
              );

  u_core_stage3_inst : UZ_D_GaN_Inverter_src_HDL_Reciprocal_core
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              xin => xstage2,  -- ufix32_En30
              ain => astage2,  -- ufix32_En32
              xout => xstage3,  -- ufix32_En30
              aout => astage3  -- ufix32_En32
              );

  din_unsigned <= unsigned(din);

  -- Input Normalization
  in_norm_output : PROCESS (din_unsigned)
    VARIABLE out1 : unsigned(4 DOWNTO 0);
    VARIABLE c_r : std_logic;
    VARIABLE c : unsigned(31 DOWNTO 0);
    VARIABLE in0 : unsigned(1 DOWNTO 0);
    VARIABLE in0_0 : unsigned(1 DOWNTO 0);
    VARIABLE in0_1 : unsigned(1 DOWNTO 0);
    VARIABLE in0_2 : unsigned(1 DOWNTO 0);
    VARIABLE cast : unsigned(7 DOWNTO 0);
    VARIABLE in0_3 : unsigned(1 DOWNTO 0);
    VARIABLE in0_4 : unsigned(1 DOWNTO 0);
    VARIABLE in0_5 : unsigned(1 DOWNTO 0);
    VARIABLE in0_6 : unsigned(1 DOWNTO 0);
    VARIABLE in0_7 : unsigned(1 DOWNTO 0);
    VARIABLE in0_8 : unsigned(1 DOWNTO 0);
    VARIABLE in0_9 : unsigned(1 DOWNTO 0);
    VARIABLE in0_10 : unsigned(1 DOWNTO 0);
    VARIABLE in0_11 : unsigned(1 DOWNTO 0);
    VARIABLE in0_12 : unsigned(1 DOWNTO 0);
    VARIABLE in0_13 : unsigned(1 DOWNTO 0);
  BEGIN
    in0_0 := to_unsigned(16#0#, 2);
    in0_1 := to_unsigned(16#0#, 2);
    in0_2 := to_unsigned(16#0#, 2);
    in0_3 := to_unsigned(16#0#, 2);
    in0_4 := to_unsigned(16#0#, 2);
    in0_5 := to_unsigned(16#0#, 2);
    in0_6 := to_unsigned(16#0#, 2);
    in0_7 := to_unsigned(16#0#, 2);
    in0_8 := to_unsigned(16#0#, 2);
    in0_9 := to_unsigned(16#0#, 2);
    in0_10 := to_unsigned(16#0#, 2);
    in0_11 := to_unsigned(16#0#, 2);
    in0_12 := to_unsigned(16#0#, 2);
    in0_13 := to_unsigned(16#0#, 2);
    in0 := din_unsigned(31 DOWNTO 30);
    IF (in0(1) OR in0(0)) = '1' THEN 
      out1 := to_unsigned(16#00#, 5);
    ELSE 
      in0_0 := din_unsigned(29 DOWNTO 28);
      IF (in0_0(1) OR in0_0(0)) = '1' THEN 
        out1 := to_unsigned(16#01#, 5);
      ELSE 
        in0_1 := din_unsigned(27 DOWNTO 26);
        IF (in0_1(1) OR in0_1(0)) = '1' THEN 
          out1 := to_unsigned(16#02#, 5);
        ELSE 
          in0_2 := din_unsigned(25 DOWNTO 24);
          IF (in0_2(1) OR in0_2(0)) = '1' THEN 
            out1 := to_unsigned(16#03#, 5);
          ELSE 
            in0_3 := din_unsigned(23 DOWNTO 22);
            IF (in0_3(1) OR in0_3(0)) = '1' THEN 
              out1 := to_unsigned(16#04#, 5);
            ELSE 
              in0_4 := din_unsigned(21 DOWNTO 20);
              IF (in0_4(1) OR in0_4(0)) = '1' THEN 
                out1 := to_unsigned(16#05#, 5);
              ELSE 
                in0_5 := din_unsigned(19 DOWNTO 18);
                IF (in0_5(1) OR in0_5(0)) = '1' THEN 
                  out1 := to_unsigned(16#06#, 5);
                ELSE 
                  in0_6 := din_unsigned(17 DOWNTO 16);
                  IF (in0_6(1) OR in0_6(0)) = '1' THEN 
                    out1 := to_unsigned(16#07#, 5);
                  ELSE 
                    in0_7 := din_unsigned(15 DOWNTO 14);
                    IF (in0_7(1) OR in0_7(0)) = '1' THEN 
                      out1 := to_unsigned(16#08#, 5);
                    ELSE 
                      in0_8 := din_unsigned(13 DOWNTO 12);
                      IF (in0_8(1) OR in0_8(0)) = '1' THEN 
                        out1 := to_unsigned(16#09#, 5);
                      ELSE 
                        in0_9 := din_unsigned(11 DOWNTO 10);
                        IF (in0_9(1) OR in0_9(0)) = '1' THEN 
                          out1 := to_unsigned(16#0A#, 5);
                        ELSE 
                          in0_10 := din_unsigned(9 DOWNTO 8);
                          IF (in0_10(1) OR in0_10(0)) = '1' THEN 
                            out1 := to_unsigned(16#0B#, 5);
                          ELSE 
                            in0_11 := din_unsigned(7 DOWNTO 6);
                            IF (in0_11(1) OR in0_11(0)) = '1' THEN 
                              out1 := to_unsigned(16#0C#, 5);
                            ELSE 
                              in0_12 := din_unsigned(5 DOWNTO 4);
                              IF (in0_12(1) OR in0_12(0)) = '1' THEN 
                                out1 := to_unsigned(16#0D#, 5);
                              ELSE 
                                in0_13 := din_unsigned(3 DOWNTO 2);
                                IF (in0_13(1) OR in0_13(0)) = '1' THEN 
                                  out1 := to_unsigned(16#0E#, 5);
                                ELSE 
                                  out1 := to_unsigned(16#0F#, 5);
                                END IF;
                              END IF;
                            END IF;
                          END IF;
                        END IF;
                      END IF;
                    END IF;
                  END IF;
                END IF;
              END IF;
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;
    cast := resize(out1 sll 1, 8);
    c := din_unsigned sll to_integer(cast);
    c_r :=  NOT c(31);
    IF c_r = '1' THEN 
      c := c sll 1;
    END IF;
    anorm <= c;
    dynamicshift <= out1;
    onemoreshift <= c_r;
  END PROCESS in_norm_output;


  anorm_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        anorm_p <= to_unsigned(0, 32);
      ELSIF enb = '1' THEN
        anorm_p <= anorm;
      END IF;
    END IF;
  END PROCESS anorm_reg_process;


  mstwobit <= anorm_p(31);

  
  inzero <= '1' WHEN mstwobit = '0' ELSE
      '0';

  -- Pipeline registers
  inzero_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        inzero_reg_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        inzero_reg_reg(0) <= inzero;
        inzero_reg_reg(1 TO 5) <= inzero_reg_reg(0 TO 4);
      END IF;
    END IF;
  END PROCESS inzero_reg_process;

  inzero_p <= inzero_reg_reg(5);

  x0 <= to_unsigned(1073741824, 32);

  xstage3_unsigned <= unsigned(xstage3);

  -- Pipeline registers
  ds_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        ds_reg_reg <= (OTHERS => to_unsigned(16#00#, 5));
      ELSIF enb = '1' THEN
        ds_reg_reg(0) <= dynamicshift;
        ds_reg_reg(1 TO 6) <= ds_reg_reg(0 TO 5);
      END IF;
    END IF;
  END PROCESS ds_reg_process;

  dynamicshift_p <= ds_reg_reg(6);

  constInf <= unsigned'(X"FFFFFFFF");

  onemoreshift_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        onemoreshift_reg_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        onemoreshift_reg_reg(0) <= onemoreshift;
        onemoreshift_reg_reg(1 TO 6) <= onemoreshift_reg_reg(0 TO 5);
      END IF;
    END IF;
  END PROCESS onemoreshift_reg_process;

  onemoreshift_p <= onemoreshift_reg_reg(6);

  -- Output Denormalization
  out_denorm_output : PROCESS (dynamicshift_p, onemoreshift_p, xstage3_unsigned)
    VARIABLE shiftarr : vector_of_unsigned32(0 TO 16);
    VARIABLE c1 : unsigned(5 DOWNTO 0);
    VARIABLE sub_cast : signed(31 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(31 DOWNTO 0);
  BEGIN
    sub_cast := to_signed(16#00000000#, 32);
    sub_cast_0 := to_signed(16#00000000#, 32);
    shiftarr(0) := SHIFT_RIGHT(xstage3_unsigned, 30);
    shiftarr(1) := SHIFT_RIGHT(xstage3_unsigned, 28);
    shiftarr(2) := SHIFT_RIGHT(xstage3_unsigned, 26);
    shiftarr(3) := SHIFT_RIGHT(xstage3_unsigned, 24);
    shiftarr(4) := SHIFT_RIGHT(xstage3_unsigned, 22);
    shiftarr(5) := SHIFT_RIGHT(xstage3_unsigned, 20);
    shiftarr(6) := SHIFT_RIGHT(xstage3_unsigned, 18);
    shiftarr(7) := SHIFT_RIGHT(xstage3_unsigned, 16);
    shiftarr(8) := SHIFT_RIGHT(xstage3_unsigned, 14);
    shiftarr(9) := SHIFT_RIGHT(xstage3_unsigned, 12);
    shiftarr(10) := SHIFT_RIGHT(xstage3_unsigned, 10);
    shiftarr(11) := SHIFT_RIGHT(xstage3_unsigned, 8);
    shiftarr(12) := SHIFT_RIGHT(xstage3_unsigned, 6);
    shiftarr(13) := SHIFT_RIGHT(xstage3_unsigned, 4);
    shiftarr(14) := SHIFT_RIGHT(xstage3_unsigned, 2);
    shiftarr(15) := xstage3_unsigned;
    shiftarr(16) := xstage3_unsigned;
    c1 := resize(dynamicshift_p, 6) + to_unsigned(16#01#, 6);
    IF onemoreshift_p = '0' THEN 
      sub_cast_0 := signed(resize(c1, 32));
      denormout <= SHIFT_RIGHT(shiftarr(to_integer(sub_cast_0 - 1)), 1);
    ELSE 
      sub_cast := signed(resize(c1, 32));
      denormout <= shiftarr(to_integer(sub_cast - 1));
    END IF;
  END PROCESS out_denorm_output;


  -- Zero input logic
  
  dout_tmp <= constInf WHEN inzero_p = '1' ELSE
      denormout;

  dout <= std_logic_vector(dout_tmp);

END rtl;

