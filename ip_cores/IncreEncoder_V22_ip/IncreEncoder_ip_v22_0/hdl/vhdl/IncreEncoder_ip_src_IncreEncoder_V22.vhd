-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\Encoder_Zynq\IncreEncoder_ip_src_IncreEncoder_V22.vhd
-- Created: 2018-10-01 09:32:45
-- 
-- Generated by MATLAB 9.4 and HDL Coder 3.12
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1e-10
-- Target subsystem base rate: 5e-09
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- omega                         ce_out        2e-08
-- omega_AXI4                    ce_out        2e-08
-- theta_el                      ce_out        2e-08
-- theta_el_AXI4                 ce_out        2e-08
-- theta_mech_AXI4               ce_out        2e-08
-- edge_rsvd                     ce_out        2e-08
-- count                         ce_out        2e-08
-- direction_AXI4                ce_out        2e-08
-- countPerPeriod_AXI4           ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: IncreEncoder_ip_src_IncreEncoder_V22
-- Source Path: Encoder_Zynq/IncreEncoder_V22
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.IncreEncoder_ip_src_IncreEncoder_V22_pkg.ALL;

ENTITY IncreEncoder_ip_src_IncreEncoder_V22 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        A                                 :   IN    std_logic;
        B                                 :   IN    std_logic;
        I                                 :   IN    std_logic;
        PI2_Inc_AXI4                      :   IN    std_logic_vector(23 DOWNTO 0);  -- ufix24_En24
        Timer_FPGA_ms_AXI4                :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En26
        IncPerTurn_mech_AXI4              :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        Inc_PerTurn_mech_2PI_AXI4         :   IN    std_logic_vector(23 DOWNTO 0);  -- ufix24_En24
        IncrementePerTurn_elek_AXI4       :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        OverSamplFactorInv_AXI4           :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16_En15
        OverSamplFactor_AXI4              :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        PeriodEnd                         :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        omega                             :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        omega_AXI4                        :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        theta_el                          :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        theta_el_AXI4                     :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        theta_mech_AXI4                   :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        edge_rsvd                         :   OUT   std_logic;
        count                             :   OUT   std_logic;
        direction_AXI4                    :   OUT   std_logic_vector(3 DOWNTO 0);  -- sfix4
        countPerPeriod_AXI4               :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
        );
END IncreEncoder_ip_src_IncreEncoder_V22;


ARCHITECTURE rtl OF IncreEncoder_ip_src_IncreEncoder_V22 IS

  -- Component Declarations
  COMPONENT IncreEncoder_ip_src_IncreEncoder_V22_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb_1_50_0                      :   OUT   std_logic;
          enb_1_100_0                     :   OUT   std_logic;
          enb_1_100_1                     :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT IncreEncoder_ip_src_omega_by_measure_time
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          Edge_rsvd                       :   IN    std_logic;
          T                               :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En26
          rps                             :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32_En26
          NewMeasurement                  :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT IncreEncoder_ip_src_HDL_Reciprocal
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          enb_1_50_0                      :   IN    std_logic;
          din                             :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En26
          dout                            :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32_En5
          );
  END COMPONENT;

  COMPONENT IncreEncoder_ip_src_Average
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          OmegaIn                         :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          NewMeasurement                  :   IN    std_logic;
          SamplingFactorInv               :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16_En15
          SamplingFactor                  :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          OmegaOut                        :   OUT   std_logic_vector(23 DOWNTO 0)  -- sfix24_En11
          );
  END COMPONENT;

  COMPONENT IncreEncoder_ip_src_Check_Direction
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          A                               :   IN    std_logic;
          B                               :   IN    std_logic;
          Dir                             :   OUT   std_logic_vector(3 DOWNTO 0)  -- sfix4
          );
  END COMPONENT;

  COMPONENT IncreEncoder_ip_src_Counter
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          Enable_ctr                      :   IN    std_logic;
          I_line                          :   IN    std_logic;
          Edge_rsvd                       :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
          Reset_1                         :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  COMPONENT IncreEncoder_ip_src_Counter_theta_ele
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          Edge_rsvd                       :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          Reset_1                         :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          );
  END COMPONENT;

  COMPONENT IncreEncoder_ip_src_Counter_theta
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          Edge_rsvd                       :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          Reset_1                         :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          );
  END COMPONENT;

  COMPONENT IncreEncoder_ip_src_omega_by_count_lines
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          Edge_rsvd                       :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          Reset1                          :   IN    std_logic;
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : IncreEncoder_ip_src_IncreEncoder_V22_tc
    USE ENTITY work.IncreEncoder_ip_src_IncreEncoder_V22_tc(rtl);

  FOR ALL : IncreEncoder_ip_src_omega_by_measure_time
    USE ENTITY work.IncreEncoder_ip_src_omega_by_measure_time(rtl);

  FOR ALL : IncreEncoder_ip_src_HDL_Reciprocal
    USE ENTITY work.IncreEncoder_ip_src_HDL_Reciprocal(rtl);

  FOR ALL : IncreEncoder_ip_src_Average
    USE ENTITY work.IncreEncoder_ip_src_Average(rtl);

  FOR ALL : IncreEncoder_ip_src_Check_Direction
    USE ENTITY work.IncreEncoder_ip_src_Check_Direction(rtl);

  FOR ALL : IncreEncoder_ip_src_Counter
    USE ENTITY work.IncreEncoder_ip_src_Counter(rtl);

  FOR ALL : IncreEncoder_ip_src_Counter_theta_ele
    USE ENTITY work.IncreEncoder_ip_src_Counter_theta_ele(rtl);

  FOR ALL : IncreEncoder_ip_src_Counter_theta
    USE ENTITY work.IncreEncoder_ip_src_Counter_theta(rtl);

  FOR ALL : IncreEncoder_ip_src_omega_by_count_lines
    USE ENTITY work.IncreEncoder_ip_src_omega_by_count_lines(rtl);

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL enb_1_100_0                      : std_logic;
  SIGNAL enb_1_50_0                       : std_logic;
  SIGNAL enb_1_100_1                      : std_logic;
  SIGNAL Logical2_out1                    : std_logic;
  SIGNAL Timer_FPGA_ms_AXI4_unsigned      : unsigned(31 DOWNTO 0);  -- ufix32_En26
  SIGNAL rd_4_reg                         : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL Logical2_out1_1                  : std_logic;
  SIGNAL Timer_FPGA_ms_AXI4_1             : unsigned(31 DOWNTO 0);  -- ufix32_En26
  SIGNAL omega_by_measure_time_out1       : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL omega_by_measure_time_out2       : std_logic;
  SIGNAL omega_by_measure_time_out1_unsigned : unsigned(31 DOWNTO 0);  -- ufix32_En26
  SIGNAL C_1_rps_1_omega_out1             : unsigned(15 DOWNTO 0);  -- ufix16_En15
  SIGNAL C_1_rps_1_omega_out1_1           : unsigned(15 DOWNTO 0);  -- ufix16_En15
  SIGNAL Mul_rps_omega_out1               : unsigned(47 DOWNTO 0);  -- ufix48_En41
  SIGNAL hold2_out1                       : unsigned(31 DOWNTO 0);  -- ufix32_En26
  SIGNAL HDL_Reciprocal_out1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL HDL_Reciprocal_out1_unsigned     : unsigned(31 DOWNTO 0);  -- ufix32_En5
  SIGNAL Data_Type_Conversion2_out1       : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL Data_Type_Conversion2_out1_1     : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL OverSamplFactorInv_AXI4_unsigned : unsigned(15 DOWNTO 0);  -- ufix16_En15
  SIGNAL OverSamplFactorInv_AXI4_1        : unsigned(15 DOWNTO 0);  -- ufix16_En15
  SIGNAL OverSamplFactor_AXI4_unsigned    : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL OverSamplFactor_AXI4_1           : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Average_out1                     : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL Average_out1_signed              : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL Check_Direction_out1             : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL Check_Direction_out1_signed      : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL hold1_out1                       : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL rd_1_reg                         : vector_of_signed4(0 TO 4);  -- sfix4 [5]
  SIGNAL Check_Direction_out1_1           : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL Mul_Direction_out1               : signed(27 DOWNTO 0);  -- sfix28_En11
  SIGNAL Mul_Direction_out1_1             : signed(27 DOWNTO 0);  -- sfix28_En11
  SIGNAL Mul_Direction_out1_2             : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL rd_8_reg                         : vector_of_signed24(0 TO 4);  -- sfix24 [5]
  SIGNAL Mul_Direction_out1_3             : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL rd_10_reg                        : vector_of_signed24(0 TO 5);  -- sfix24 [6]
  SIGNAL Average_out1_1                   : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL Product_theta_el0_deserializer_contl_cnt : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL Product_theta_el0_deserializer_contl_validOutput : std_logic;
  SIGNAL Product_theta_el0_deserializer_innerRegEn : std_logic;
  SIGNAL Product_theta_el0_deserializer_innerRegCtrolEn : std_logic;
  SIGNAL Product_theta_el0_deserializer_outBypassEn : std_logic;
  SIGNAL Product_theta_el0_deserializer_tapDelayEn : std_logic;
  SIGNAL Product_theta_el0_deserializer_tapDelayEn_1 : std_logic;
  SIGNAL counterSig                       : std_logic;  -- ufix1
  SIGNAL PI2_Inc_AXI4_unsigned            : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL PI2_Inc_AXI4_1                   : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL Inc_PerTurn_mech_2PI_AXI4_unsigned : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL Inc_PerTurn_mech_2PI_AXI4_1      : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL c0_serial_0                      : vector_of_unsigned24(0 TO 1);  -- ufix24_En24 [2]
  SIGNAL rcc_out                          : vector_of_unsigned24(0 TO 1);  -- ufix24_En24 [2]
  SIGNAL ratechange_splitcomp_out0        : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL ratechange_splitcomp_out1        : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL PI2_Inc_AXI4_2                   : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL Logical1_out1                    : std_logic;
  SIGNAL Logical1_out1_1                  : std_logic;
  SIGNAL Counter_out1                     : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL Counter_out2                     : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL Counter_theta_ele_out1           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Counter_theta_ele_out1_signed    : signed(15 DOWNTO 0);  -- int16
  SIGNAL Data_Type_Conversion1_out1       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL reset_old2_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Counter_theta_out1               : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Counter_theta_out1_signed        : signed(15 DOWNTO 0);  -- int16
  SIGNAL Data_Type_Conversion9_out1       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL reset_old5_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL c0_serial_1                      : vector_of_unsigned16(0 TO 1);  -- uint16 [2]
  SIGNAL rcc_out_1                        : vector_of_unsigned16(0 TO 1);  -- uint16 [2]
  SIGNAL ratechange_splitcomp_out0_1      : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL ratechange_splitcomp_out1_1      : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL reset_old2_out1_1                : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Product_theta_el_out1            : unsigned(39 DOWNTO 0);  -- ufix40_En24
  SIGNAL Product_theta_el0_deserializer_tapout : unsigned(39 DOWNTO 0);  -- ufix40_En24
  SIGNAL Product_theta_el0_deserializer_muxOut : vector_of_unsigned40(0 TO 1);  -- ufix40_En24 [2]
  SIGNAL c0_serialOut_0                   : vector_of_unsigned40(0 TO 1);  -- ufix40_En24 [2]
  SIGNAL Product_theta_el_out1_1          : unsigned(39 DOWNTO 0);  -- ufix40_En24
  SIGNAL Product_theta_el_out1_2          : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL reset_old4_out1                  : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL reduced_reg                      : vector_of_signed24(0 TO 8);  -- sfix24 [9]
  SIGNAL reset_old4_out1_1                : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Product_theta_mech_out1          : unsigned(39 DOWNTO 0);  -- ufix40_En24
  SIGNAL Product_theta_mech_out1_1        : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL delayMatch6_reg                  : vector_of_signed24(0 TO 9);  -- sfix24 [10]
  SIGNAL reset_old3_out1                  : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Detec_edge_out1                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL reset_old1_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL reset_old_switch1_out1           : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Constant1_out1                   : std_logic;
  SIGNAL Constant_out1                    : std_logic;
  SIGNAL reset_old_switch3_out1           : std_logic;
  SIGNAL delayMatch2_reg                  : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL reset_old_switch3_out1_1         : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL Logical1_out1_2                  : std_logic;
  SIGNAL rd_2_reg                         : vector_of_signed4(0 TO 5);  -- sfix4 [6]
  SIGNAL hold1_out1_1                     : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL omega_by_count_lines_out1        : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL omega_by_count_lines_out1_signed : signed(15 DOWNTO 0);  -- int16
  SIGNAL delayMatch9_reg                  : vector_of_signed16(0 TO 9);  -- sfix16 [10]
  SIGNAL omega_by_count_lines_out1_1      : signed(15 DOWNTO 0);  -- int16

BEGIN
  -- Speed
  -- 
  -- theta_mech
  -- 
  -- theta_el

  u_IncreEncoder_V22_tc : IncreEncoder_ip_src_IncreEncoder_V22_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              enb_1_50_0 => enb_1_50_0,
              enb_1_100_0 => enb_1_100_0,
              enb_1_100_1 => enb_1_100_1
              );

  u_omega_by_measure_time : IncreEncoder_ip_src_omega_by_measure_time
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              Edge_rsvd => Logical2_out1_1,
              T => std_logic_vector(Timer_FPGA_ms_AXI4_1),  -- ufix32_En26
              rps => omega_by_measure_time_out1,  -- ufix32_En26
              NewMeasurement => omega_by_measure_time_out2
              );

  u_HDL_Reciprocal : IncreEncoder_ip_src_HDL_Reciprocal
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              enb_1_50_0 => enb_1_50_0,
              din => std_logic_vector(hold2_out1),  -- ufix32_En26
              dout => HDL_Reciprocal_out1  -- ufix32_En5
              );

  u_Average : IncreEncoder_ip_src_Average
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              OmegaIn => std_logic_vector(Data_Type_Conversion2_out1_1),  -- sfix24_En11
              NewMeasurement => omega_by_measure_time_out2,
              SamplingFactorInv => std_logic_vector(OverSamplFactorInv_AXI4_1),  -- ufix16_En15
              SamplingFactor => std_logic_vector(OverSamplFactor_AXI4_1),  -- uint16
              OmegaOut => Average_out1  -- sfix24_En11
              );

  u_Check_Direction : IncreEncoder_ip_src_Check_Direction
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              A => A,
              B => B,
              Dir => Check_Direction_out1  -- sfix4
              );

  u_Counter : IncreEncoder_ip_src_Counter
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              Enable_ctr => Logical1_out1_1,
              I_line => I,
              Edge_rsvd => Counter_out1,  -- int8
              Reset_1 => Counter_out2  -- uint8
              );

  u_Counter_theta_ele : IncreEncoder_ip_src_Counter_theta_ele
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              Edge_rsvd => Counter_out1,  -- int8
              Reset_1 => Counter_out2,  -- uint8
              IncsPerTurn => IncrementePerTurn_elek_AXI4,  -- uint16
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              count => Counter_theta_ele_out1  -- int16
              );

  u_Counter_theta : IncreEncoder_ip_src_Counter_theta
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              Edge_rsvd => Counter_out1,  -- int8
              Reset_1 => Counter_out2,  -- uint8
              IncsPerTurn => IncPerTurn_mech_AXI4,  -- uint16
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              count => Counter_theta_out1  -- int16
              );

  u_omega_by_count_lines : IncreEncoder_ip_src_omega_by_count_lines
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              Edge_rsvd => Counter_out1,  -- int8
              Reset1 => PeriodEnd,
              IncsPerTurn => IncPerTurn_mech_AXI4,  -- uint16
              count => omega_by_count_lines_out1  -- int16
              );

  Logical2_out1 <=  NOT A;

  Timer_FPGA_ms_AXI4_unsigned <= unsigned(Timer_FPGA_ms_AXI4);

  rd_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        rd_4_reg <= (OTHERS => '0');
      ELSIF enb_1_100_0 = '1' THEN
        rd_4_reg(0) <= Logical2_out1;
        rd_4_reg(1) <= rd_4_reg(0);
      END IF;
    END IF;
  END PROCESS rd_4_process;

  Logical2_out1_1 <= rd_4_reg(1);

  rd_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Timer_FPGA_ms_AXI4_1 <= to_unsigned(0, 32);
      ELSIF enb_1_100_0 = '1' THEN
        Timer_FPGA_ms_AXI4_1 <= Timer_FPGA_ms_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS rd_5_process;


  omega_by_measure_time_out1_unsigned <= unsigned(omega_by_measure_time_out1);

  C_1_rps_1_omega_out1 <= to_unsigned(16#145F#, 16);

  rd_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        C_1_rps_1_omega_out1_1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        C_1_rps_1_omega_out1_1 <= C_1_rps_1_omega_out1;
      END IF;
    END IF;
  END PROCESS rd_3_process;


  Mul_rps_omega_out1 <= omega_by_measure_time_out1_unsigned * C_1_rps_1_omega_out1_1;

  
  hold2_out1 <= X"FFFFFFFF" WHEN Mul_rps_omega_out1(47) /= '0' ELSE
      Mul_rps_omega_out1(46 DOWNTO 15);

  HDL_Reciprocal_out1_unsigned <= unsigned(HDL_Reciprocal_out1);

  Data_Type_Conversion2_out1 <= signed(HDL_Reciprocal_out1_unsigned(17 DOWNTO 0) & '0' & '0' & '0' & '0' & '0' & '0');

  rd_11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Data_Type_Conversion2_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_100_0 = '1' THEN
        Data_Type_Conversion2_out1_1 <= Data_Type_Conversion2_out1;
      END IF;
    END IF;
  END PROCESS rd_11_process;


  OverSamplFactorInv_AXI4_unsigned <= unsigned(OverSamplFactorInv_AXI4);

  rd_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        OverSamplFactorInv_AXI4_1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        OverSamplFactorInv_AXI4_1 <= OverSamplFactorInv_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS rd_6_process;


  OverSamplFactor_AXI4_unsigned <= unsigned(OverSamplFactor_AXI4);

  rd_7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        OverSamplFactor_AXI4_1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        OverSamplFactor_AXI4_1 <= OverSamplFactor_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS rd_7_process;


  Average_out1_signed <= signed(Average_out1);

  Check_Direction_out1_signed <= signed(Check_Direction_out1);

  rd_0_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hold1_out1 <= to_signed(16#0#, 4);
      ELSIF enb_1_100_0 = '1' THEN
        hold1_out1 <= Check_Direction_out1_signed;
      END IF;
    END IF;
  END PROCESS rd_0_process;


  rd_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        rd_1_reg <= (OTHERS => to_signed(16#0#, 4));
      ELSIF enb_1_100_0 = '1' THEN
        rd_1_reg(0) <= hold1_out1;
        rd_1_reg(1 TO 4) <= rd_1_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS rd_1_process;

  Check_Direction_out1_1 <= rd_1_reg(4);

  Mul_Direction_out1 <= Average_out1_signed * Check_Direction_out1_1;

  rd_9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Mul_Direction_out1_1 <= to_signed(16#0000000#, 28);
      ELSIF enb_1_100_0 = '1' THEN
        Mul_Direction_out1_1 <= Mul_Direction_out1;
      END IF;
    END IF;
  END PROCESS rd_9_process;


  
  Mul_Direction_out1_2 <= X"7FFFFF" WHEN (Mul_Direction_out1_1(27) = '0') AND (Mul_Direction_out1_1(26 DOWNTO 23) /= "0000") ELSE
      X"800000" WHEN (Mul_Direction_out1_1(27) = '1') AND (Mul_Direction_out1_1(26 DOWNTO 23) /= "1111") ELSE
      Mul_Direction_out1_1(23 DOWNTO 0);

  rd_8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        rd_8_reg <= (OTHERS => to_signed(16#000000#, 24));
      ELSIF enb_1_100_0 = '1' THEN
        rd_8_reg(0) <= Mul_Direction_out1_2;
        rd_8_reg(1 TO 4) <= rd_8_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS rd_8_process;

  Mul_Direction_out1_3 <= rd_8_reg(4);

  omega <= std_logic_vector(Mul_Direction_out1_3);

  rd_10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        rd_10_reg <= (OTHERS => to_signed(16#000000#, 24));
      ELSIF enb_1_100_0 = '1' THEN
        rd_10_reg(0) <= Average_out1_signed;
        rd_10_reg(1 TO 5) <= rd_10_reg(0 TO 4);
      END IF;
    END IF;
  END PROCESS rd_10_process;

  Average_out1_1 <= rd_10_reg(5);

  omega_AXI4 <= std_logic_vector(Average_out1_1);

  Product_theta_el0_deserializer_contl_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Product_theta_el0_deserializer_contl_cnt <= to_unsigned(16#0#, 2);
      ELSIF enb_1_50_0 = '1' THEN
        IF Product_theta_el0_deserializer_contl_cnt = to_unsigned(16#1#, 2) THEN 
          Product_theta_el0_deserializer_contl_cnt <= to_unsigned(16#0#, 2);
        ELSE 
          Product_theta_el0_deserializer_contl_cnt <= Product_theta_el0_deserializer_contl_cnt + to_unsigned(16#1#, 2);
        END IF;
      END IF;
    END IF;
  END PROCESS Product_theta_el0_deserializer_contl_process;

  Product_theta_el0_deserializer_tapDelayEn <= hdlcoder_to_stdlogic(Product_theta_el0_deserializer_contl_cnt < to_unsigned(16#1#, 2));
  
  Product_theta_el0_deserializer_contl_validOutput <= '1' WHEN Product_theta_el0_deserializer_contl_cnt = to_unsigned(16#1#, 2) ELSE
      '0';
  
  Product_theta_el0_deserializer_innerRegEn <= '1' WHEN Product_theta_el0_deserializer_contl_validOutput = '1' ELSE
      '0';
  
  Product_theta_el0_deserializer_innerRegCtrolEn <= '1' WHEN Product_theta_el0_deserializer_contl_validOutput = '1' ELSE
      '0';
  Product_theta_el0_deserializer_outBypassEn <= '1';

  Product_theta_el0_deserializer_tapDelayEn_1 <= enb_1_50_0 AND Product_theta_el0_deserializer_tapDelayEn;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 1
  ctr_0_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        counterSig <= '0';
      ELSIF enb_1_50_0 = '1' THEN
        counterSig <=  NOT counterSig;
      END IF;
    END IF;
  END PROCESS ctr_0_1_process;


  PI2_Inc_AXI4_unsigned <= unsigned(PI2_Inc_AXI4);

  delayMatch7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        PI2_Inc_AXI4_1 <= to_unsigned(16#000000#, 24);
      ELSIF enb_1_100_0 = '1' THEN
        PI2_Inc_AXI4_1 <= PI2_Inc_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS delayMatch7_process;


  Inc_PerTurn_mech_2PI_AXI4_unsigned <= unsigned(Inc_PerTurn_mech_2PI_AXI4);

  delayMatch8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Inc_PerTurn_mech_2PI_AXI4_1 <= to_unsigned(16#000000#, 24);
      ELSIF enb_1_100_0 = '1' THEN
        Inc_PerTurn_mech_2PI_AXI4_1 <= Inc_PerTurn_mech_2PI_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS delayMatch8_process;


  c0_serial_0(0) <= PI2_Inc_AXI4_1;
  c0_serial_0(1) <= Inc_PerTurn_mech_2PI_AXI4_1;

  rcc_out <= c0_serial_0;

  ratechange_splitcomp_out0 <= rcc_out(0);

  ratechange_splitcomp_out1 <= rcc_out(1);

  
  PI2_Inc_AXI4_2 <= ratechange_splitcomp_out0 WHEN counterSig = '0' ELSE
      ratechange_splitcomp_out1;

  Logical1_out1 <= A XOR B;

  Logical1_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Logical1_out1_1 <= '0';
      ELSIF enb_1_100_0 = '1' THEN
        Logical1_out1_1 <= Logical1_out1;
      END IF;
    END IF;
  END PROCESS Logical1_out_pipe_process;


  Counter_theta_ele_out1_signed <= signed(Counter_theta_ele_out1);

  Data_Type_Conversion1_out1 <= unsigned(Counter_theta_ele_out1_signed);

  reset_old2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old2_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        reset_old2_out1 <= Data_Type_Conversion1_out1;
      END IF;
    END IF;
  END PROCESS reset_old2_process;


  Counter_theta_out1_signed <= signed(Counter_theta_out1);

  Data_Type_Conversion9_out1 <= unsigned(Counter_theta_out1_signed);

  reset_old5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old5_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        reset_old5_out1 <= Data_Type_Conversion9_out1;
      END IF;
    END IF;
  END PROCESS reset_old5_process;


  c0_serial_1(0) <= reset_old2_out1;
  c0_serial_1(1) <= reset_old5_out1;

  rcc_out_1 <= c0_serial_1;

  ratechange_splitcomp_out0_1 <= rcc_out_1(0);

  ratechange_splitcomp_out1_1 <= rcc_out_1(1);

  
  reset_old2_out1_1 <= ratechange_splitcomp_out0_1 WHEN counterSig = '0' ELSE
      ratechange_splitcomp_out1_1;

  Product_theta_el_out1 <= PI2_Inc_AXI4_2 * reset_old2_out1_1;

  Product_theta_el0_deserializer_tapDelayComp_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Product_theta_el0_deserializer_tapout <= to_unsigned(0, 40);
      ELSIF enb_1_50_0 = '1' AND Product_theta_el0_deserializer_tapDelayEn_1 = '1' THEN
        Product_theta_el0_deserializer_tapout <= Product_theta_el_out1;
      END IF;
    END IF;
  END PROCESS Product_theta_el0_deserializer_tapDelayComp_process;


  Product_theta_el0_deserializer_muxOut(0) <= Product_theta_el0_deserializer_tapout;
  Product_theta_el0_deserializer_muxOut(1) <= Product_theta_el_out1;

  Product_theta_el0_deserializer_regComp_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        c0_serialOut_0 <= (OTHERS => to_unsigned(0, 40));
      ELSIF enb_1_50_0 = '1' AND Product_theta_el0_deserializer_innerRegEn = '1' THEN
        c0_serialOut_0 <= Product_theta_el0_deserializer_muxOut;
      END IF;
    END IF;
  END PROCESS Product_theta_el0_deserializer_regComp_process;


  Product_theta_el_out1_1 <= c0_serialOut_0(0);

  Product_theta_el_out1_2 <= signed(Product_theta_el_out1_1(27 DOWNTO 4));

  reset_old4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old4_out1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_100_0 = '1' THEN
        reset_old4_out1 <= Product_theta_el_out1_2;
      END IF;
    END IF;
  END PROCESS reset_old4_process;


  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg <= (OTHERS => to_signed(16#000000#, 24));
      ELSIF enb_1_100_0 = '1' THEN
        reduced_reg(0) <= reset_old4_out1;
        reduced_reg(1 TO 8) <= reduced_reg(0 TO 7);
      END IF;
    END IF;
  END PROCESS reduced_process;

  reset_old4_out1_1 <= reduced_reg(8);

  theta_el <= std_logic_vector(reset_old4_out1_1);

  theta_el_AXI4 <= std_logic_vector(reset_old4_out1_1);

  Product_theta_mech_out1 <= c0_serialOut_0(1);

  Product_theta_mech_out1_1 <= signed(Product_theta_mech_out1(27 DOWNTO 4));

  delayMatch6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch6_reg <= (OTHERS => to_signed(16#000000#, 24));
      ELSIF enb_1_100_0 = '1' THEN
        delayMatch6_reg(0) <= Product_theta_mech_out1_1;
        delayMatch6_reg(1 TO 9) <= delayMatch6_reg(0 TO 8);
      END IF;
    END IF;
  END PROCESS delayMatch6_process;

  reset_old3_out1 <= delayMatch6_reg(9);

  theta_mech_AXI4 <= std_logic_vector(reset_old3_out1);

  
  reset_old_switch1_out1 <= reset_old1_out1 WHEN Detec_edge_out1 = to_unsigned(16#00#, 8) ELSE
      Data_Type_Conversion9_out1;

  reset_old1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old1_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        reset_old1_out1 <= reset_old_switch1_out1;
      END IF;
    END IF;
  END PROCESS reset_old1_process;


  Detec_edge_out1 <= resize(Data_Type_Conversion9_out1, 8) - resize(reset_old1_out1, 8);

  Constant1_out1 <= '0';

  Constant_out1 <= '1';

  
  reset_old_switch3_out1 <= Constant1_out1 WHEN Detec_edge_out1 = to_unsigned(16#00#, 8) ELSE
      Constant_out1;

  delayMatch2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch2_reg <= (OTHERS => '0');
      ELSIF enb_1_100_0 = '1' THEN
        delayMatch2_reg(0) <= reset_old_switch3_out1;
        delayMatch2_reg(1 TO 9) <= delayMatch2_reg(0 TO 8);
      END IF;
    END IF;
  END PROCESS delayMatch2_process;

  reset_old_switch3_out1_1 <= delayMatch2_reg(9);

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb_1_100_0 = '1' THEN
        delayMatch_reg(0) <= Logical1_out1_1;
        delayMatch_reg(1 TO 9) <= delayMatch_reg(0 TO 8);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  Logical1_out1_2 <= delayMatch_reg(9);

  rd_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        rd_2_reg <= (OTHERS => to_signed(16#0#, 4));
      ELSIF enb_1_100_0 = '1' THEN
        rd_2_reg(0) <= Check_Direction_out1_1;
        rd_2_reg(1 TO 5) <= rd_2_reg(0 TO 4);
      END IF;
    END IF;
  END PROCESS rd_2_process;

  hold1_out1_1 <= rd_2_reg(5);

  direction_AXI4 <= std_logic_vector(hold1_out1_1);

  omega_by_count_lines_out1_signed <= signed(omega_by_count_lines_out1);

  delayMatch9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch9_reg <= (OTHERS => to_signed(16#0000#, 16));
      ELSIF enb_1_100_0 = '1' THEN
        delayMatch9_reg(0) <= omega_by_count_lines_out1_signed;
        delayMatch9_reg(1 TO 9) <= delayMatch9_reg(0 TO 8);
      END IF;
    END IF;
  END PROCESS delayMatch9_process;

  omega_by_count_lines_out1_1 <= delayMatch9_reg(9);

  countPerPeriod_AXI4 <= std_logic_vector(omega_by_count_lines_out1_1);

  ce_out <= enb_1_100_1;

  edge_rsvd <= reset_old_switch3_out1_1;

  count <= Logical1_out1_2;

END rtl;

