-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\PMSM_Flux_NonLinear_FCS_FixPoint_Np1_V7\Counter_f_sw_V2_ip_src_Counter_f_sw_V2.vhd
-- Created: 2020-04-27 19:15:37
-- 
-- Generated by MATLAB 9.4 and HDL Coder 3.12
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1e-08
-- Target subsystem base rate: 1e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- switchNumb_AXI                ce_out        1e-08
-- switchNumb                    ce_out        1e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Counter_f_sw_V2_ip_src_Counter_f_sw_V2
-- Source Path: Counter_f_sw_V2
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY Counter_f_sw_V2_ip_src_Counter_f_sw_V2 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        ss_in_0                           :   IN    std_logic;
        ss_in_1                           :   IN    std_logic;
        ss_in_2                           :   IN    std_logic;
        ss_in_3                           :   IN    std_logic;
        ss_in_4                           :   IN    std_logic;
        ss_in_5                           :   IN    std_logic;
        bResetAXI                         :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        switchNumb_AXI                    :   OUT   std_logic_vector(24 DOWNTO 0);  -- ufix25
        switchNumb                        :   OUT   std_logic_vector(24 DOWNTO 0)  -- ufix25
        );
END Counter_f_sw_V2_ip_src_Counter_f_sw_V2;


ARCHITECTURE rtl OF Counter_f_sw_V2_ip_src_Counter_f_sw_V2 IS

  -- Component Declarations
  COMPONENT Counter_f_sw_V2_ip_src_Count_f_sw
    PORT( switchNumb                      :   IN    std_logic_vector(24 DOWNTO 0);  -- ufix25
          ss_v_old_0                      :   IN    std_logic;  -- boolean
          ss_v_old_1                      :   IN    std_logic;  -- boolean
          ss_v_old_2                      :   IN    std_logic;  -- boolean
          ss_v_old_3                      :   IN    std_logic;  -- boolean
          ss_v_old_4                      :   IN    std_logic;  -- boolean
          ss_v_old_5                      :   IN    std_logic;  -- boolean
          ss_v_0                          :   IN    std_logic;  -- boolean
          ss_v_1                          :   IN    std_logic;  -- boolean
          ss_v_2                          :   IN    std_logic;  -- boolean
          ss_v_3                          :   IN    std_logic;  -- boolean
          ss_v_4                          :   IN    std_logic;  -- boolean
          ss_v_5                          :   IN    std_logic;  -- boolean
          bReset                          :   IN    std_logic;  -- ufix1
          switchNumbOut                   :   OUT   std_logic_vector(24 DOWNTO 0)  -- ufix25
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Counter_f_sw_V2_ip_src_Count_f_sw
    USE ENTITY work.Counter_f_sw_V2_ip_src_Count_f_sw(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL ss_in_0_1                        : std_logic;
  SIGNAL ss_in_1_1                        : std_logic;
  SIGNAL ss_in_2_1                        : std_logic;
  SIGNAL ss_in_3_1                        : std_logic;
  SIGNAL ss_in_4_1                        : std_logic;
  SIGNAL ss_in_5_1                        : std_logic;
  SIGNAL Mux_out1                         : std_logic_vector(0 TO 5);  -- boolean [6]
  SIGNAL SS_Old_out1                      : std_logic_vector(0 TO 5);  -- boolean [6]
  SIGNAL bResetAXI_1                      : std_logic;
  SIGNAL alpha1_for_one_cycle_if_edge_recognized : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old2_out1                  : std_logic;
  SIGNAL reset_old_switch1_out1           : std_logic;
  SIGNAL Detec_edge_sub_cast              : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge_sub_cast_1            : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL dtc_out                          : std_logic;  -- ufix1
  SIGNAL Saturation_out1                  : std_logic;  -- ufix1
  SIGNAL switchNumbOut                    : std_logic_vector(24 DOWNTO 0);  -- ufix25
  SIGNAL switchNumbOut_unsigned           : unsigned(24 DOWNTO 0);  -- ufix25
  SIGNAL delay_out1                       : unsigned(24 DOWNTO 0);  -- ufix25

BEGIN
  -- To avoid unneccessary calcualtions, i divide by 12 on the ARM processor.
  -- 
  -- Over AXI, 32 Bit are received.
  -- However, only one Bit is used.
  -- 
  -- 1 for one cycle if edge recognized
  -- 
  -- Since i count now every On and Off Transition for each switch,
  -- i have to divide by 6*2 in order to get the switching frequency
  -- (after dividing by the time).
  -- 6 comes from the 6 switches
  -- 2 comes from that 1 ON-transition and 1 OFF-transition = 1 switching-cycle

  u_Count_f_sw : Counter_f_sw_V2_ip_src_Count_f_sw
    PORT MAP( switchNumb => std_logic_vector(delay_out1),  -- ufix25
              ss_v_old_0 => SS_Old_out1(0),  -- boolean
              ss_v_old_1 => SS_Old_out1(1),  -- boolean
              ss_v_old_2 => SS_Old_out1(2),  -- boolean
              ss_v_old_3 => SS_Old_out1(3),  -- boolean
              ss_v_old_4 => SS_Old_out1(4),  -- boolean
              ss_v_old_5 => SS_Old_out1(5),  -- boolean
              ss_v_0 => ss_in_0_1,  -- boolean
              ss_v_1 => ss_in_1_1,  -- boolean
              ss_v_2 => ss_in_2_1,  -- boolean
              ss_v_3 => ss_in_3_1,  -- boolean
              ss_v_4 => ss_in_4_1,  -- boolean
              ss_v_5 => ss_in_5_1,  -- boolean
              bReset => Saturation_out1,  -- ufix1
              switchNumbOut => switchNumbOut  -- ufix25
              );

  enb <= clk_enable;

  in_0_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        ss_in_0_1 <= '0';
      ELSIF enb = '1' THEN
        ss_in_0_1 <= ss_in_0;
      END IF;
    END IF;
  END PROCESS in_0_pipe_process;


  in_1_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        ss_in_1_1 <= '0';
      ELSIF enb = '1' THEN
        ss_in_1_1 <= ss_in_1;
      END IF;
    END IF;
  END PROCESS in_1_pipe_process;


  in_2_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        ss_in_2_1 <= '0';
      ELSIF enb = '1' THEN
        ss_in_2_1 <= ss_in_2;
      END IF;
    END IF;
  END PROCESS in_2_pipe_process;


  in_3_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        ss_in_3_1 <= '0';
      ELSIF enb = '1' THEN
        ss_in_3_1 <= ss_in_3;
      END IF;
    END IF;
  END PROCESS in_3_pipe_process;


  in_4_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        ss_in_4_1 <= '0';
      ELSIF enb = '1' THEN
        ss_in_4_1 <= ss_in_4;
      END IF;
    END IF;
  END PROCESS in_4_pipe_process;


  in_5_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        ss_in_5_1 <= '0';
      ELSIF enb = '1' THEN
        ss_in_5_1 <= ss_in_5;
      END IF;
    END IF;
  END PROCESS in_5_pipe_process;


  Mux_out1(0) <= ss_in_0_1;
  Mux_out1(1) <= ss_in_1_1;
  Mux_out1(2) <= ss_in_2_1;
  Mux_out1(3) <= ss_in_3_1;
  Mux_out1(4) <= ss_in_4_1;
  Mux_out1(5) <= ss_in_5_1;

  SS_Old_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        SS_Old_out1 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        SS_Old_out1 <= Mux_out1;
      END IF;
    END IF;
  END PROCESS SS_Old_process;


  in_6_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        bResetAXI_1 <= '0';
      ELSIF enb = '1' THEN
        bResetAXI_1 <= bResetAXI;
      END IF;
    END IF;
  END PROCESS in_6_pipe_process;


  
  reset_old_switch1_out1 <= reset_old2_out1 WHEN alpha1_for_one_cycle_if_edge_recognized = to_signed(16#00#, 8) ELSE
      bResetAXI_1;

  reset_old2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old2_out1 <= '0';
      ELSIF enb = '1' THEN
        reset_old2_out1 <= reset_old_switch1_out1;
      END IF;
    END IF;
  END PROCESS reset_old2_process;


  Detec_edge_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & bResetAXI_1;
  Detec_edge_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old2_out1;
  alpha1_for_one_cycle_if_edge_recognized <= Detec_edge_sub_cast - Detec_edge_sub_cast_1;

  
  dtc_out <= '1' WHEN (alpha1_for_one_cycle_if_edge_recognized(7) = '0') AND (alpha1_for_one_cycle_if_edge_recognized(6 DOWNTO 1) /= "000000") ELSE
      '0' WHEN alpha1_for_one_cycle_if_edge_recognized(7) = '1' ELSE
      alpha1_for_one_cycle_if_edge_recognized(0);

  Saturation_out1 <= dtc_out;

  switchNumbOut_unsigned <= unsigned(switchNumbOut);

  delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delay_out1 <= to_unsigned(16#0000000#, 25);
      ELSIF enb = '1' THEN
        delay_out1 <= switchNumbOut_unsigned;
      END IF;
    END IF;
  END PROCESS delay_process;


  ce_out <= clk_enable;


  switchNumb_AXI <= switchNumbOut;

  switchNumb <= switchNumbOut;

END rtl;

