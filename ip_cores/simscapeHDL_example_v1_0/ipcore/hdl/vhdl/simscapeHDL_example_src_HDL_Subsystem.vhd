-- -------------------------------------------------------------
-- 
-- File Name: /home/ts/Dokumente/simscapeHDL/hdlsrc/gmStateSpaceHDL_HalfWaveRectifier_HDL/simscapeHDL_example_src_HDL_Subsystem.vhd
-- Created: 2021-03-18 18:25:23
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 5.55556e-09
-- Target subsystem base rate: 5.55556e-09
-- Explicit user oversample request: 60x
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1e-06
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- IR                            ce_out        1e-06
-- Iout                          ce_out        1e-06
-- Vdiode                        ce_out        1e-06
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: simscapeHDL_example_src_HDL_Subsystem
-- Source Path: gmStateSpaceHDL_HalfWaveRectifier_HDL/Simscape_system/HDL Subsystem
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.simscapeHDL_example_src_HDL_Subsystem_pkg.ALL;

ENTITY simscapeHDL_example_src_HDL_Subsystem IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        Vin                               :   IN    std_logic_vector(31 DOWNTO 0);  -- single
        ce_out                            :   OUT   std_logic;
        IR                                :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        Iout                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- single
        Vdiode                            :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
        );
END simscapeHDL_example_src_HDL_Subsystem;


ARCHITECTURE rtl OF simscapeHDL_example_src_HDL_Subsystem IS

  -- Component Declarations
  COMPONENT simscapeHDL_example_src_HDL_Subsystem_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb                             :   OUT   std_logic;
          enb_1_60_0                      :   OUT   std_logic;
          enb_1_60_1                      :   OUT   std_logic;
          enb_1_180_0                     :   OUT   std_logic;
          enb_1_180_1                     :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT simscapeHDL_example_src_dot_product_1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          in1                             :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          in2                             :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          out1                            :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  COMPONENT simscapeHDL_example_src_Subsystem1
    GENERIC( Index                        : integer
             );
    PORT( In1                             :   IN    std_logic;
          In2                             :   IN    std_logic;  -- ufix1
          In3                             :   IN    std_logic;
          Out1                            :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  COMPONENT simscapeHDL_example_src_nfp_relop_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out1                        :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT simscapeHDL_example_src_Subsystem1_block
    GENERIC( Index                        : integer
             );
    PORT( In1                             :   IN    std_logic;
          In2                             :   IN    std_logic;  -- ufix1
          In3                             :   IN    std_logic;
          Out1                            :   OUT   std_logic  -- ufix1
          );
  END COMPONENT;

  COMPONENT simscapeHDL_example_src_nfp_add_single
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          nfp_in1                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_in2                         :   IN    std_logic_vector(31 DOWNTO 0);  -- single
          nfp_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- single
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : simscapeHDL_example_src_HDL_Subsystem_tc
    USE ENTITY work.simscapeHDL_example_src_HDL_Subsystem_tc(rtl);

  FOR ALL : simscapeHDL_example_src_dot_product_1
    USE ENTITY work.simscapeHDL_example_src_dot_product_1(rtl);

  FOR ALL : simscapeHDL_example_src_Subsystem1
    USE ENTITY work.simscapeHDL_example_src_Subsystem1(rtl);

  FOR ALL : simscapeHDL_example_src_nfp_relop_single
    USE ENTITY work.simscapeHDL_example_src_nfp_relop_single(rtl);

  FOR ALL : simscapeHDL_example_src_Subsystem1_block
    USE ENTITY work.simscapeHDL_example_src_Subsystem1_block(rtl);

  FOR ALL : simscapeHDL_example_src_nfp_add_single
    USE ENTITY work.simscapeHDL_example_src_nfp_add_single(rtl);

  -- Signals
  SIGNAL enb_1_60_0                       : std_logic;
  SIGNAL enb_1_180_1                      : std_logic;
  SIGNAL enb_1_180_0                      : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL enb_1_60_1                       : std_logic;
  SIGNAL configuration1                   : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Rate_Transition2_out1            : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Input_Concat_out1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Input_Concat_out1_1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay1_reg                       : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Delay1_reg_next                  : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Delay1_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay1_out1_1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL dot_product1                     : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL configuration1_1                 : vector_of_std_logic_vector32(0 TO 2);  -- ufix32 [3]
  SIGNAL Valid_Out1_out1                  : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL delayMatch_reg_next              : std_logic_vector(0 TO 2);  -- ufix1 [3]
  SIGNAL Valid_Out1_out1_1                : std_logic;
  SIGNAL Valid_Out1_out1_2                : std_logic;
  SIGNAL reduced_reg                      : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL reduced_reg_next                 : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL Valid_Out1_out1_3                : std_logic;
  SIGNAL Delay2_out1                      : std_logic;
  SIGNAL X0_out1                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay_out1                       : std_logic;
  SIGNAL Counter_Limited_out1             : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Counter_Limited_out1_1           : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Compare_To_Constant_out1         : std_logic;
  SIGNAL Bitwise_Operator_out1            : std_logic;
  SIGNAL Delay_out1_1                     : std_logic;
  SIGNAL Constant_out1                    : std_logic;  -- ufix1
  SIGNAL const_2                          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Default_Index_out1               : std_logic;  -- ufix1
  SIGNAL Mode_Vector2_out1                : std_logic;
  SIGNAL Mode_Vector1_out1                : std_logic;
  SIGNAL configuration1_2                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL configuration2                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Bias_out1                        : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Switch1_out1                     : std_logic;  -- ufix1
  SIGNAL Data_Type_Conversion_out1        : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Selector_out1                    : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Data_Type_Conversion_out1_1      : std_logic;
  SIGNAL Subsystem2_out1                  : std_logic;  -- ufix1
  SIGNAL State_Update_out1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL mode1                            : std_logic;
  SIGNAL Subsystem1_out1                  : std_logic;  -- ufix1
  SIGNAL active_configuration             : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL dot_product1_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Output_Sum_out1                  : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL State_Delay_bypass_reg           : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL State_Delay_out1                 : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch3_out1                     : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch3_out1_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay3_bypass_reg                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch3_out1_2                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Delay3_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Switch_out1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL dot_product1_2                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL nfp_out_1_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Output_Demux_out1                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch4_reg                  : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL delayMatch4_reg_next             : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Output_Demux_out1_1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL PS_Simulink_Converter1           : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL PS_Simulink_Converter1_1         : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL dot_product2                     : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL dot_product2_1                   : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL nfp_out_2_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Output_Demux_out2                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch5_reg                  : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL delayMatch5_reg_next             : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Output_Demux_out2_1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL PS_Simulink_Converter            : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL PS_Simulink_Converter_1          : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL const0                           : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL dot_product3                     : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL nfp_out_3_1                      : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL Output_Demux_out3                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL delayMatch6_reg                  : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL delayMatch6_reg_next             : vector_of_std_logic_vector32(0 TO 1);  -- ufix32 [2]
  SIGNAL Output_Demux_out3_1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL PS_Simulink_Converter2           : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL PS_Simulink_Converter2_1         : std_logic_vector(31 DOWNTO 0);  -- ufix32

BEGIN
  u_HDL_Subsystem_tc : simscapeHDL_example_src_HDL_Subsystem_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              enb => enb,
              enb_1_60_0 => enb_1_60_0,
              enb_1_60_1 => enb_1_60_1,
              enb_1_180_0 => enb_1_180_0,
              enb_1_180_1 => enb_1_180_1
              );

  u_dot_product_1 : simscapeHDL_example_src_dot_product_1
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              in1 => configuration1(0),  -- single
              in2 => Delay1_out1_1,  -- single
              out1 => dot_product1  -- single
              );

  u_Subsystem2 : simscapeHDL_example_src_Subsystem1
    GENERIC MAP( Index => 1
                 )
    PORT MAP( In1 => Data_Type_Conversion_out1_1,
              In2 => Default_Index_out1,  -- ufix1
              In3 => Mode_Vector2_out1,
              Out1 => Subsystem2_out1  -- ufix1
              );

  u_nfp_relop_comp : simscapeHDL_example_src_nfp_relop_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => State_Update_out1,  -- single
              nfp_in2 => const_2,  -- single
              nfp_out1 => mode1
              );

  u_Subsystem1 : simscapeHDL_example_src_Subsystem1_block
    GENERIC MAP( Index => 0
                 )
    PORT MAP( In1 => Data_Type_Conversion_out1_1,
              In2 => Subsystem2_out1,  -- ufix1
              In3 => Mode_Vector1_out1,
              Out1 => Subsystem1_out1  -- ufix1
              );

  u_dot_product_1_1 : simscapeHDL_example_src_dot_product_1
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              in1 => active_configuration,  -- single
              in2 => Rate_Transition2_out1,  -- single
              out1 => dot_product1_1  -- single
              );

  u_nfp_add_comp : simscapeHDL_example_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => dot_product1_1,  -- single
              nfp_in2 => Selector_out1,  -- single
              nfp_out => Output_Sum_out1  -- single
              );

  u_dot_product_1_2 : simscapeHDL_example_src_dot_product_1
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              in1 => configuration1_1(0),  -- single
              in2 => Switch_out1,  -- single
              out1 => dot_product1_2  -- single
              );

  u_nfp_add_comp_1 : simscapeHDL_example_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => dot_product1,  -- single
              nfp_in2 => dot_product1_2,  -- single
              nfp_out => nfp_out_1_1  -- single
              );

  u_dot_product_1_3 : simscapeHDL_example_src_dot_product_1
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              in1 => configuration1(1),  -- single
              in2 => Delay1_out1_1,  -- single
              out1 => dot_product2  -- single
              );

  u_dot_product_1_4 : simscapeHDL_example_src_dot_product_1
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              in1 => configuration1_1(1),  -- single
              in2 => Switch_out1,  -- single
              out1 => dot_product2_1  -- single
              );

  u_nfp_add_comp_2 : simscapeHDL_example_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => dot_product2,  -- single
              nfp_in2 => dot_product2_1,  -- single
              nfp_out => nfp_out_2_1  -- single
              );

  u_dot_product_1_5 : simscapeHDL_example_src_dot_product_1
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              in1 => configuration1_1(2),  -- single
              in2 => Switch_out1,  -- single
              out1 => dot_product3  -- single
              );

  u_nfp_add_comp_3 : simscapeHDL_example_src_nfp_add_single
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              nfp_in1 => const0,  -- single
              nfp_in2 => dot_product3,  -- single
              nfp_out => nfp_out_3_1  -- single
              );

  configuration1(0) <= X"3f800000";
  configuration1(1) <= X"3f800000";

  Rate_Transition2_out1 <= Vin;

  delayMatch2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Input_Concat_out1 <= X"00000000";
      ELSIF enb = '1' THEN
        Input_Concat_out1 <= Rate_Transition2_out1;
      END IF;
    END IF;
  END PROCESS delayMatch2_process;


  Delay11_output_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Input_Concat_out1_1 <= X"00000000";
      ELSIF enb_1_60_1 = '1' THEN
        Input_Concat_out1_1 <= Input_Concat_out1;
      END IF;
    END IF;
  END PROCESS Delay11_output_process;


  Delay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay1_reg(0) <= X"00000000";
        Delay1_reg(1) <= X"00000000";
      ELSIF enb_1_60_0 = '1' THEN
        Delay1_reg(0) <= Delay1_reg_next(0);
        Delay1_reg(1) <= Delay1_reg_next(1);
      END IF;
    END IF;
  END PROCESS Delay1_process;

  Delay1_out1 <= Delay1_reg(1);
  Delay1_reg_next(0) <= Input_Concat_out1_1;
  Delay1_reg_next(1) <= Delay1_reg(0);

  Delay1_out1_1 <= Delay1_out1;

  configuration1_1(0) <= X"bf800000";
  configuration1_1(1) <= X"bf800000";
  configuration1_1(2) <= X"3f800000";

  Valid_Out1_out1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch_reg(0) <= '0';
        delayMatch_reg(1) <= '0';
        delayMatch_reg(2) <= '0';
      ELSIF enb_1_60_0 = '1' THEN
        delayMatch_reg(0) <= delayMatch_reg_next(0);
        delayMatch_reg(1) <= delayMatch_reg_next(1);
        delayMatch_reg(2) <= delayMatch_reg_next(2);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  Valid_Out1_out1_1 <= delayMatch_reg(2);
  delayMatch_reg_next(0) <= Valid_Out1_out1;
  delayMatch_reg_next(1) <= delayMatch_reg(0);
  delayMatch_reg_next(2) <= delayMatch_reg(1);

  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Valid_Out1_out1_2 <= '0';
      ELSIF enb_1_60_0 = '1' THEN
        Valid_Out1_out1_2 <= Valid_Out1_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_process;


  reduced_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg(0) <= '0';
        reduced_reg(1) <= '0';
      ELSIF enb_1_60_0 = '1' THEN
        reduced_reg(0) <= reduced_reg_next(0);
        reduced_reg(1) <= reduced_reg_next(1);
      END IF;
    END IF;
  END PROCESS reduced_1_process;

  Valid_Out1_out1_3 <= reduced_reg(1);
  reduced_reg_next(0) <= Valid_Out1_out1_2;
  reduced_reg_next(1) <= reduced_reg(0);

  Delay2_out1 <= Valid_Out1_out1_3;

  X0_out1 <= X"00000000";

  Delay_out1 <= Valid_Out1_out1_2;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 2
  Counter_Limited_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Counter_Limited_out1 <= to_unsigned(16#00#, 8);
      ELSIF enb_1_60_0 = '1' THEN
        IF Counter_Limited_out1 >= to_unsigned(16#02#, 8) THEN 
          Counter_Limited_out1 <= to_unsigned(16#00#, 8);
        ELSE 
          Counter_Limited_out1 <= Counter_Limited_out1 + to_unsigned(16#01#, 8);
        END IF;
      END IF;
    END IF;
  END PROCESS Counter_Limited_process;


  Counter_Limited_out1_1 <= Counter_Limited_out1;

  
  Compare_To_Constant_out1 <= '1' WHEN Counter_Limited_out1_1 = to_unsigned(16#00#, 8) ELSE
      '0';

  Bitwise_Operator_out1 <= Delay_out1 AND Compare_To_Constant_out1;

  Delay_out1_1 <= Valid_Out1_out1_2;

  Constant_out1 <= '0';

  const_2 <= X"3f800000";

  Default_Index_out1 <= '0';

  Mode_Vector2_out1 <= '1';

  Mode_Vector1_out1 <= '0';

  configuration1_2 <= X"3f800000";

  configuration2 <= X"3e6c4ec5";

  Bias_out1(0) <= X"00000000";
  Bias_out1(1) <= X"3f44ec4f";

  Data_Type_Conversion_out1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & Switch1_out1;

  
  Selector_out1 <= Bias_out1(0) WHEN Data_Type_Conversion_out1 = to_unsigned(0, 32) ELSE
      Bias_out1(1);

  
  Data_Type_Conversion_out1_1 <= '1' WHEN mode1 /= '0' ELSE
      '0';

  
  Switch1_out1 <= Constant_out1 WHEN Delay_out1_1 = '0' ELSE
      Subsystem1_out1;

  
  active_configuration <= configuration1_2 WHEN Switch1_out1 = '0' ELSE
      configuration2;

  State_Delay_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        State_Delay_bypass_reg <= X"00000000";
      ELSIF enb_1_60_1 = '1' THEN
        State_Delay_bypass_reg <= Output_Sum_out1;
      END IF;
    END IF;
  END PROCESS State_Delay_bypass_process;

  
  State_Update_out1 <= Output_Sum_out1 WHEN enb_1_60_1 = '1' ELSE
      State_Delay_bypass_reg;

  State_Delay_out1 <= State_Update_out1;

  delayMatch3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch3_out1_1 <= X"00000000";
      ELSIF enb = '1' THEN
        Switch3_out1_1 <= Switch3_out1;
      END IF;
    END IF;
  END PROCESS delayMatch3_process;


  Delay3_bypass_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_bypass_reg <= X"00000000";
      ELSIF enb_1_60_1 = '1' THEN
        Delay3_bypass_reg <= Switch3_out1_1;
      END IF;
    END IF;
  END PROCESS Delay3_bypass_process;

  
  Switch3_out1_2 <= Switch3_out1_1 WHEN enb_1_60_1 = '1' ELSE
      Delay3_bypass_reg;

  Delay3_out1 <= Switch3_out1_2;

  
  Switch3_out1 <= Delay3_out1 WHEN Bitwise_Operator_out1 = '0' ELSE
      State_Delay_out1;

  
  Switch_out1 <= X0_out1 WHEN Delay2_out1 = '0' ELSE
      Switch3_out1;

  Rate_Transition31_output_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Output_Demux_out1 <= X"00000000";
      ELSIF enb_1_60_1 = '1' THEN
        Output_Demux_out1 <= nfp_out_1_1;
      END IF;
    END IF;
  END PROCESS Rate_Transition31_output_process;


  delayMatch4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch4_reg(0) <= X"00000000";
        delayMatch4_reg(1) <= X"00000000";
      ELSIF enb_1_60_0 = '1' THEN
        delayMatch4_reg(0) <= delayMatch4_reg_next(0);
        delayMatch4_reg(1) <= delayMatch4_reg_next(1);
      END IF;
    END IF;
  END PROCESS delayMatch4_process;

  Output_Demux_out1_1 <= delayMatch4_reg(1);
  delayMatch4_reg_next(0) <= Output_Demux_out1;
  delayMatch4_reg_next(1) <= delayMatch4_reg(0);

  Rate_Transition3_output_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        PS_Simulink_Converter1 <= X"00000000";
      ELSIF enb_1_180_1 = '1' THEN
        PS_Simulink_Converter1 <= Output_Demux_out1_1;
      END IF;
    END IF;
  END PROCESS Rate_Transition3_output_process;


  PipelineRegister_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        PS_Simulink_Converter1_1 <= X"00000000";
      ELSIF enb_1_180_0 = '1' THEN
        PS_Simulink_Converter1_1 <= PS_Simulink_Converter1;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  IR <= PS_Simulink_Converter1_1;

  Rate_Transition41_output_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Output_Demux_out2 <= X"00000000";
      ELSIF enb_1_60_1 = '1' THEN
        Output_Demux_out2 <= nfp_out_2_1;
      END IF;
    END IF;
  END PROCESS Rate_Transition41_output_process;


  delayMatch5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch5_reg(0) <= X"00000000";
        delayMatch5_reg(1) <= X"00000000";
      ELSIF enb_1_60_0 = '1' THEN
        delayMatch5_reg(0) <= delayMatch5_reg_next(0);
        delayMatch5_reg(1) <= delayMatch5_reg_next(1);
      END IF;
    END IF;
  END PROCESS delayMatch5_process;

  Output_Demux_out2_1 <= delayMatch5_reg(1);
  delayMatch5_reg_next(0) <= Output_Demux_out2;
  delayMatch5_reg_next(1) <= delayMatch5_reg(0);

  Rate_Transition4_output_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        PS_Simulink_Converter <= X"00000000";
      ELSIF enb_1_180_1 = '1' THEN
        PS_Simulink_Converter <= Output_Demux_out2_1;
      END IF;
    END IF;
  END PROCESS Rate_Transition4_output_process;


  PipelineRegister1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        PS_Simulink_Converter_1 <= X"00000000";
      ELSIF enb_1_180_0 = '1' THEN
        PS_Simulink_Converter_1 <= PS_Simulink_Converter;
      END IF;
    END IF;
  END PROCESS PipelineRegister1_process;


  Iout <= PS_Simulink_Converter_1;

  const0 <= X"00000000";

  Rate_Transition51_output_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Output_Demux_out3 <= X"00000000";
      ELSIF enb_1_60_1 = '1' THEN
        Output_Demux_out3 <= nfp_out_3_1;
      END IF;
    END IF;
  END PROCESS Rate_Transition51_output_process;


  delayMatch6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch6_reg(0) <= X"00000000";
        delayMatch6_reg(1) <= X"00000000";
      ELSIF enb_1_60_0 = '1' THEN
        delayMatch6_reg(0) <= delayMatch6_reg_next(0);
        delayMatch6_reg(1) <= delayMatch6_reg_next(1);
      END IF;
    END IF;
  END PROCESS delayMatch6_process;

  Output_Demux_out3_1 <= delayMatch6_reg(1);
  delayMatch6_reg_next(0) <= Output_Demux_out3;
  delayMatch6_reg_next(1) <= delayMatch6_reg(0);

  Rate_Transition5_output_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        PS_Simulink_Converter2 <= X"00000000";
      ELSIF enb_1_180_1 = '1' THEN
        PS_Simulink_Converter2 <= Output_Demux_out3_1;
      END IF;
    END IF;
  END PROCESS Rate_Transition5_output_process;


  PipelineRegister2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        PS_Simulink_Converter2_1 <= X"00000000";
      ELSIF enb_1_180_0 = '1' THEN
        PS_Simulink_Converter2_1 <= PS_Simulink_Converter2;
      END IF;
    END IF;
  END PROCESS PipelineRegister2_process;


  Vdiode <= PS_Simulink_Converter2_1;

  ce_out <= enb_1_180_1;

END rtl;

