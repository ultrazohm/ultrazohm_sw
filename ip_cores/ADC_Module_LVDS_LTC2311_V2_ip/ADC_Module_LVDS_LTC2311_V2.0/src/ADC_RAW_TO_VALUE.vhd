-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\ADC_RAW_TO_VALUE\ADC_RAW_TO_VALUE.vhd
-- Created: 2019-08-12 16:34:02
-- 
-- Generated by MATLAB 9.4 and HDL Coder 3.12
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1e-07
-- Target subsystem base rate: 1e-07
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1e-07
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- CALC_VALUE                    ce_out        1e-07
-- CALC_VALUE_VALID              ce_out        1e-07
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ADC_RAW_TO_VALUE
-- Source Path: ADC_RAW_TO_VALUE/ADC_RAW_TO_VALUE
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ADC_RAW_TO_VALUE_pkg.ALL;

ENTITY ADC_RAW_TO_VALUE IS
  generic( ADC_SET_USER_OFFSET : boolean := false --SW:If False (0), than the flag uses the measured value as offset. If True (1), than the flag uses the falue in ADC_USER_OFFSET.																																				 
);
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        ADC_SET_OFFSET                    :   IN    std_logic;
        ADC_IN                            :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
        ADC_DATA_VALID                    :   IN    std_logic;
     --   ADC_SET_USER_OFFSET               :   IN    std_logic;
        ADC_USER_OFFSET                   :   IN    std_logic_vector(31 DOWNTO 0);  -- int32
        CONVERSION_RATE_ADC               :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En32
        ce_out                            :   OUT   std_logic;
        CALC_VALUE                        :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        CALC_VALUE_VALID                  :   OUT   std_logic
        );
END ADC_RAW_TO_VALUE;


ARCHITECTURE rtl OF ADC_RAW_TO_VALUE IS

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL DelayFlagValid_reg               : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL DelayFlagValid_out1              : std_logic;
  SIGNAL reduced_reg                      : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL DelayFlagValid_out1_1            : std_logic;
  SIGNAL ADC_IN_signed                    : signed(15 DOWNTO 0);  -- int16
  SIGNAL AskValidOffset_out1              : std_logic;
  SIGNAL ADC_USER_OFFSET_signed           : signed(31 DOWNTO 0);  -- int32
  SIGNAL Data_Type_Offset_out1            : signed(15 DOWNTO 0);  -- int16
  SIGNAL SwitchUserOffset_out1            : signed(15 DOWNTO 0);  -- int16
  SIGNAL SwitchSetOffset_out1             : signed(15 DOWNTO 0);  -- int16
  SIGNAL DelayOffset_out1                 : signed(15 DOWNTO 0);  -- int16
  SIGNAL AddOffset_out1                   : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL AddOffset_out1_1                 : signed(17 DOWNTO 0);  -- sfix18
  SIGNAL CONVERSION_RATE_ADC_signed       : signed(31 DOWNTO 0);  -- sfix32_En32
  SIGNAL Data_Type_Rate_out1              : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL Data_Type_Rate_out1_1            : signed(17 DOWNTO 0);  -- sfix18_En17
  SIGNAL ProductConv_mul_temp             : signed(35 DOWNTO 0);  -- sfix36_En17
  SIGNAL ProductConv_out1                 : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL PipelineRegister_reg             : vector_of_signed18(0 TO 1);  -- sfix18 [2]
  SIGNAL ProductConv_out1_1               : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL SwitchNewValue_out1              : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay4_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11

BEGIN
  enb <= clk_enable;

  DelayFlagValid_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
      --  DelayFlagValid_reg <= (OTHERS => '0');  --SW:Do not include this reset!
      ELSIF enb = '1' THEN
        DelayFlagValid_reg(0) <= ADC_DATA_VALID;
        DelayFlagValid_reg(1) <= DelayFlagValid_reg(0);
      END IF;
    END IF;
  END PROCESS DelayFlagValid_process;

  DelayFlagValid_out1 <= DelayFlagValid_reg(1);

  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
      --  reduced_reg <= (OTHERS => '0');  --SW:Do not include this reset!
      ELSIF enb = '1' THEN
        reduced_reg(0) <= DelayFlagValid_out1;
        reduced_reg(1) <= reduced_reg(0);
      END IF;
    END IF;
  END PROCESS reduced_process;

  DelayFlagValid_out1_1 <= reduced_reg(1);

  ADC_IN_signed <= signed(ADC_IN);

  AskValidOffset_out1 <= ADC_SET_OFFSET AND ADC_DATA_VALID;

  ADC_USER_OFFSET_signed <= signed(ADC_USER_OFFSET);

  Data_Type_Offset_out1 <= ADC_USER_OFFSET_signed(15 DOWNTO 0);

  
  SwitchUserOffset_out1 <= ADC_IN_signed WHEN not(ADC_SET_USER_OFFSET) ELSE   --SW Changed from logic to bool
      Data_Type_Offset_out1;

  DelayOffset_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
     --   DelayOffset_out1 <= to_signed(16#0000#, 16);  --SW:Do not include this reset!
      ELSIF enb = '1' THEN
        DelayOffset_out1 <= SwitchSetOffset_out1;
      END IF;
    END IF;
  END PROCESS DelayOffset_process;


  
  SwitchSetOffset_out1 <= DelayOffset_out1 WHEN AskValidOffset_out1 = '0' ELSE
      SwitchUserOffset_out1;

  AddOffset_out1 <= resize(ADC_IN_signed, 18) - resize(SwitchSetOffset_out1, 18);

  HwModeRegister_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
     --   AddOffset_out1_1 <= to_signed(16#00000#, 18);  --SW:Do not include this reset!
      ELSIF enb = '1' THEN
        AddOffset_out1_1 <= AddOffset_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister_process;


  CONVERSION_RATE_ADC_signed <= signed(CONVERSION_RATE_ADC);

  Data_Type_Rate_out1 <= resize(CONVERSION_RATE_ADC_signed(31 DOWNTO 15), 18);

  HwModeRegister1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Data_Type_Rate_out1_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        Data_Type_Rate_out1_1 <= Data_Type_Rate_out1;
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;


  ProductConv_mul_temp <= AddOffset_out1_1 * Data_Type_Rate_out1_1;
  ProductConv_out1 <= ProductConv_mul_temp(23 DOWNTO 6);

  PipelineRegister_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
   --     PipelineRegister_reg <= (OTHERS => to_signed(16#00000#, 18)); --SW:Do not include this reset!
      ELSIF enb = '1' THEN
        PipelineRegister_reg(0) <= ProductConv_out1;
        PipelineRegister_reg(1) <= PipelineRegister_reg(0);
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;

  ProductConv_out1_1 <= PipelineRegister_reg(1);

  Delay4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
    --    Delay4_out1 <= to_signed(16#00000#, 18); --SW:Do not include this reset!
      ELSIF enb = '1' THEN
        Delay4_out1 <= SwitchNewValue_out1;
      END IF;
    END IF;
  END PROCESS Delay4_process;


  
  SwitchNewValue_out1 <= Delay4_out1 WHEN DelayFlagValid_out1_1 = '0' ELSE
      ProductConv_out1_1;

  CALC_VALUE <= std_logic_vector(SwitchNewValue_out1);

  ce_out <= clk_enable;

  CALC_VALUE_VALID <= DelayFlagValid_out1_1;

END rtl;

