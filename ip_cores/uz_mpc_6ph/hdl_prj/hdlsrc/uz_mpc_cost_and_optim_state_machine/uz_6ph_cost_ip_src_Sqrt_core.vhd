-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\uz_mpc_cost_and_optim_state_machine\uz_6ph_cost_ip_src_Sqrt_core.vhd
-- Created: 2022-09-20 09:58:30
-- 
-- Generated by MATLAB 9.10 and HDL Coder 3.18
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: uz_6ph_cost_ip_src_Sqrt_core
-- Source Path: uz_mpc_cost_and_optim_state_machine/uz_6ph_mpc_costs_and_optimization/Sqrt/Sqrt_core
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY uz_6ph_cost_ip_src_Sqrt_core IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_3_1_0                         :   IN    std_logic;
        xin                               :   IN    std_logic_vector(53 DOWNTO 0);  -- sfix54_En49
        ain                               :   IN    std_logic_vector(27 DOWNTO 0);  -- ufix28_En28
        sel                               :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        xout                              :   OUT   std_logic_vector(53 DOWNTO 0);  -- sfix54_En49
        aout                              :   OUT   std_logic_vector(27 DOWNTO 0)  -- ufix28_En28
        );
END uz_6ph_cost_ip_src_Sqrt_core;


ARCHITECTURE rtl OF uz_6ph_cost_ip_src_Sqrt_core IS

  -- Signals
  SIGNAL sel_unsigned                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL ain_unsigned                     : unsigned(27 DOWNTO 0);  -- ufix28_En28
  SIGNAL amul                             : signed(52 DOWNTO 0);  -- sfix53_En49
  SIGNAL const3                           : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL xin_signed                       : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL delayout                         : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL subout                           : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL shiftout                         : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL shiftmul                         : signed(52 DOWNTO 0);  -- sfix53_En49
  SIGNAL mulout                           : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL delaymul                         : signed(52 DOWNTO 0);  -- sfix53_En49
  SIGNAL muxout                           : signed(52 DOWNTO 0);  -- sfix53_En49
  SIGNAL mul_mul_temp                     : signed(106 DOWNTO 0);  -- sfix107_En98
  SIGNAL xout_tmp                         : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL aout_tmp                         : unsigned(27 DOWNTO 0);  -- ufix28_En28

BEGIN
  -- Iteration Core of the RecipSqrt Implementation using Newton Method

  sel_unsigned <= unsigned(sel);

  ain_unsigned <= unsigned(ain);

  amul <= signed(resize(ain_unsigned & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 53));

  const3 <= signed'("000110000000000000000000000000000000000000000000000000");

  xin_signed <= signed(xin);

  subout <= const3 - delayout;

  shiftout <= SHIFT_RIGHT(subout, 1);

  shiftmul <= shiftout(52 DOWNTO 0);

  reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayout <= to_signed(0, 54);
      ELSIF enb_3_1_0 = '1' THEN
        delayout <= mulout;
      END IF;
    END IF;
  END PROCESS reg_process;


  delaymul <= delayout(52 DOWNTO 0);

  
  muxout <= amul WHEN sel_unsigned = to_unsigned(16#0#, 2) ELSE
      delaymul WHEN sel_unsigned = to_unsigned(16#1#, 2) ELSE
      shiftmul;

  mul_mul_temp <= muxout * xin_signed;
  mulout <= mul_mul_temp(102 DOWNTO 49);

  xout_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        xout_tmp <= to_signed(0, 54);
      ELSIF enb = '1' THEN
        xout_tmp <= mulout;
      END IF;
    END IF;
  END PROCESS xout_reg_process;


  xout <= std_logic_vector(xout_tmp);

  aout_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        aout_tmp <= to_unsigned(16#0000000#, 28);
      ELSIF enb = '1' THEN
        aout_tmp <= ain_unsigned;
      END IF;
    END IF;
  END PROCESS aout_reg_process;


  aout <= std_logic_vector(aout_tmp);

END rtl;

