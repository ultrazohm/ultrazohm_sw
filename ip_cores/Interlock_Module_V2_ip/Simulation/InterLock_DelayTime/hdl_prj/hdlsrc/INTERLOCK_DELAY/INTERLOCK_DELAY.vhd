-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\INTERLOCK_DELAY\INTERLOCK_DELAY.vhd
-- Created: 2017-11-08 17:54:18
-- 
-- Generated by MATLAB 9.0 and HDL Coder 3.8
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 0.2
-- Target subsystem base rate: 0.2
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        0.2
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- Switch_S0_OUT                 ce_out        0.2
-- Switch_S1_OUT                 ce_out        0.2
-- Switch_S2_OUT                 ce_out        0.2
-- Switch_S3_OUT                 ce_out        0.2
-- Switch_S4_OUT                 ce_out        0.2
-- Switch_S5_OUT                 ce_out        0.2
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: INTERLOCK_DELAY
-- Source Path: INTERLOCK_DELAY
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY INTERLOCK_DELAY IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        Switch_S0_IN                      :   IN    std_logic;
        Switch_S1_IN                      :   IN    std_logic;
        Switch_S2_IN                      :   IN    std_logic;
        Switch_S3_IN                      :   IN    std_logic;
        Switch_S4_IN                      :   IN    std_logic;
        Switch_S5_IN                      :   IN    std_logic;
        Enable_Gate                       :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        Switch_S0_OUT                     :   OUT   std_logic;
        Switch_S1_OUT                     :   OUT   std_logic;
        Switch_S2_OUT                     :   OUT   std_logic;
        Switch_S3_OUT                     :   OUT   std_logic;
        Switch_S4_OUT                     :   OUT   std_logic;
        Switch_S5_OUT                     :   OUT   std_logic
        );
END INTERLOCK_DELAY;


ARCHITECTURE rtl OF INTERLOCK_DELAY IS

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL ShortCircuit1_out1               : std_logic;
  SIGNAL ShortCircuit2_out1               : std_logic;
  SIGNAL ShortCircuit3_out1               : std_logic;
  SIGNAL ShortCircuit4_out1               : std_logic;
  SIGNAL ShortCircuit5_out1               : std_logic;
  SIGNAL ShortCircuit6_out1               : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL alpha1_for_one_cycle_if_edge_recognized : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old1_out1                  : std_logic;
  SIGNAL reset_old_switch1_out1           : std_logic;
  SIGNAL Detec_edge_sub_cast              : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge_sub_cast_1            : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Compare_To_Zero_out1             : std_logic;
  SIGNAL Delay0_reg                       : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL Delay0_out1                      : std_logic;
  SIGNAL alpha1_for_one_cycle_if_edge_recognized_1 : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old2_out1                  : std_logic;
  SIGNAL reset_old_switch2_out1           : std_logic;
  SIGNAL Detec_edge1_sub_cast             : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge1_sub_cast_1           : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Compare_To_Zero1_out1            : std_logic;
  SIGNAL Delay1_reg                       : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL Delay1_out1                      : std_logic;
  SIGNAL alpha1_for_one_cycle_if_edge_recognized_2 : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old3_out1                  : std_logic;
  SIGNAL reset_old_switch3_out1           : std_logic;
  SIGNAL Detec_edge2_sub_cast             : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge2_sub_cast_1           : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Compare_To_Zero2_out1            : std_logic;
  SIGNAL Delay2_reg                       : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL Delay2_out1                      : std_logic;
  SIGNAL alpha1_for_one_cycle_if_edge_recognized_3 : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old4_out1                  : std_logic;
  SIGNAL reset_old_switch4_out1           : std_logic;
  SIGNAL Detec_edge3_sub_cast             : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge3_sub_cast_1           : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Compare_To_Zero3_out1            : std_logic;
  SIGNAL Delay3_reg                       : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL Delay3_out1                      : std_logic;
  SIGNAL alpha1_for_one_cycle_if_edge_recognized_4 : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old5_out1                  : std_logic;
  SIGNAL reset_old_switch5_out1           : std_logic;
  SIGNAL Detec_edge4_sub_cast             : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge4_sub_cast_1           : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Compare_To_Zero4_out1            : std_logic;
  SIGNAL Delay4_reg                       : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL Delay4_out1                      : std_logic;
  SIGNAL alpha1_for_one_cycle_if_edge_recognized_5 : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old6_out1                  : std_logic;
  SIGNAL reset_old_switch6_out1           : std_logic;
  SIGNAL Detec_edge5_sub_cast             : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge5_sub_cast_1           : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Compare_To_Zero5_out1            : std_logic;
  SIGNAL Delay5_reg                       : std_logic_vector(0 TO 9);  -- ufix1 [10]
  SIGNAL Delay5_out1                      : std_logic;
  SIGNAL Constant13_out1                  : std_logic_vector(0 TO 5);  -- boolean [6]
  SIGNAL Logical0_out1                    : std_logic;
  SIGNAL CompareToZero0_out1              : std_logic;
  SIGNAL Logical1_out1                    : std_logic;
  SIGNAL CompareToZero1_out1              : std_logic;
  SIGNAL Logical2_out1                    : std_logic;
  SIGNAL CompareToZero2_out1              : std_logic;
  SIGNAL Logical3_out1                    : std_logic;
  SIGNAL CompareToZero3_out1              : std_logic;
  SIGNAL Logical4_out1                    : std_logic;
  SIGNAL CompareToZero4_out1              : std_logic;
  SIGNAL Logical5_out1                    : std_logic;
  SIGNAL CompareToZero5_out1              : std_logic;
  SIGNAL Mux2_out1                        : std_logic_vector(0 TO 5);  -- boolean [6]
  SIGNAL ShortCircuitProtection_out1      : std_logic_vector(0 TO 5);  -- boolean [6]
  SIGNAL INVERSE_BOTTOMSWITCH_out1        : std_logic;
  SIGNAL switch_compare_1_1               : std_logic;
  SIGNAL ShortCircuitProtection_out1_1    : std_logic;
  SIGNAL Inverse_BottomSwitch1_out1       : std_logic;
  SIGNAL ShortCircuitProtection1_out1     : std_logic;
  SIGNAL switch_compare_1_2               : std_logic;
  SIGNAL ShortCircuitProtection_out1_3    : std_logic;
  SIGNAL Inverse_BottomSwitch2_out1       : std_logic;
  SIGNAL ShortCircuitProtection2_out1     : std_logic;
  SIGNAL switch_compare_1_3               : std_logic;
  SIGNAL ShortCircuitProtection_out1_5    : std_logic;
  SIGNAL Inverse_BottomSwitch3_out1       : std_logic;
  SIGNAL ShortCircuitProtection3_out1     : std_logic;

BEGIN
  -- Author: Sebastian Wendel
  -- Date: 22.07.2017
  -- Description:
  -- InterLock times and Short circuit protection
  -- Da Falling-edge nichht HDL-Generiert werden kann, wurde Workaround mir separatem Block gemacht
  -- Default Deadtime = 10 Clock cycles
  -- 
  -- 0V Default
  -- 
  -- 1 for one cycle if falling edge recognized
  -- 
  -- 1 for one cycle if falling edge recognized
  -- 
  -- 1 for one cycle if falling edge recognized
  -- 
  -- 1 for one cycle if falling edge recognized
  -- 
  -- 1 for one cycle if falling edge recognized
  -- 
  -- 1 for one cycle if falling edge recognized

  ShortCircuit1_out1 <= Switch_S0_IN AND Switch_S1_IN;

  ShortCircuit2_out1 <= Switch_S2_IN AND Switch_S3_IN;

  ShortCircuit3_out1 <= Switch_S4_IN AND Switch_S5_IN;

  ShortCircuit4_out1 <= ShortCircuit3_out1 OR (ShortCircuit1_out1 OR ShortCircuit2_out1);

  ShortCircuit5_out1 <=  NOT ShortCircuit4_out1;

  ShortCircuit6_out1 <= Enable_Gate AND ShortCircuit5_out1;

  
  switch_compare_1 <= '1' WHEN ShortCircuit6_out1 = '1' ELSE
      '0';

  enb <= clk_enable;

  
  reset_old_switch1_out1 <= reset_old1_out1 WHEN alpha1_for_one_cycle_if_edge_recognized = to_signed(16#00#, 8) ELSE
      Switch_S0_IN;

  reset_old1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reset_old1_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        reset_old1_out1 <= reset_old_switch1_out1;
      END IF;
    END IF;
  END PROCESS reset_old1_process;


  Detec_edge_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old1_out1;
  Detec_edge_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & Switch_S0_IN;
  alpha1_for_one_cycle_if_edge_recognized <= Detec_edge_sub_cast - Detec_edge_sub_cast_1;

  
  Compare_To_Zero_out1 <= '1' WHEN alpha1_for_one_cycle_if_edge_recognized > to_signed(16#00#, 8) ELSE
      '0';

  Delay0_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay0_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF Compare_To_Zero_out1 = '1' THEN
          Delay0_reg <= (OTHERS => '0');
        ELSE 
          Delay0_reg(0) <= Switch_S0_IN;
          Delay0_reg(1 TO 9) <= Delay0_reg(0 TO 8);
        END IF;
      END IF;
    END IF;
  END PROCESS Delay0_process;

  
  Delay0_out1 <= '0' WHEN Compare_To_Zero_out1 = '1' ELSE
      Delay0_reg(9);

  
  reset_old_switch2_out1 <= reset_old2_out1 WHEN alpha1_for_one_cycle_if_edge_recognized_1 = to_signed(16#00#, 8) ELSE
      Switch_S1_IN;

  reset_old2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reset_old2_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        reset_old2_out1 <= reset_old_switch2_out1;
      END IF;
    END IF;
  END PROCESS reset_old2_process;


  Detec_edge1_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old2_out1;
  Detec_edge1_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & Switch_S1_IN;
  alpha1_for_one_cycle_if_edge_recognized_1 <= Detec_edge1_sub_cast - Detec_edge1_sub_cast_1;

  
  Compare_To_Zero1_out1 <= '1' WHEN alpha1_for_one_cycle_if_edge_recognized_1 > to_signed(16#00#, 8) ELSE
      '0';

  Delay1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay1_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF Compare_To_Zero1_out1 = '1' THEN
          Delay1_reg <= (OTHERS => '0');
        ELSE 
          Delay1_reg(0) <= Switch_S1_IN;
          Delay1_reg(1 TO 9) <= Delay1_reg(0 TO 8);
        END IF;
      END IF;
    END IF;
  END PROCESS Delay1_process;

  
  Delay1_out1 <= '0' WHEN Compare_To_Zero1_out1 = '1' ELSE
      Delay1_reg(9);

  
  reset_old_switch3_out1 <= reset_old3_out1 WHEN alpha1_for_one_cycle_if_edge_recognized_2 = to_signed(16#00#, 8) ELSE
      Switch_S2_IN;

  reset_old3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reset_old3_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        reset_old3_out1 <= reset_old_switch3_out1;
      END IF;
    END IF;
  END PROCESS reset_old3_process;


  Detec_edge2_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old3_out1;
  Detec_edge2_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & Switch_S2_IN;
  alpha1_for_one_cycle_if_edge_recognized_2 <= Detec_edge2_sub_cast - Detec_edge2_sub_cast_1;

  
  Compare_To_Zero2_out1 <= '1' WHEN alpha1_for_one_cycle_if_edge_recognized_2 > to_signed(16#00#, 8) ELSE
      '0';

  Delay2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay2_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF Compare_To_Zero2_out1 = '1' THEN
          Delay2_reg <= (OTHERS => '0');
        ELSE 
          Delay2_reg(0) <= Switch_S2_IN;
          Delay2_reg(1 TO 9) <= Delay2_reg(0 TO 8);
        END IF;
      END IF;
    END IF;
  END PROCESS Delay2_process;

  
  Delay2_out1 <= '0' WHEN Compare_To_Zero2_out1 = '1' ELSE
      Delay2_reg(9);

  
  reset_old_switch4_out1 <= reset_old4_out1 WHEN alpha1_for_one_cycle_if_edge_recognized_3 = to_signed(16#00#, 8) ELSE
      Switch_S3_IN;

  reset_old4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reset_old4_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        reset_old4_out1 <= reset_old_switch4_out1;
      END IF;
    END IF;
  END PROCESS reset_old4_process;


  Detec_edge3_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old4_out1;
  Detec_edge3_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & Switch_S3_IN;
  alpha1_for_one_cycle_if_edge_recognized_3 <= Detec_edge3_sub_cast - Detec_edge3_sub_cast_1;

  
  Compare_To_Zero3_out1 <= '1' WHEN alpha1_for_one_cycle_if_edge_recognized_3 > to_signed(16#00#, 8) ELSE
      '0';

  Delay3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay3_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF Compare_To_Zero3_out1 = '1' THEN
          Delay3_reg <= (OTHERS => '0');
        ELSE 
          Delay3_reg(0) <= Switch_S3_IN;
          Delay3_reg(1 TO 9) <= Delay3_reg(0 TO 8);
        END IF;
      END IF;
    END IF;
  END PROCESS Delay3_process;

  
  Delay3_out1 <= '0' WHEN Compare_To_Zero3_out1 = '1' ELSE
      Delay3_reg(9);

  
  reset_old_switch5_out1 <= reset_old5_out1 WHEN alpha1_for_one_cycle_if_edge_recognized_4 = to_signed(16#00#, 8) ELSE
      Switch_S4_IN;

  reset_old5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reset_old5_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        reset_old5_out1 <= reset_old_switch5_out1;
      END IF;
    END IF;
  END PROCESS reset_old5_process;


  Detec_edge4_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old5_out1;
  Detec_edge4_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & Switch_S4_IN;
  alpha1_for_one_cycle_if_edge_recognized_4 <= Detec_edge4_sub_cast - Detec_edge4_sub_cast_1;

  
  Compare_To_Zero4_out1 <= '1' WHEN alpha1_for_one_cycle_if_edge_recognized_4 > to_signed(16#00#, 8) ELSE
      '0';

  Delay4_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay4_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF Compare_To_Zero4_out1 = '1' THEN
          Delay4_reg <= (OTHERS => '0');
        ELSE 
          Delay4_reg(0) <= Switch_S4_IN;
          Delay4_reg(1 TO 9) <= Delay4_reg(0 TO 8);
        END IF;
      END IF;
    END IF;
  END PROCESS Delay4_process;

  
  Delay4_out1 <= '0' WHEN Compare_To_Zero4_out1 = '1' ELSE
      Delay4_reg(9);

  
  reset_old_switch6_out1 <= reset_old6_out1 WHEN alpha1_for_one_cycle_if_edge_recognized_5 = to_signed(16#00#, 8) ELSE
      Switch_S5_IN;

  reset_old6_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      reset_old6_out1 <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        reset_old6_out1 <= reset_old_switch6_out1;
      END IF;
    END IF;
  END PROCESS reset_old6_process;


  Detec_edge5_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old6_out1;
  Detec_edge5_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & Switch_S5_IN;
  alpha1_for_one_cycle_if_edge_recognized_5 <= Detec_edge5_sub_cast - Detec_edge5_sub_cast_1;

  
  Compare_To_Zero5_out1 <= '1' WHEN alpha1_for_one_cycle_if_edge_recognized_5 > to_signed(16#00#, 8) ELSE
      '0';

  Delay5_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay5_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        IF Compare_To_Zero5_out1 = '1' THEN
          Delay5_reg <= (OTHERS => '0');
        ELSE 
          Delay5_reg(0) <= Switch_S5_IN;
          Delay5_reg(1 TO 9) <= Delay5_reg(0 TO 8);
        END IF;
      END IF;
    END IF;
  END PROCESS Delay5_process;

  
  Delay5_out1 <= '0' WHEN Compare_To_Zero5_out1 = '1' ELSE
      Delay5_reg(9);

  Constant13_out1(0) <= '0';
  Constant13_out1(1) <= '0';
  Constant13_out1(2) <= '0';
  Constant13_out1(3) <= '0';
  Constant13_out1(4) <= '0';
  Constant13_out1(5) <= '0';

  Logical0_out1 <= Switch_S0_IN AND Delay0_out1;

  
  CompareToZero0_out1 <= '1' WHEN Logical0_out1 /= '0' ELSE
      '0';

  Logical1_out1 <= Switch_S1_IN AND Delay1_out1;

  
  CompareToZero1_out1 <= '1' WHEN Logical1_out1 /= '0' ELSE
      '0';

  Logical2_out1 <= Switch_S2_IN AND Delay2_out1;

  
  CompareToZero2_out1 <= '1' WHEN Logical2_out1 /= '0' ELSE
      '0';

  Logical3_out1 <= Switch_S3_IN AND Delay3_out1;

  
  CompareToZero3_out1 <= '1' WHEN Logical3_out1 /= '0' ELSE
      '0';

  Logical4_out1 <= Switch_S4_IN AND Delay4_out1;

  
  CompareToZero4_out1 <= '1' WHEN Logical4_out1 /= '0' ELSE
      '0';

  Logical5_out1 <= Switch_S5_IN AND Delay5_out1;

  
  CompareToZero5_out1 <= '1' WHEN Logical5_out1 /= '0' ELSE
      '0';

  Mux2_out1(0) <= CompareToZero0_out1;
  Mux2_out1(1) <= CompareToZero1_out1;
  Mux2_out1(2) <= CompareToZero2_out1;
  Mux2_out1(3) <= CompareToZero3_out1;
  Mux2_out1(4) <= CompareToZero4_out1;
  Mux2_out1(5) <= CompareToZero5_out1;

  
  ShortCircuitProtection_out1 <= Constant13_out1 WHEN switch_compare_1 = '0' ELSE
      Mux2_out1;

  INVERSE_BOTTOMSWITCH_out1 <= '0';

  
  switch_compare_1_1 <= '1' WHEN INVERSE_BOTTOMSWITCH_out1 = '1' ELSE
      '0';

  ShortCircuitProtection_out1_1 <= ShortCircuitProtection_out1(1);

  Inverse_BottomSwitch1_out1 <=  NOT ShortCircuitProtection_out1_1;

  
  ShortCircuitProtection1_out1 <= ShortCircuitProtection_out1_1 WHEN switch_compare_1_1 = '0' ELSE
      Inverse_BottomSwitch1_out1;

  
  switch_compare_1_2 <= '1' WHEN INVERSE_BOTTOMSWITCH_out1 = '1' ELSE
      '0';

  ShortCircuitProtection_out1_3 <= ShortCircuitProtection_out1(3);

  Inverse_BottomSwitch2_out1 <=  NOT ShortCircuitProtection_out1_3;

  
  ShortCircuitProtection2_out1 <= ShortCircuitProtection_out1_3 WHEN switch_compare_1_2 = '0' ELSE
      Inverse_BottomSwitch2_out1;

  
  switch_compare_1_3 <= '1' WHEN INVERSE_BOTTOMSWITCH_out1 = '1' ELSE
      '0';

  ShortCircuitProtection_out1_5 <= ShortCircuitProtection_out1(5);

  Inverse_BottomSwitch3_out1 <=  NOT ShortCircuitProtection_out1_5;

  
  ShortCircuitProtection3_out1 <= ShortCircuitProtection_out1_5 WHEN switch_compare_1_3 = '0' ELSE
      Inverse_BottomSwitch3_out1;

  ce_out <= clk_enable;

  Switch_S0_OUT <= ShortCircuitProtection_out1(0);

  Switch_S1_OUT <= ShortCircuitProtection1_out1;

  Switch_S2_OUT <= ShortCircuitProtection_out1(2);

  Switch_S3_OUT <= ShortCircuitProtection2_out1;

  Switch_S4_OUT <= ShortCircuitProtection_out1(4);

  Switch_S5_OUT <= ShortCircuitProtection3_out1;

END rtl;

