-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\Transformation_V12\Trans_123_dq_V12_ip_src_Trans_123_dq_fix_V12.vhd
-- Created: 2020-06-10 19:03:35
-- 
-- Generated by MATLAB 9.4 and HDL Coder 3.12
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 2e-08
-- Target subsystem base rate: 4e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        4e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- id                            ce_out        4e-08
-- iq                            ce_out        4e-08
-- id_AXI                        ce_out        4e-08
-- iq_AXI                        ce_out        4e-08
-- dq_Done                       ce_out        4e-08
-- sin                           ce_out        4e-08
-- cos                           ce_out        4e-08
-- i1_AXI                        ce_out        4e-08
-- i2_AXI                        ce_out        4e-08
-- i3_AXI                        ce_out        4e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Trans_123_dq_V12_ip_src_Trans_123_dq_fix_V12
-- Source Path: Transformation_V12/Trans_123_dq_fix_V12
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Trans_123_dq_V12_ip_src_Trans_123_dq_fix_V12_pkg.ALL;

ENTITY Trans_123_dq_V12_ip_src_Trans_123_dq_fix_V12 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        i_ph1                             :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i_ph2                             :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i_ph3                             :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        theta                             :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        theta_offset_AXI                  :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        CurrentValid_in                   :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        id                                :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        iq                                :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        id_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        iq_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        dq_Done                           :   OUT   std_logic;
        sin                               :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        cos                               :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        i1_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i2_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i3_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0)  -- sfix18_En11
        );
END Trans_123_dq_V12_ip_src_Trans_123_dq_fix_V12;


ARCHITECTURE rtl OF Trans_123_dq_V12_ip_src_Trans_123_dq_fix_V12 IS

  -- Component Declarations
  COMPONENT Trans_123_dq_V12_ip_src_Cosine
    PORT( u                               :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
          sin_2_pi_u                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          cos_2_pi_u                      :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En14
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Trans_123_dq_V12_ip_src_Cosine
    USE ENTITY work.Trans_123_dq_V12_ip_src_Cosine(rtl);

  -- Signals
  SIGNAL enb_1_2_0                        : std_logic;
  SIGNAL CurrentValid_in_1                : std_logic;
  SIGNAL alpha1_for_one_cycle_if_edge_recognized : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old2_out1                  : std_logic;
  SIGNAL reset_old_switch1_out1           : std_logic;
  SIGNAL Detec_edge_sub_cast              : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge_sub_cast_1            : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL dtc_out                          : std_logic;  -- ufix1
  SIGNAL Saturation_out1                  : std_logic;  -- ufix1
  SIGNAL Saturation_out1_1                : std_logic;  -- ufix1
  SIGNAL Data_Type_Conversion1_out1       : signed(7 DOWNTO 0);  -- int8
  SIGNAL Second_value                     : std_logic;  -- ufix1
  SIGNAL Data_Type_Conversion2_out1       : signed(7 DOWNTO 0);  -- int8
  SIGNAL Gain_out1                        : signed(15 DOWNTO 0);  -- sfix16_En5
  SIGNAL Add4_add_cast                    : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Switch                           : signed(7 DOWNTO 0);  -- int8
  SIGNAL id1_Enable                       : std_logic;
  SIGNAL delayMatch5_reg                  : std_logic_vector(0 TO 5);  -- ufix1 [6]
  SIGNAL id1_Enable_1                     : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL switch_compare_1_1               : std_logic;
  SIGNAL i_ph2_signed                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL i_ph2_1                          : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on3_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay4_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain1_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En28
  SIGNAL Gain1_factor                     : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain1_factor_1                   : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain1_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL switch_compare_1_2               : std_logic;
  SIGNAL i_ph3_signed                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL i_ph3_1                          : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on4_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay5_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain2_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En28
  SIGNAL Gain2_factor                     : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain2_factor_1                   : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain2_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL AddBeta_out1                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL DelayValue2_out1                 : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL switch_compare_1_3               : std_logic;
  SIGNAL i_ph1_signed                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL i_ph1_1                          : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on2_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay2_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain6_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En28
  SIGNAL Gain6_factor                     : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain6_factor_1                   : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain6_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain4_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En29
  SIGNAL Gain4_factor                     : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain4_factor_1                   : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain4_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL AddAlpha_op_stage2               : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain5_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En29
  SIGNAL Gain5_factor                     : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain5_factor_1                   : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain5_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL AddAlpha_out1                    : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain7_cast                       : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL Gain7_cast_1                     : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL Gain7_cast_2                     : signed(35 DOWNTO 0);  -- sfix36_En28
  SIGNAL Gain7_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL DelayValue4_out1                 : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_id_out1                   : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_id_out1_1                 : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL reduced_reg                      : vector_of_signed18(0 TO 3);  -- sfix18 [4]
  SIGNAL Switch_id_out1_2                 : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Saturation_out1_2                : std_logic;  -- ufix1
  SIGNAL reduced_reg_1                    : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL Saturation_out1_3                : std_logic;  -- ufix1
  SIGNAL switch_compare_1_4               : std_logic;
  SIGNAL theta_signed                     : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL theta_1                          : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL theta_offset_AXI_signed          : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL theta_offset_AXI_1               : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add1_out1                        : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add1_out1_1                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Compare_Limit_Low_out1           : std_logic;
  SIGNAL Compare_Limit_High_out1          : std_logic;
  SIGNAL Compare_Limit_High_out1_1        : std_logic;
  SIGNAL switch_compare_1_5               : std_logic;
  SIGNAL Add1_out1_2                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Constant_out1                    : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add2_out1                        : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Compare_Limit_Low_out1_1         : std_logic;
  SIGNAL switch_compare_1_6               : std_logic;
  SIGNAL Add2_out1_1                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Switch_Limit_High_out1           : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Constant1_out1                   : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add3_out1                        : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add3_out1_1                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Switch_Limit_Low_out1            : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL ScaleTheta_mul_temp              : signed(47 DOWNTO 0);  -- sfix48_En45
  SIGNAL ScaleTheta_out1                  : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL ScaleTheta_out1_1                : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Cosine_out1                      : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Cosine_out2                      : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Cosine_out1_signed               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Cosine_out1_1                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_on7_out1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_on7_out1_1                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL sin1_out1                        : signed(33 DOWNTO 0);  -- sfix34_En25
  SIGNAL DelayValue1_out1                 : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_id1_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_id1_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL reduced_reg_2                    : vector_of_signed18(0 TO 3);  -- sfix18 [4]
  SIGNAL Switch_id1_out1_2                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL switch_compare_1_7               : std_logic;
  SIGNAL Cosine_out2_signed               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Cosine_out2_1                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_on1_out1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_on1_out1_1                : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL cos1_out1                        : signed(33 DOWNTO 0);  -- sfix34_En25
  SIGNAL sin1_out1_1                      : signed(33 DOWNTO 0);  -- sfix34_En25
  SIGNAL sin1_out1_2                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL cos1_out1_1                      : signed(33 DOWNTO 0);  -- sfix34_En25
  SIGNAL cos1_out1_2                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Add_1_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_idpred1_out1              : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay10_out1                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_idpred1_out1_1            : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL delayMatch6_reg                  : vector_of_signed8(0 TO 5);  -- sfix8 [6]
  SIGNAL Switch_1                         : signed(7 DOWNTO 0);  -- int8
  SIGNAL switch_compare_1_8               : std_logic;
  SIGNAL Switch_idpred2_out1              : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay16_out1                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_idpred2_out1_1            : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL shift6_out1                      : std_logic;  -- ufix1
  SIGNAL shift1_out1                      : std_logic;  -- ufix1
  SIGNAL shift2_out1                      : std_logic;  -- ufix1
  SIGNAL shift3_out1                      : std_logic;  -- ufix1
  SIGNAL Logical_Operator_out1            : std_logic;
  SIGNAL delayMatch7_reg                  : std_logic_vector(0 TO 6);  -- ufix1 [7]
  SIGNAL Logical_Operator_out1_1          : std_logic;
  SIGNAL delayMatch8_reg                  : vector_of_signed16(0 TO 2);  -- sfix16 [3]
  SIGNAL Cosine_out1_2                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL delayMatch9_reg                  : vector_of_signed16(0 TO 2);  -- sfix16 [3]
  SIGNAL Cosine_out2_2                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL delayMatch10_reg                 : vector_of_signed18(0 TO 6);  -- sfix18 [7]
  SIGNAL Switch_on2_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL delayMatch11_reg                 : vector_of_signed18(0 TO 6);  -- sfix18 [7]
  SIGNAL Switch_on3_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL delayMatch12_reg                 : vector_of_signed18(0 TO 6);  -- sfix18 [7]
  SIGNAL Switch_on4_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL End_Cycle                        : std_logic;  -- ufix1
  SIGNAL alpha1_for_one_cycle_if_edge_recognized_1 : signed(7 DOWNTO 0);  -- int8

BEGIN
  -- Delay to compensate the 1 pipeline before the multiplication.
  -- 1 Pipeline for the second repeating.
  -- 
  -- cosine -> Nur Look-Up,
  -- keine Multiplikatoren
  -- verwendet
  -- 
  -- - Ich lass den ganzen IP Core mit einem langsameren Clock laufen, 
  --  damit ich keine Timingverletzung durch die Trigonometrische 
  --  Funktion in Vivado bekomme.
  -- - Dadurch das ich unnütze Pipeline Stages einspare, sollte 
  --  die notwendige Gesamtzeit konstant bleiben.
  -- - Der cosine braucht bei (2^7)+1 circa 24ns Durchlaufzeit.
  -- - Zwischen (2^7)+1 und (2^13)+1 macht die Genauigkeit Sinn. Je mehr Bits
  --  desto Genauer, aber desto längere Durchlaufzeiten habe ich als auch mehr
  --   Ressourcen brauche ich. (Habe mich aktuell für (2^9)+1 entschieden.
  -- 
  -- Durch den Delay von 5, wird ab erkennen der Flanke,
  -- das Signal für 5 Takte high bleiben.
  -- Hierdurch kann man die Impuls Länge des Enables einstellen.
  -- Da ich diesen IP-Core mit 25MHz laufen lasse, bedeuten 5 Delays -> 20 Clocks at 100MHz
  -- 
  -- 1 for one cycle if edge recognized
  -- 
  -- Wir brauchen hier auf jeden Fall 4 Taktzyklen-Flag (@100MHz),
  -- damit ich es mit dem 25MHZ IP-Core sicher erkennen kann. Das hab 
  -- ich aber, da die Strommessung mit "CurrentValid" ein sehr langes Flag
  -- (345 Takte @100MHz) ausgibt!
  -- 
  -- Because of the subsequent VoltageVectors runs with 25MHz and this
  -- IP Core also runs with 25MHz, we need a DONE-Flag for at least 1 cycle.
  -- Now, since this block runs at 25MHz, i have 20 cycles (at 100MHz) in order
  -- to connect this dq-transformation also with other, slower, IP Cores such as
  -- FOC.
  -- 
  -- Threshold = 1
  -- 
  -- Threshold = 2

  u_Cosine : Trans_123_dq_V12_ip_src_Cosine
    PORT MAP( u => std_logic_vector(ScaleTheta_out1_1),  -- sfix24_En20
              sin_2_pi_u => Cosine_out1,  -- sfix16_En14
              cos_2_pi_u => Cosine_out2  -- sfix16_En14
              );

  enb_1_2_0 <= clk_enable;

  in_5_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        CurrentValid_in_1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        CurrentValid_in_1 <= CurrentValid_in;
      END IF;
    END IF;
  END PROCESS in_5_pipe_process;


  
  reset_old_switch1_out1 <= reset_old2_out1 WHEN alpha1_for_one_cycle_if_edge_recognized = to_signed(16#00#, 8) ELSE
      CurrentValid_in_1;

  reset_old2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old2_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        reset_old2_out1 <= reset_old_switch1_out1;
      END IF;
    END IF;
  END PROCESS reset_old2_process;


  Detec_edge_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & CurrentValid_in_1;
  Detec_edge_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old2_out1;
  alpha1_for_one_cycle_if_edge_recognized <= Detec_edge_sub_cast - Detec_edge_sub_cast_1;

  
  dtc_out <= '1' WHEN (alpha1_for_one_cycle_if_edge_recognized(7) = '0') AND (alpha1_for_one_cycle_if_edge_recognized(6 DOWNTO 1) /= "000000") ELSE
      '0' WHEN alpha1_for_one_cycle_if_edge_recognized(7) = '1' ELSE
      alpha1_for_one_cycle_if_edge_recognized(0);

  Saturation_out1 <= dtc_out;

  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Saturation_out1_1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Saturation_out1_1 <= Saturation_out1;
      END IF;
    END IF;
  END PROCESS reduced_process;


  Data_Type_Conversion1_out1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & Saturation_out1_1;

  Delay36_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Second_value <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Second_value <= Saturation_out1_1;
      END IF;
    END IF;
  END PROCESS Delay36_process;


  Data_Type_Conversion2_out1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & Second_value;

  Gain_out1 <= resize(Data_Type_Conversion2_out1 & '0' & '0' & '0' & '0' & '0' & '0', 16);

  Add4_add_cast <= Gain_out1(12 DOWNTO 5);
  Switch <= Data_Type_Conversion1_out1 + Add4_add_cast;

  
  id1_Enable <= '1' WHEN Switch = to_signed(16#01#, 8) ELSE
      '0';

  delayMatch5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch5_reg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        delayMatch5_reg(0) <= id1_Enable;
        delayMatch5_reg(1 TO 5) <= delayMatch5_reg(0 TO 4);
      END IF;
    END IF;
  END PROCESS delayMatch5_process;

  id1_Enable_1 <= delayMatch5_reg(5);

  
  switch_compare_1 <= '1' WHEN id1_Enable_1 = '1' ELSE
      '0';

  
  switch_compare_1_1 <= '1' WHEN Saturation_out1 = '1' ELSE
      '0';

  i_ph2_signed <= signed(i_ph2);

  in_1_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        i_ph2_1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        i_ph2_1 <= i_ph2_signed;
      END IF;
    END IF;
  END PROCESS in_1_pipe_process;


  Delay4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay4_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        Delay4_out1 <= Switch_on3_out1;
      END IF;
    END IF;
  END PROCESS Delay4_process;


  
  Switch_on3_out1 <= Delay4_out1 WHEN switch_compare_1_1 = '0' ELSE
      i_ph2_1;

  -- FCSD for 75674 = 2 X 157 X 241; Total Cost = 5
  -- CSD Encoding (2) : 10; Cost (Adders) = 0
  Gain1_factor <= resize(Switch_on3_out1 & '0', 36);
  -- CSD Encoding (157) : 0101001'01; Cost (Adders) = 3
  Gain1_factor_1 <= ((resize(Gain1_factor & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) + resize(Gain1_factor & '0' & '0' & '0' & '0' & '0', 36)) - resize(Gain1_factor & '0' & '0', 36)) + Gain1_factor;
  -- CSD Encoding (241) : 10001'0001; Cost (Adders) = 2
  Gain1_mul_temp <= (resize(Gain1_factor_1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) - resize(Gain1_factor_1 & '0' & '0' & '0' & '0', 36)) + Gain1_factor_1;
  Gain1_out1 <= Gain1_mul_temp(34 DOWNTO 17);

  
  switch_compare_1_2 <= '1' WHEN Saturation_out1 = '1' ELSE
      '0';

  i_ph3_signed <= signed(i_ph3);

  in_2_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        i_ph3_1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        i_ph3_1 <= i_ph3_signed;
      END IF;
    END IF;
  END PROCESS in_2_pipe_process;


  Delay5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay5_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        Delay5_out1 <= Switch_on4_out1;
      END IF;
    END IF;
  END PROCESS Delay5_process;


  
  Switch_on4_out1 <= Delay5_out1 WHEN switch_compare_1_2 = '0' ELSE
      i_ph3_1;

  -- FCSD for 75674 = 2 X 157 X 241; Total Cost = 5
  -- CSD Encoding (2) : 10; Cost (Adders) = 0
  Gain2_factor <= resize(Switch_on4_out1 & '0', 36);
  -- CSD Encoding (157) : 0101001'01; Cost (Adders) = 3
  Gain2_factor_1 <= ((resize(Gain2_factor & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) + resize(Gain2_factor & '0' & '0' & '0' & '0' & '0', 36)) - resize(Gain2_factor & '0' & '0', 36)) + Gain2_factor;
  -- CSD Encoding (241) : 10001'0001; Cost (Adders) = 2
  Gain2_mul_temp <= (resize(Gain2_factor_1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) - resize(Gain2_factor_1 & '0' & '0' & '0' & '0', 36)) + Gain2_factor_1;
  Gain2_out1 <= Gain2_mul_temp(34 DOWNTO 17);

  AddBeta_out1 <= Gain1_out1 - Gain2_out1;

  DelayValue2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        DelayValue2_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        DelayValue2_out1 <= AddBeta_out1;
      END IF;
    END IF;
  END PROCESS DelayValue2_process;


  
  switch_compare_1_3 <= '1' WHEN Saturation_out1 = '1' ELSE
      '0';

  i_ph1_signed <= signed(i_ph1);

  in_0_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        i_ph1_1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        i_ph1_1 <= i_ph1_signed;
      END IF;
    END IF;
  END PROCESS in_0_pipe_process;


  Delay2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay2_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        Delay2_out1 <= Switch_on2_out1;
      END IF;
    END IF;
  END PROCESS Delay2_process;


  
  Switch_on2_out1 <= Delay2_out1 WHEN switch_compare_1_3 = '0' ELSE
      i_ph1_1;

  -- FCSD for 87381 = 511 X 9 X 19; Total Cost = 4
  -- CSD Encoding (511) : 1000000001'; Cost (Adders) = 1
  Gain6_factor <= resize(Switch_on2_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) - resize(Switch_on2_out1, 36);
  -- CSD Encoding (9) : 01001; Cost (Adders) = 1
  Gain6_factor_1 <= resize(Gain6_factor & '0' & '0' & '0', 36) + Gain6_factor;
  -- CSD Encoding (19) : 010011; Cost (Adders) = 2
  Gain6_mul_temp <= (resize(Gain6_factor_1 & '0' & '0' & '0' & '0', 36) + resize(Gain6_factor_1 & '0', 36)) + Gain6_factor_1;
  Gain6_out1 <= Gain6_mul_temp(34 DOWNTO 17);

  -- FCSD for 87381 = 511 X 9 X 19; Total Cost = 4
  -- CSD Encoding (511) : 1000000001'; Cost (Adders) = 1
  Gain4_factor <= resize(Switch_on3_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) - resize(Switch_on3_out1, 36);
  -- CSD Encoding (9) : 01001; Cost (Adders) = 1
  Gain4_factor_1 <= resize(Gain4_factor & '0' & '0' & '0', 36) + Gain4_factor;
  -- CSD Encoding (19) : 010011; Cost (Adders) = 2
  Gain4_mul_temp <= (resize(Gain4_factor_1 & '0' & '0' & '0' & '0', 36) + resize(Gain4_factor_1 & '0', 36)) + Gain4_factor_1;
  Gain4_out1 <= Gain4_mul_temp(35 DOWNTO 18);

  AddAlpha_op_stage2 <= Gain6_out1 - Gain4_out1;

  -- FCSD for 87381 = 511 X 9 X 19; Total Cost = 4
  -- CSD Encoding (511) : 1000000001'; Cost (Adders) = 1
  Gain5_factor <= resize(Switch_on4_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) - resize(Switch_on4_out1, 36);
  -- CSD Encoding (9) : 01001; Cost (Adders) = 1
  Gain5_factor_1 <= resize(Gain5_factor & '0' & '0' & '0', 36) + Gain5_factor;
  -- CSD Encoding (19) : 010011; Cost (Adders) = 2
  Gain5_mul_temp <= (resize(Gain5_factor_1 & '0' & '0' & '0' & '0', 36) + resize(Gain5_factor_1 & '0', 36)) + Gain5_factor_1;
  Gain5_out1 <= Gain5_mul_temp(35 DOWNTO 18);

  AddAlpha_out1 <= AddAlpha_op_stage2 - Gain5_out1;

  Gain7_cast <= resize(AddAlpha_out1, 19);
  Gain7_cast_1 <=  - (Gain7_cast);
  Gain7_cast_2 <= Gain7_cast_1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0';
  Gain7_out1 <= Gain7_cast_2(34 DOWNTO 17);

  DelayValue4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        DelayValue4_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        DelayValue4_out1 <= Gain7_out1;
      END IF;
    END IF;
  END PROCESS DelayValue4_process;


  
  Switch_id_out1_1 <= DelayValue2_out1 WHEN Switch = to_signed(16#01#, 8) ELSE
      DelayValue4_out1 WHEN Switch = to_signed(16#02#, 8) ELSE
      Switch_id_out1;

  reduced_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_id_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        Switch_id_out1 <= Switch_id_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  reduced_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb_1_2_0 = '1' THEN
        reduced_reg(0) <= Switch_id_out1;
        reduced_reg(1 TO 3) <= reduced_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS reduced_2_process;

  Switch_id_out1_2 <= reduced_reg(3);

  reduced_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Saturation_out1_2 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Saturation_out1_2 <= Saturation_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_3_process;


  reduced_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg_1 <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        reduced_reg_1(0) <= Saturation_out1_2;
        reduced_reg_1(1) <= reduced_reg_1(0);
      END IF;
    END IF;
  END PROCESS reduced_4_process;

  Saturation_out1_3 <= reduced_reg_1(1);

  
  switch_compare_1_4 <= '1' WHEN Saturation_out1_3 = '1' ELSE
      '0';

  theta_signed <= signed(theta);

  in_3_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        theta_1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        theta_1 <= theta_signed;
      END IF;
    END IF;
  END PROCESS in_3_pipe_process;


  theta_offset_AXI_signed <= signed(theta_offset_AXI);

  in_4_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        theta_offset_AXI_1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        theta_offset_AXI_1 <= theta_offset_AXI_signed;
      END IF;
    END IF;
  END PROCESS in_4_pipe_process;


  Add1_out1 <= theta_1 - theta_offset_AXI_1;

  Add1_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add1_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        Add1_out1_1 <= Add1_out1;
      END IF;
    END IF;
  END PROCESS Add1_out_pipe_process;


  
  Compare_Limit_Low_out1 <= '1' WHEN Add1_out1_1 < to_signed(16#000000#, 24) ELSE
      '0';

  
  Compare_Limit_High_out1 <= '1' WHEN Add1_out1_1 >= to_signed(16#6487ED#, 24) ELSE
      '0';

  Compare_Limit_High_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Compare_Limit_High_out1_1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Compare_Limit_High_out1_1 <= Compare_Limit_High_out1;
      END IF;
    END IF;
  END PROCESS Compare_Limit_High_out_pipe_process;


  
  switch_compare_1_5 <= '1' WHEN Compare_Limit_High_out1_1 > '0' ELSE
      '0';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add1_out1_2 <= to_signed(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        Add1_out1_2 <= Add1_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  Constant_out1 <= to_signed(16#6487ED#, 24);

  Add2_out1 <= Add1_out1_1 - Constant_out1;

  Compare_Limit_Low_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Compare_Limit_Low_out1_1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        Compare_Limit_Low_out1_1 <= Compare_Limit_Low_out1;
      END IF;
    END IF;
  END PROCESS Compare_Limit_Low_out_pipe_process;


  
  switch_compare_1_6 <= '1' WHEN Compare_Limit_Low_out1_1 > '0' ELSE
      '0';

  Add2_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add2_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        Add2_out1_1 <= Add2_out1;
      END IF;
    END IF;
  END PROCESS Add2_out_pipe_process;


  
  Switch_Limit_High_out1 <= Add1_out1_2 WHEN switch_compare_1_5 = '0' ELSE
      Add2_out1_1;

  Constant1_out1 <= to_signed(16#6487ED#, 24);

  Add3_out1 <= Add1_out1_1 + Constant1_out1;

  Add3_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add3_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        Add3_out1_1 <= Add3_out1;
      END IF;
    END IF;
  END PROCESS Add3_out_pipe_process;


  
  Switch_Limit_Low_out1 <= Switch_Limit_High_out1 WHEN switch_compare_1_6 = '0' ELSE
      Add3_out1_1;

  -- CSD Encoding (5340354) : 01010001100001'0011000010; Cost (Adders) = 7
  ScaleTheta_mul_temp <= ((((((resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) - resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0', 48);
  ScaleTheta_out1 <= resize(ScaleTheta_mul_temp(47 DOWNTO 25), 24);

  Cosine_in_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        ScaleTheta_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_2_0 = '1' THEN
        ScaleTheta_out1_1 <= ScaleTheta_out1;
      END IF;
    END IF;
  END PROCESS Cosine_in_pipe_process;


  Cosine_out1_signed <= signed(Cosine_out1);

  Cosine_out_pipe0_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Cosine_out1_1 <= to_signed(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        Cosine_out1_1 <= Cosine_out1_signed;
      END IF;
    END IF;
  END PROCESS Cosine_out_pipe0_process;


  
  Switch_on7_out1_1 <= Switch_on7_out1 WHEN switch_compare_1_4 = '0' ELSE
      Cosine_out1_1;

  reduced_5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on7_out1 <= to_signed(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        Switch_on7_out1 <= Switch_on7_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_5_process;


  sin1_out1 <= Switch_id_out1_2 * Switch_on7_out1;

  DelayValue1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        DelayValue1_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        DelayValue1_out1 <= AddAlpha_out1;
      END IF;
    END IF;
  END PROCESS DelayValue1_process;


  
  Switch_id1_out1_1 <= DelayValue1_out1 WHEN Switch = to_signed(16#01#, 8) ELSE
      DelayValue2_out1 WHEN Switch = to_signed(16#02#, 8) ELSE
      Switch_id1_out1;

  reduced_6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_id1_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        Switch_id1_out1 <= Switch_id1_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_6_process;


  reduced_7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg_2 <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb_1_2_0 = '1' THEN
        reduced_reg_2(0) <= Switch_id1_out1;
        reduced_reg_2(1 TO 3) <= reduced_reg_2(0 TO 2);
      END IF;
    END IF;
  END PROCESS reduced_7_process;

  Switch_id1_out1_2 <= reduced_reg_2(3);

  
  switch_compare_1_7 <= '1' WHEN Saturation_out1_3 = '1' ELSE
      '0';

  Cosine_out2_signed <= signed(Cosine_out2);

  Cosine_out_pipe1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Cosine_out2_1 <= to_signed(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        Cosine_out2_1 <= Cosine_out2_signed;
      END IF;
    END IF;
  END PROCESS Cosine_out_pipe1_process;


  
  Switch_on1_out1_1 <= Switch_on1_out1 WHEN switch_compare_1_7 = '0' ELSE
      Cosine_out2_1;

  reduced_8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_on1_out1 <= to_signed(16#0000#, 16);
      ELSIF enb_1_2_0 = '1' THEN
        Switch_on1_out1 <= Switch_on1_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_8_process;


  cos1_out1 <= Switch_id1_out1_2 * Switch_on1_out1;

  PipelineRegister1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        sin1_out1_1 <= to_signed(0, 34);
      ELSIF enb_1_2_0 = '1' THEN
        sin1_out1_1 <= sin1_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister1_process;


  sin1_out1_2 <= sin1_out1_1(31 DOWNTO 14);

  PipelineRegister_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        cos1_out1_1 <= to_signed(0, 34);
      ELSIF enb_1_2_0 = '1' THEN
        cos1_out1_1 <= cos1_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  cos1_out1_2 <= cos1_out1_1(31 DOWNTO 14);

  Add_1_out1 <= sin1_out1_2 + cos1_out1_2;

  Delay10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay10_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        Delay10_out1 <= Switch_idpred1_out1;
      END IF;
    END IF;
  END PROCESS Delay10_process;


  
  Switch_idpred1_out1 <= Delay10_out1 WHEN switch_compare_1 = '0' ELSE
      Add_1_out1;

  reduced_9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_idpred1_out1_1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        Switch_idpred1_out1_1 <= Switch_idpred1_out1;
      END IF;
    END IF;
  END PROCESS reduced_9_process;


  id <= std_logic_vector(Switch_idpred1_out1_1);

  delayMatch6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch6_reg <= (OTHERS => to_signed(16#00#, 8));
      ELSIF enb_1_2_0 = '1' THEN
        delayMatch6_reg(0) <= Switch;
        delayMatch6_reg(1 TO 5) <= delayMatch6_reg(0 TO 4);
      END IF;
    END IF;
  END PROCESS delayMatch6_process;

  Switch_1 <= delayMatch6_reg(5);

  
  switch_compare_1_8 <= '1' WHEN Switch_1 >= to_signed(16#02#, 8) ELSE
      '0';

  Delay16_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay16_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        Delay16_out1 <= Switch_idpred2_out1;
      END IF;
    END IF;
  END PROCESS Delay16_process;


  
  Switch_idpred2_out1 <= Delay16_out1 WHEN switch_compare_1_8 = '0' ELSE
      Add_1_out1;

  reduced_10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_idpred2_out1_1 <= to_signed(16#00000#, 18);
      ELSIF enb_1_2_0 = '1' THEN
        Switch_idpred2_out1_1 <= Switch_idpred2_out1;
      END IF;
    END IF;
  END PROCESS reduced_10_process;


  iq <= std_logic_vector(Switch_idpred2_out1_1);

  id_AXI <= std_logic_vector(Switch_idpred1_out1_1);

  iq_AXI <= std_logic_vector(Switch_idpred2_out1_1);

  shift6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift6_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        shift6_out1 <= Saturation_out1_2;
      END IF;
    END IF;
  END PROCESS shift6_process;


  shift1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift1_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        shift1_out1 <= shift6_out1;
      END IF;
    END IF;
  END PROCESS shift1_process;


  shift2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift2_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        shift2_out1 <= shift1_out1;
      END IF;
    END IF;
  END PROCESS shift2_process;


  shift3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift3_out1 <= '0';
      ELSIF enb_1_2_0 = '1' THEN
        shift3_out1 <= shift2_out1;
      END IF;
    END IF;
  END PROCESS shift3_process;


  Logical_Operator_out1 <= shift3_out1 OR (shift2_out1 OR (shift1_out1 OR (Saturation_out1_2 OR shift6_out1)));

  delayMatch7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch7_reg <= (OTHERS => '0');
      ELSIF enb_1_2_0 = '1' THEN
        delayMatch7_reg(0) <= Logical_Operator_out1;
        delayMatch7_reg(1 TO 6) <= delayMatch7_reg(0 TO 5);
      END IF;
    END IF;
  END PROCESS delayMatch7_process;

  Logical_Operator_out1_1 <= delayMatch7_reg(6);

  delayMatch8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch8_reg <= (OTHERS => to_signed(16#0000#, 16));
      ELSIF enb_1_2_0 = '1' THEN
        delayMatch8_reg(0) <= Cosine_out1_1;
        delayMatch8_reg(1 TO 2) <= delayMatch8_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS delayMatch8_process;

  Cosine_out1_2 <= delayMatch8_reg(2);

  sin <= std_logic_vector(Cosine_out1_2);

  delayMatch9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch9_reg <= (OTHERS => to_signed(16#0000#, 16));
      ELSIF enb_1_2_0 = '1' THEN
        delayMatch9_reg(0) <= Cosine_out2_1;
        delayMatch9_reg(1 TO 2) <= delayMatch9_reg(0 TO 1);
      END IF;
    END IF;
  END PROCESS delayMatch9_process;

  Cosine_out2_2 <= delayMatch9_reg(2);

  cos <= std_logic_vector(Cosine_out2_2);

  delayMatch10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch10_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb_1_2_0 = '1' THEN
        delayMatch10_reg(0) <= Switch_on2_out1;
        delayMatch10_reg(1 TO 6) <= delayMatch10_reg(0 TO 5);
      END IF;
    END IF;
  END PROCESS delayMatch10_process;

  Switch_on2_out1_1 <= delayMatch10_reg(6);

  i1_AXI <= std_logic_vector(Switch_on2_out1_1);

  delayMatch11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch11_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb_1_2_0 = '1' THEN
        delayMatch11_reg(0) <= Switch_on3_out1;
        delayMatch11_reg(1 TO 6) <= delayMatch11_reg(0 TO 5);
      END IF;
    END IF;
  END PROCESS delayMatch11_process;

  Switch_on3_out1_1 <= delayMatch11_reg(6);

  i2_AXI <= std_logic_vector(Switch_on3_out1_1);

  delayMatch12_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch12_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb_1_2_0 = '1' THEN
        delayMatch12_reg(0) <= Switch_on4_out1;
        delayMatch12_reg(1 TO 6) <= delayMatch12_reg(0 TO 5);
      END IF;
    END IF;
  END PROCESS delayMatch12_process;

  Switch_on4_out1_1 <= delayMatch12_reg(6);

  i3_AXI <= std_logic_vector(Switch_on4_out1_1);

  ce_out <= clk_enable;

  dq_Done <= Logical_Operator_out1_1;

END rtl;

