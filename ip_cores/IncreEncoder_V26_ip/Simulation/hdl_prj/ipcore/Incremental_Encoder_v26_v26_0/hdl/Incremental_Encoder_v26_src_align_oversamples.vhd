-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\inc_enc_v26\Incremental_Encoder_v26_src_align_oversamples.vhd
-- Created: 2023-03-06 13:40:26
-- 
-- Generated by MATLAB 9.13 and HDL Coder 4.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Incremental_Encoder_v26_src_align_oversamples
-- Source Path: inc_enc_v26/IncEnc_V25/speed/OS_factor_logic/align_oversamples
-- Hierarchy Level: 3
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Incremental_Encoder_v26_src_IncEnc_V25_pac.ALL;

ENTITY Incremental_Encoder_v26_src_align_oversamples IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb_1_5987_0                      :   IN    std_logic;
        oversampling_factor               :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        new_transition                    :   IN    std_logic_vector(0 TO 3);  -- boolean [4]
        states                            :   IN    vector_of_std_logic_vector16(0 TO 3);  -- int16 [4]
        delay_output                      :   OUT   std_logic_vector(0 TO 3)  -- boolean [4]
        );
END Incremental_Encoder_v26_src_align_oversamples;


ARCHITECTURE rtl OF Incremental_Encoder_v26_src_align_oversamples IS

  -- Signals
  SIGNAL oversampling_factor_unsigned     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL states_signed                    : vector_of_signed16(0 TO 3);  -- int16 [4]
  SIGNAL delay                            : std_logic_vector(0 TO 3);  -- boolean [4]
  SIGNAL delay_next                       : std_logic_vector(0 TO 3);  -- boolean [4]

BEGIN
  oversampling_factor_unsigned <= unsigned(oversampling_factor);

  outputgen: FOR k1 IN 0 TO 3 GENERATE
    states_signed(k1) <= signed(states(k1));
  END GENERATE;

  align_oversamples_process : PROCESS (clk)
    VARIABLE t_1 : INTEGER;
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN

        FOR t_1 IN 0 TO 3 LOOP
          delay(t_1) <= '0';
        END LOOP;

      ELSIF enb_1_5987_0 = '1' THEN

        FOR t_0 IN 0 TO 3 LOOP
          delay(t_0) <= delay_next(t_0);
        END LOOP;

      END IF;
    END IF;
  END PROCESS align_oversamples_process;

  align_oversamples_output : PROCESS (delay, new_transition, oversampling_factor_unsigned, states_signed)
    VARIABLE omega2_reset : std_logic_vector(0 TO 3);
    VARIABLE omega3_reset : std_logic_vector(0 TO 3);
    VARIABLE omega4_reset : std_logic_vector(0 TO 3);
    VARIABLE omega2_target : unsigned(7 DOWNTO 0);
    VARIABLE omega3_target : unsigned(7 DOWNTO 0);
    VARIABLE omega4_target : unsigned(7 DOWNTO 0);
    VARIABLE y : std_logic;
    VARIABLE a : unsigned(15 DOWNTO 0);
    VARIABLE a_0 : unsigned(15 DOWNTO 0);
    VARIABLE delay_temp : std_logic_vector(0 TO 3);
    VARIABLE cast : unsigned(16 DOWNTO 0);
    VARIABLE mul_temp : unsigned(17 DOWNTO 0);
    VARIABLE sub_temp : unsigned(7 DOWNTO 0);
    VARIABLE cast_0 : signed(31 DOWNTO 0);
    VARIABLE sub_temp_0 : unsigned(7 DOWNTO 0);
    VARIABLE cast_1 : signed(31 DOWNTO 0);
    VARIABLE cast_2 : signed(31 DOWNTO 0);
    VARIABLE sub_temp_1 : unsigned(7 DOWNTO 0);
    VARIABLE cast_3 : signed(31 DOWNTO 0);
    VARIABLE cast_4 : signed(31 DOWNTO 0);
    VARIABLE cast_5 : signed(31 DOWNTO 0);
  BEGIN
    y := '0';
    a := to_unsigned(16#0000#, 16);
    a_0 := to_unsigned(16#0000#, 16);
    mul_temp := to_unsigned(16#00000#, 18);
    sub_temp := to_unsigned(16#00#, 8);
    sub_temp_0 := to_unsigned(16#00#, 8);
    sub_temp_1 := to_unsigned(16#00#, 8);
    omega4_target := to_unsigned(16#00#, 8);
    omega2_target := to_unsigned(16#00#, 8);
    omega3_target := to_unsigned(16#00#, 8);
    cast := to_unsigned(16#00000#, 17);
    cast_0 := to_signed(16#00000000#, 32);
    cast_1 := to_signed(16#00000000#, 32);
    cast_2 := to_signed(16#00000000#, 32);
    cast_3 := to_signed(16#00000000#, 32);
    cast_4 := to_signed(16#00000000#, 32);
    cast_5 := to_signed(16#00000000#, 32);

    FOR t_0 IN 0 TO 3 LOOP
      delay_temp(t_0) := delay(t_0);
    END LOOP;

    --MATLAB Function 'IncEnc_V25/speed/OS_factor_logic/align_oversamples'
    -- Fqint8 = fimath('RoundingMethod', 'Floor', 'OverflowAction', 'Wrap','ProductMode', 'SpecifyPrecision', 'ProductWordLength', 8,'ProductFractionLength',0,'SumMode','SpecifyPrecision','SumWordLength',8,'SumFractionLength',0);
    -- detect current ordering
    IF new_transition(0) = '1' THEN 
      -- omega_A updated
      --    %% change ordering
      --desired order when dir = +1: A, not B, not A, B => 1, 4, 3, 2
      --desired order when dir = -1: A, B, notA, not B  => 1, 2, 3, 4
      -- desired order = omega1=A, omega2, omega3, omega4

      FOR t_2 IN 0 TO 3 LOOP
        omega2_reset(t_2) := '0';
        omega3_reset(t_2) := '0';
        omega4_reset(t_2) := '0';
      END LOOP;

      omega2_reset(3) := '1';
      omega3_reset(2) := '1';
      omega4_reset(1) := '1';
      a := oversampling_factor_unsigned;
      cast := resize(a, 17);
      omega2_target := cast(8 DOWNTO 1) + ('0' & cast(0));
      a_0 := oversampling_factor_unsigned;
      -- CSD Encoding (3) : 011; Cost (Adders) = 1
      mul_temp := resize(a_0 & '0', 18) + resize(a_0, 18);
      omega3_target := mul_temp(9 DOWNTO 2) + ('0' & mul_temp(1));
      omega4_target := oversampling_factor_unsigned(7 DOWNTO 0);
      IF oversampling_factor_unsigned >= to_unsigned(16#00000002#, 16) THEN 
        y := '1';

        FOR k IN 0 TO 3 LOOP
          y := y AND ( NOT delay(k));
        END LOOP;

        IF y = '1' THEN 
          -- no delay active
          cast_2 := signed(resize(omega4_target, 32));
          IF resize(states_signed(1), 32) /= cast_2 THEN 

            FOR t_5 IN 0 TO 3 LOOP
              delay_temp(t_5) := omega4_reset(t_5);
            END LOOP;

          ELSE 
            cast_4 := signed(resize(omega3_target, 32));
            IF resize(states_signed(2), 32) /= cast_4 THEN 

              FOR t_8 IN 0 TO 3 LOOP
                delay_temp(t_8) := omega3_reset(t_8);
              END LOOP;

            ELSE 
              cast_5 := signed(resize(omega2_target, 32));
              IF resize(states_signed(3), 32) /= cast_5 THEN 

                FOR t_10 IN 0 TO 3 LOOP
                  delay_temp(t_10) := omega2_reset(t_10);
                END LOOP;

              ELSE 

                FOR t_7 IN 0 TO 3 LOOP
                  delay_temp(t_7) := '0';
                END LOOP;

                --final state is reached
              END IF;
            END IF;
          END IF;
        ELSE 
          -- a delay is already active
          sub_temp := omega4_target - 1;
          cast_0 := signed(resize(sub_temp, 32));
          IF delay(1) = '1' AND (resize(states_signed(1), 32) = cast_0) THEN 

            FOR t_4 IN 0 TO 3 LOOP
              delay_temp(t_4) := '0';
            END LOOP;

          ELSE 
            sub_temp_0 := omega3_target - 1;
            cast_1 := signed(resize(sub_temp_0, 32));
            IF delay(2) = '1' AND (resize(states_signed(2), 32) = cast_1) THEN 

              FOR t_6 IN 0 TO 3 LOOP
                delay_temp(t_6) := '0';
              END LOOP;

              --elseif(     isequal(delay, omega2_reset ) && (states(omega2) == (omega2_target-1) ) )
            ELSE 
              sub_temp_1 := omega2_target - 1;
              cast_3 := signed(resize(sub_temp_1, 32));
              IF delay(3) = '1' AND (resize(states_signed(3), 32) = cast_3) THEN 

                FOR t_9 IN 0 TO 3 LOOP
                  delay_temp(t_9) := '0';
                END LOOP;

              END IF;
            END IF;
          END IF;
        END IF;
      ELSE 

        FOR t_3 IN 0 TO 3 LOOP
          delay_temp(t_3) := '0';
        END LOOP;

      END IF;
    END IF;

    FOR t_1 IN 0 TO 3 LOOP
      delay_output(t_1) <= delay_temp(t_1);
      delay_next(t_1) <= delay_temp(t_1);
    END LOOP;

  END PROCESS align_oversamples_output;


END rtl;

