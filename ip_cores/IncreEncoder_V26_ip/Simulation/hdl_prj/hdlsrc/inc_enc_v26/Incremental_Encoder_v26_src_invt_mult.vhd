-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\inc_enc_v26\Incremental_Encoder_v26_src_invt_mult.vhd
-- Created: 2023-09-05 15:42:51
-- 
-- Generated by MATLAB 9.13 and HDL Coder 4.0
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Incremental_Encoder_v26_src_invt_mult
-- Source Path: inc_enc_v26/IncEnc_V26/speed1/calc_omega/invt_mult
-- Hierarchy Level: 3
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Incremental_Encoder_v26_src_IncEnc_V26_pac.ALL;

ENTITY Incremental_Encoder_v26_src_invt_mult IS
  PORT( clk                               :   IN    std_logic;
        reset_x                           :   IN    std_logic;
        enb_1_245467_0                    :   IN    std_logic;
        New_Measurement                   :   IN    std_logic;
        rps                               :   IN    std_logic_vector(37 DOWNTO 0);  -- sfix38_En32
        Oversampling_Factor               :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        omega_oversampled                 :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        New_Measurement_delayed           :   OUT   std_logic
        );
END Incremental_Encoder_v26_src_invt_mult;


ARCHITECTURE rtl OF Incremental_Encoder_v26_src_invt_mult IS

  -- Component Declarations
  COMPONENT Incremental_Encoder_v26_src_HDL_Reciprocal
    PORT( clk                             :   IN    std_logic;
          reset_x                         :   IN    std_logic;
          enb_1_245467_0                  :   IN    std_logic;
          din                             :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En18
          dout                            :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En12
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Incremental_Encoder_v26_src_HDL_Reciprocal
    USE ENTITY work.Incremental_Encoder_v26_src_HDL_Reciprocal(rtl);

  -- Signals
  SIGNAL rps_signed                       : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL rps_1                            : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL before_invert                    : signed(31 DOWNTO 0);  -- sfix32_En18
  SIGNAL after_invert                     : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL after_invert_signed              : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL after_invert_1                   : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL omega_OS_factor                  : signed(23 DOWNTO 0);  -- sfix24_En12
  SIGNAL Oversampling_Factor_unsigned     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Oversampling_Factor_1            : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL before_invert_1                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL rd_3_reg                         : vector_of_unsigned6(0 TO 7);  -- ufix6 [8]
  SIGNAL before_invert_2                  : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL Div_i1_cast                      : signed(6 DOWNTO 0);  -- sfix7
  SIGNAL Div_i1_mul_temp                  : signed(30 DOWNTO 0);  -- sfix31_En12
  SIGNAL omega_oversampled_1              : signed(29 DOWNTO 0);  -- sfix30_En12
  SIGNAL omega_oversampled_2              : signed(29 DOWNTO 0);  -- sfix30_En12
  SIGNAL omega_oversampled_3              : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL omega_oversampled_tmp            : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 10);  -- ufix1 [11]
  SIGNAL New_Measurement_1                : std_logic;

BEGIN
  -- At high speed, e.g. at 6000rpm, an steady-state error occurs of around 2.5rpm. I would need more iterrations in 
  -- the division to get it accurate
  -- However, i also tried to do a multiplication befor the division, so that the Oversampling factor do not gain the 
  -- steady-state error.
  -- But after a try, i still had a steady-state error, which was even bigger (3,2rpm). So i keep it so far. 
  -- However, the problem is not the fixed-point fromat. The problem is the number of itterations in the division!
  -- This applies for 3 iterations
  -- Invert 1/omega and muliply with synchronized oversampling factor

  u_HDL_Reciprocal : Incremental_Encoder_v26_src_HDL_Reciprocal
    PORT MAP( clk => clk,
              reset_x => reset_x,
              enb_1_245467_0 => enb_1_245467_0,
              din => std_logic_vector(before_invert),  -- sfix32_En18
              dout => after_invert  -- sfix32_En12
              );

  rps_signed <= signed(rps);

  in_1_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        rps_1 <= to_signed(0, 38);
      ELSIF enb_1_245467_0 = '1' THEN
        rps_1 <= rps_signed;
      END IF;
    END IF;
  END PROCESS in_1_pipe_process;


  before_invert <= resize(rps_1(37 DOWNTO 14), 32);

  after_invert_signed <= signed(after_invert);

  rd_0_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        after_invert_1 <= to_signed(0, 32);
      ELSIF enb_1_245467_0 = '1' THEN
        after_invert_1 <= after_invert_signed;
      END IF;
    END IF;
  END PROCESS rd_0_process;


  omega_OS_factor <= after_invert_1(23 DOWNTO 0);

  Oversampling_Factor_unsigned <= unsigned(Oversampling_Factor);

  rd_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        Oversampling_Factor_1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_245467_0 = '1' THEN
        Oversampling_Factor_1 <= Oversampling_Factor_unsigned;
      END IF;
    END IF;
  END PROCESS rd_1_process;


  before_invert_1 <= Oversampling_Factor_1(5 DOWNTO 0);

  rd_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        rd_3_reg <= (OTHERS => to_unsigned(16#00#, 6));
      ELSIF enb_1_245467_0 = '1' THEN
        rd_3_reg(0) <= before_invert_1;
        rd_3_reg(1 TO 7) <= rd_3_reg(0 TO 6);
      END IF;
    END IF;
  END PROCESS rd_3_process;

  before_invert_2 <= rd_3_reg(7);

  Div_i1_cast <= signed(resize(before_invert_2, 7));
  Div_i1_mul_temp <= omega_OS_factor * Div_i1_cast;
  omega_oversampled_1 <= Div_i1_mul_temp(29 DOWNTO 0);

  rd_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        omega_oversampled_2 <= to_signed(16#00000000#, 30);
      ELSIF enb_1_245467_0 = '1' THEN
        omega_oversampled_2 <= omega_oversampled_1;
      END IF;
    END IF;
  END PROCESS rd_4_process;


  
  omega_oversampled_3 <= X"7FFFFF" WHEN (omega_oversampled_2(29) = '0') AND (omega_oversampled_2(28 DOWNTO 24) /= "00000") ELSE
      X"800000" WHEN (omega_oversampled_2(29) = '1') AND (omega_oversampled_2(28 DOWNTO 24) /= "11111") ELSE
      omega_oversampled_2(24 DOWNTO 1);

  rd_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        omega_oversampled_tmp <= to_signed(16#000000#, 24);
      ELSIF enb_1_245467_0 = '1' THEN
        omega_oversampled_tmp <= omega_oversampled_3;
      END IF;
    END IF;
  END PROCESS rd_2_process;


  omega_oversampled <= std_logic_vector(omega_oversampled_tmp);

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset_x = '1' THEN
        delayMatch_reg <= (OTHERS => '0');
      ELSIF enb_1_245467_0 = '1' THEN
        delayMatch_reg(0) <= New_Measurement;
        delayMatch_reg(1 TO 10) <= delayMatch_reg(0 TO 9);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  New_Measurement_1 <= delayMatch_reg(10);

  New_Measurement_delayed <= New_Measurement_1;

END rtl;

