.. _unit_tests:

==========
Unit tests
==========

The software of the R5 uses unit tests.
Unit tests make sure that the code works as expected.
Unit tests are short and focused on a specific software module, e.g., testing one translation unit (``.c file``).
They state how the software ought to behave and tests if it does.
These tests are run on the local developer machine instead of a UltraZohm.
Unit tests do not test the complete system and verified that it works (that is system & integration test) but makes sure that individual modules work, i.e., all the small things.

We use the four-phase test pattern [#TDD]_ (p. 25):

- Setup: Establish the preconditions on the test
- Exercise: Do something to the system
- Verify: Check the expected outcome
- Cleanup: Return the system under test to its initial state

Out test framework is `Ceedling <https://github.com/ThrowTheSwitch/Ceedling>`_.
Ceedling simplifies the usage of `Unity <https://github.com/throwtheswitch/unity>`_ (the actual testing framework) `Cmock <https://github.com/throwtheswitch/cmock`>_ (used for generating mocks).
The unit tests are located in ``vitis/software/Baremetal/``.
The folder ``src`` holds the software that is tested and used when programming the UltraZohm with Vitis.
The other folders hold auxiliary files for the test suite.
The file ``project.yml`` holds the configuration for Ceedling.

::

    ultrazohm_sw/
    └── vitis/
        └── software/
            ├── Baremetal/
            |    ├── build
            |    ├── src
            |    ├── support
            |    ├── test
            |    └── project.yml
            ├── FreeRTOS
            └── FSBL

More information:

- `CMock summary <https://github.com/ThrowTheSwitch/CMock/blob/master/docs/CMock_Summary.md>`_
- `Add unit tests to your current project with Ceedling (Blogpost) <http://www.electronvector.com/blog/add-unit-tests-to-your-current-project-with-ceedling>`_
- `Ceedling homepage <http://www.throwtheswitch.org/ceedling>`_
- `Introduction video <http://www.electronvector.com/blog/getting-started-with-ceedling-creating-a-new-project0>`_
- `More videos <https://vimeo.com/user27428789>`_


Run Tests from CLI
==================

In a terminal with the path ``ultrazohm_sw/vitis/software/Baremetal``:

::

  ceedling test:all

Create a new module
===================

In a terminal with the path ``ultrazohm_sw/vitis/software/Baremetal``:

::

  ceedling module:create[path/name]

With ``path`` being the path in which the new module should be created relative to ``Baremetal/src`` directory and ``name`` the name of the module.
Example: 

::

  ceedling module:create[IP_Cores/uz_myIP/uz_myIP]

Creates the files ``uz_myIP.c`` and ``uz_myIP.h`` in ``ultrazohm_sw/vitis/software/Baremetal/src/IP_Cores/uz_myIP/`` and ``test_uz_myIP.c`` in ``ultrazohm_sw/vitis/software/Baremetal/test/IP_Cores/uz_myIP/``.
Note that this also works if some of these files already exist.

Example test
============

Line 1-3 of :ref:`test-example-header` are automatically generated by Ceedling/Unity.
Line 4 is added manually.
The prefix ``mock_`` tells Ceedling to automatically generate mocked versions of the functions defined in ``uz_AXI.h``.
These mocked versions can be called with the prefix ``_Expect`` and ``_ExpectAndReturn`` to state that these functions are expected to be called from the function under test with the specified arguments and return the defined value if called with these arguments.
See `Cmock docs <https://github.com/ThrowTheSwitch/CMock/blob/master/docs/CMock_Summary.md>`_ for more information.

.. code-block:: c
   :linenos:
   :name: test-example-header
   :caption: Include section of test
   
   #include "unity.h"
   #include <stdint.h>
   #include "uz_axiTestIP2_hw.h"
   #include "mock_uz_AXI.h"
   #define base_address 0x0000000F

:ref:`simple-test-expect` uses the automatically generated mock function ``uz_axi_write_int32_Expect`` to indicate that in this test, the function ``uz_axiTestIP2_hw_write_A_int32`` has to call ``uz_axi_write_int32`` with the specified arguments. If the function is not called or other arguments are passed to ``uz_axi_write_int32`` from ``uz_axiTestIP2_hw_write_A_int32`` the test will fail.
Note that the function ``uz_axi_write_int32`` expects a call with the sum of base address and offset for the specific axi register, i.e., ``uz_axiTestIP2_hw_write_A_int32`` has to add the right offset.

.. code-block:: c
    :linenos:
    :name: simple-test-expect
    :caption: Simple test with expected call

    void test_uz_axiTestIP2_hw_write_to_A_int32(void)
    {
        int a=10;
        uz_axi_write_int32_Expect(base_address+A_int32_Data_uz_axi_testIP, a);
        uz_axiTestIP2_hw_write_A_int32(base_address,a);
    }

:ref:`test-expect-return` shows a test that involves a return value. 

.. code-block:: c
   :linenos:
   :name: test-expect-return
   :caption: Test with readback and ASSERT_EQUAL
    
   void test_uz_axiTestIP2_hw_read_C_int32(void)
   {
       int a=20;
       int b=-10;
       uz_axi_read_int32_ExpectAndReturn(base_address+C_int32_Data_uz_axi_testIP,a*b);
       int c=uz_axiTestIP2_hw_read_C_int32(base_address);
       TEST_ASSERT_EQUAL_INT(a*b,c);
   }

.. note:: These tests rely on the usage of the HAL functions and HAL AXi read/write functions.

.. warning:: The unit test for IP-core drivers *only* test if the software works as intended, dedicated testing for the actual hardware of the IP-core is assumed here! The example above tests if the software driver reads and writes the correct registers but the function of the IP-core itself (the multiplication) is not tested by this unit test. 


Testing assertions
==================

:ref:`assertions` are used in the UltraZohm project to protect form programming errors such as calling functions with arguments that are out of range or passing ``NULL`` pointers.

- Include the test macros for the assertions in the test file (``#include "test_assert_with_exception.h``)
- Use the test macro ``TEST_ASSERT_FAIL_ASSERT`` to test if a assert fails.
- Use the test macro ``TEST_ASSERT_PASS_ASSERT`` to test if a assert passes.
- Both function calls should cause an assert fo fail due to calling it with a ``NULL`` pointer and an pointer to an uninitialized instance (``is_ready`` is ``false`` in the second call). Example:

.. code-block:: c

   TEST_ASSERT_FAIL_ASSERT(uz_axiTestIP2_multiply(NULL, a,b));
   uz_axiTestIP2 test_instance2={
       .base_address=TEST_BASE_ADDRESS  
   };
   uz_axiTestIP2* testptr=&test_instance2;
   TEST_ASSERT_FAIL_ASSERT(uz_axiTestIP2_multiply(testptr, a,b));

Implementation details
----------------------

To test if assertions we use the following approach:

- http://www.electronvector.com/blog/unit-testing-with-asserts
- Use ``CException <https://github.com/ThrowTheSwitch/CException>``_ while testing (``:use_exceptions: TRUE`` in Ceedling ``project.yml``)
- Defined ``uz_assert`` in the following way in ``uz_HAL.h`` for testing.

.. code-block:: c

   #include "CException.h"
   #define uz_assert(condition) if (!(condition)) Throw(0)

This means a failing assertions throws an exception instead of triggering a *real* assert.
The test macros ``TEST_ASSERT_FAIL_ASSERT`` and ``TEST_ASSERT_PASS_ASSERT`` catch the thrown exception and print a error message if the test fails.

Sources
=======

.. [#TDD] Test-Driven Development for Embedded C, James W. Grenning, 2011
