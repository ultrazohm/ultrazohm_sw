-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\uz_mpc_cost_and_optim_state_machine\uz_6ph_cost_ip_src_Sqrt_iv.vhd
-- Created: 2022-09-20 09:58:30
-- 
-- Generated by MATLAB 9.10 and HDL Coder 3.18
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: uz_6ph_cost_ip_src_Sqrt_iv
-- Source Path: uz_mpc_cost_and_optim_state_machine/uz_6ph_mpc_costs_and_optimization/Sqrt/Sqrt_iv
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY uz_6ph_cost_ip_src_Sqrt_iv IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_3_1_0                         :   IN    std_logic;
        ain                               :   IN    std_logic_vector(27 DOWNTO 0);  -- ufix28_En28
        sel                               :   IN    std_logic_vector(1 DOWNTO 0);  -- ufix2
        xinit                             :   OUT   std_logic_vector(53 DOWNTO 0);  -- sfix54_En49
        inzero                            :   OUT   std_logic  -- ufix1
        );
END uz_6ph_cost_ip_src_Sqrt_iv;


ARCHITECTURE rtl OF uz_6ph_cost_ip_src_Sqrt_iv IS

  -- Signals
  SIGNAL sel_unsigned                     : unsigned(1 DOWNTO 0);  -- ufix2
  SIGNAL constA                           : signed(55 DOWNTO 0);  -- sfix56_En52
  SIGNAL ain_unsigned                     : unsigned(27 DOWNTO 0);  -- ufix28_En28
  SIGNAL constC                           : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL constB                           : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL mmuxout                          : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL delayout                         : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL delaymul                         : signed(55 DOWNTO 0);  -- sfix56_En52
  SIGNAL mmuxout_1                        : signed(55 DOWNTO 0);  -- sfix56_En52
  SIGNAL mul_cast                         : signed(28 DOWNTO 0);  -- sfix29_En28
  SIGNAL mul_mul_temp                     : signed(84 DOWNTO 0);  -- sfix85_En80
  SIGNAL mul_cast_1                       : signed(83 DOWNTO 0);  -- sfix84_En80
  SIGNAL mulout                           : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL sumout                           : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL xinit_tmp                        : signed(53 DOWNTO 0);  -- sfix54_En49
  SIGNAL mstwobit                         : unsigned(1 DOWNTO 0);  -- ufix2

BEGIN
  -- Polynomial initial value stage of the RecipSqrt Implementation using Newton Method

  sel_unsigned <= unsigned(sel);

  constA <= signed'(X"197DBFC2AAFDE8");

  ain_unsigned <= unsigned(ain);

  constC <= signed'("000101010000000101011101001111100110000010000000101000");

  constB <= signed'("111001101000101000001110110000111111000011101000111110");

  
  mmuxout <= constC WHEN sel_unsigned = to_unsigned(16#1#, 2) ELSE
      constB;

  delaymul <= delayout(52 DOWNTO 0) & '0' & '0' & '0';

  
  mmuxout_1 <= delaymul WHEN sel_unsigned = to_unsigned(16#1#, 2) ELSE
      constA;

  mul_cast <= signed(resize(ain_unsigned, 29));
  mul_mul_temp <= mmuxout_1 * mul_cast;
  mul_cast_1 <= mul_mul_temp(83 DOWNTO 0);
  mulout <= resize(mul_cast_1(83 DOWNTO 31), 54);

  sumout <= mulout + mmuxout;

  reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayout <= to_signed(0, 54);
      ELSIF enb_3_1_0 = '1' THEN
        delayout <= sumout;
      END IF;
    END IF;
  END PROCESS reg_process;


  xinit_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        xinit_tmp <= to_signed(0, 54);
      ELSIF enb = '1' THEN
        xinit_tmp <= delayout;
      END IF;
    END IF;
  END PROCESS xinit_reg_process;


  xinit <= std_logic_vector(xinit_tmp);

  mstwobit <= ain_unsigned(27 DOWNTO 26);

  
  inzero <= '1' WHEN mstwobit = to_unsigned(16#0#, 2) ELSE
      '0';

END rtl;

