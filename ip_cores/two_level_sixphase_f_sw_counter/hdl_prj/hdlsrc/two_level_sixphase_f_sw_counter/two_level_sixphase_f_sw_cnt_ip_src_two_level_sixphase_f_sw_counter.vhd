-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\two_level_sixphase_f_sw_counter\two_level_sixphase_f_sw_cnt_ip_src_two_level_sixphase_f_sw_counter.vhd
-- Created: 2023-01-05 11:03:28
-- 
-- Generated by MATLAB 9.10 and HDL Coder 3.18
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1e-08
-- Target subsystem base rate: 1e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- switchNumb_AXI                ce_out        1e-08
-- switchNumb                    ce_out        1e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: two_level_sixphase_f_sw_cnt_ip_src_two_level_sixphase_f_sw_counter
-- Source Path: two_level_sixphase_f_sw_counter/two_level_sixphase_f_sw_counter
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY two_level_sixphase_f_sw_cnt_ip_src_two_level_sixphase_f_sw_counter IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        ss_in_0                           :   IN    std_logic;
        ss_in_1                           :   IN    std_logic;
        ss_in_2                           :   IN    std_logic;
        ss_in_3                           :   IN    std_logic;
        ss_in_4                           :   IN    std_logic;
        ss_in_5                           :   IN    std_logic;
        ss_in_6                           :   IN    std_logic;
        ss_in_7                           :   IN    std_logic;
        ss_in_8                           :   IN    std_logic;
        ss_in_9                           :   IN    std_logic;
        ss_in_10                          :   IN    std_logic;
        ss_in_11                          :   IN    std_logic;
        bResetAXI                         :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        switchNumb_AXI                    :   OUT   std_logic_vector(24 DOWNTO 0);  -- ufix25
        switchNumb                        :   OUT   std_logic_vector(24 DOWNTO 0)  -- ufix25
        );
END two_level_sixphase_f_sw_cnt_ip_src_two_level_sixphase_f_sw_counter;


ARCHITECTURE rtl OF two_level_sixphase_f_sw_cnt_ip_src_two_level_sixphase_f_sw_counter IS

  -- Component Declarations
  COMPONENT two_level_sixphase_f_sw_cnt_ip_src_Count_f_sw
    PORT( switchNumb                      :   IN    std_logic_vector(24 DOWNTO 0);  -- ufix25
          ss_v_old                        :   IN    std_logic_vector(0 TO 11);  -- boolean [12]
          ss_v                            :   IN    std_logic_vector(0 TO 11);  -- boolean [12]
          bReset                          :   IN    std_logic;  -- ufix1
          switchNumbOut                   :   OUT   std_logic_vector(24 DOWNTO 0)  -- ufix25
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : two_level_sixphase_f_sw_cnt_ip_src_Count_f_sw
    USE ENTITY work.two_level_sixphase_f_sw_cnt_ip_src_Count_f_sw(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL Mux2_out1                        : std_logic_vector(0 TO 11);  -- boolean [12]
  SIGNAL SS_Old_out1                      : std_logic_vector(0 TO 11);  -- boolean [12]
  SIGNAL alpha1_for_one_cycle_if_edge_recognized : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old2_out1                  : std_logic;
  SIGNAL reset_old_switch1_out1           : std_logic;
  SIGNAL Detec_edge_sub_cast              : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge_sub_cast_1            : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL dtc_out                          : std_logic;  -- ufix1
  SIGNAL Saturation_out1                  : std_logic;  -- ufix1
  SIGNAL switchNumbOut                    : std_logic_vector(24 DOWNTO 0);  -- ufix25
  SIGNAL switchNumbOut_unsigned           : unsigned(24 DOWNTO 0);  -- ufix25
  SIGNAL delay_out1                       : unsigned(24 DOWNTO 0);  -- ufix25

BEGIN
  -- To avoid unneccessary calcualtions, i divide by 24 on the ARM processor.
  -- 
  -- 1 for one cycle if edge recognized
  -- 
  -- Over AXI, 32 Bit are received.
  -- However, only one Bit is used.
  -- 
  -- Since i count now every On and Off Transition for each switch,
  -- i have to divide by 12*2 in order to get the switching frequency
  -- (after dividing by the time).
  -- 12 comes from the 12 switches
  -- 2 comes from that 1 ON-transition and 1 OFF-transition = 1 switching-cycle

  u_Count_f_sw : two_level_sixphase_f_sw_cnt_ip_src_Count_f_sw
    PORT MAP( switchNumb => std_logic_vector(delay_out1),  -- ufix25
              ss_v_old => SS_Old_out1,  -- boolean [12]
              ss_v => Mux2_out1,  -- boolean [12]
              bReset => Saturation_out1,  -- ufix1
              switchNumbOut => switchNumbOut  -- ufix25
              );

  enb <= clk_enable;

  Mux2_out1(0) <= ss_in_0;
  Mux2_out1(1) <= ss_in_1;
  Mux2_out1(2) <= ss_in_2;
  Mux2_out1(3) <= ss_in_3;
  Mux2_out1(4) <= ss_in_4;
  Mux2_out1(5) <= ss_in_5;
  Mux2_out1(6) <= ss_in_6;
  Mux2_out1(7) <= ss_in_7;
  Mux2_out1(8) <= ss_in_8;
  Mux2_out1(9) <= ss_in_9;
  Mux2_out1(10) <= ss_in_10;
  Mux2_out1(11) <= ss_in_11;

  SS_Old_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        SS_Old_out1 <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        SS_Old_out1 <= Mux2_out1;
      END IF;
    END IF;
  END PROCESS SS_Old_process;


  
  reset_old_switch1_out1 <= reset_old2_out1 WHEN alpha1_for_one_cycle_if_edge_recognized = to_signed(16#00#, 8) ELSE
      bResetAXI;

  reset_old2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old2_out1 <= '0';
      ELSIF enb = '1' THEN
        reset_old2_out1 <= reset_old_switch1_out1;
      END IF;
    END IF;
  END PROCESS reset_old2_process;


  Detec_edge_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & bResetAXI;
  Detec_edge_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old2_out1;
  alpha1_for_one_cycle_if_edge_recognized <= Detec_edge_sub_cast - Detec_edge_sub_cast_1;

  
  dtc_out <= '1' WHEN (alpha1_for_one_cycle_if_edge_recognized(7) = '0') AND (alpha1_for_one_cycle_if_edge_recognized(6 DOWNTO 1) /= "000000") ELSE
      '0' WHEN alpha1_for_one_cycle_if_edge_recognized(7) = '1' ELSE
      alpha1_for_one_cycle_if_edge_recognized(0);

  Saturation_out1 <= dtc_out;

  switchNumbOut_unsigned <= unsigned(switchNumbOut);

  delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delay_out1 <= to_unsigned(16#0000000#, 25);
      ELSIF enb = '1' THEN
        delay_out1 <= switchNumbOut_unsigned;
      END IF;
    END IF;
  END PROCESS delay_process;


  ce_out <= clk_enable;

  switchNumb_AXI <= switchNumbOut;

  switchNumb <= switchNumbOut;

END rtl;

