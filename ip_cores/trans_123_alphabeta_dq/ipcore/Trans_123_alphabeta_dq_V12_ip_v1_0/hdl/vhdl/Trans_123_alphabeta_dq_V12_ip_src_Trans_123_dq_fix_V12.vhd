-- -------------------------------------------------------------
-- 
-- File Name: C:\ultrazohm_sw\ip_cores\trans_123_alphabeta_dq\hdlsrc\trans_123_alphabeta_dq_V1\Trans_123_alphabeta_dq_V12_ip_src_Trans_123_dq_fix_V12.vhd
-- Created: 2022-06-03 10:45:00
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 2e-08
-- Target subsystem base rate: 2e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- id                            ce_out        2e-08
-- iq                            ce_out        2e-08
-- id_AXI                        ce_out        2e-08
-- iq_AXI                        ce_out        2e-08
-- dq_Done                       ce_out        2e-08
-- sin                           ce_out        2e-08
-- cos                           ce_out        2e-08
-- i1_AXI                        ce_out        2e-08
-- i2_AXI                        ce_out        2e-08
-- i3_AXI                        ce_out        2e-08
-- ialpha                        ce_out        2e-08
-- ialpha_AXI                    ce_out        2e-08
-- ibeta                         ce_out        2e-08
-- ibeta_AXI                     ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Trans_123_alphabeta_dq_V12_ip_src_Trans_123_dq_fix_V12
-- Source Path: trans_123_alphabeta_dq_V1/Trans_123_dq_fix_V12
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.Trans_123_alphabeta_dq_V12_ip_src_Trans_123_dq_fix_V12_pkg.ALL;

ENTITY Trans_123_alphabeta_dq_V12_ip_src_Trans_123_dq_fix_V12 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        i_ph1                             :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i_ph2                             :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i_ph3                             :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        theta                             :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        theta_offset_AXI                  :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        CurrentValid_in                   :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        id                                :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        iq                                :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        id_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        iq_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        dq_Done                           :   OUT   std_logic;
        sin                               :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        cos                               :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
        i1_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i2_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        i3_AXI                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        ialpha                            :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        ialpha_AXI                        :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        ibeta                             :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En11
        ibeta_AXI                         :   OUT   std_logic_vector(17 DOWNTO 0)  -- sfix18_En11
        );
END Trans_123_alphabeta_dq_V12_ip_src_Trans_123_dq_fix_V12;


ARCHITECTURE rtl OF Trans_123_alphabeta_dq_V12_ip_src_Trans_123_dq_fix_V12 IS

  -- Component Declarations
  COMPONENT Trans_123_alphabeta_dq_V12_ip_src_Cosine
    PORT( u                               :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
          sin_2_pi_u                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          cos_2_pi_u                      :   OUT   std_logic_vector(15 DOWNTO 0)  -- sfix16_En14
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Trans_123_alphabeta_dq_V12_ip_src_Cosine
    USE ENTITY work.Trans_123_alphabeta_dq_V12_ip_src_Cosine(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL CurrentValid_in_1                : std_logic;
  SIGNAL stateControl_1                   : std_logic;
  SIGNAL stateControl_2                   : std_logic;
  SIGNAL enb_gated                        : std_logic;
  SIGNAL alpha1_for_one_cycle_if_edge_recognized : signed(7 DOWNTO 0);  -- int8
  SIGNAL reset_old2_out1                  : std_logic;
  SIGNAL reset_old_switch1_out1           : std_logic;
  SIGNAL Detec_edge_sub_cast              : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Detec_edge_sub_cast_1            : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL alpha1_for_one_cycle_if_edge_recognized_1 : signed(7 DOWNTO 0);  -- int8
  SIGNAL dtc_out                          : std_logic;  -- ufix1
  SIGNAL Saturation_out1                  : std_logic;  -- ufix1
  SIGNAL DelayValue3_out1                 : std_logic;  -- ufix1
  SIGNAL Data_Type_Conversion1_out1       : signed(7 DOWNTO 0);  -- int8
  SIGNAL Second_value                     : std_logic;  -- ufix1
  SIGNAL Data_Type_Conversion2_out1       : signed(7 DOWNTO 0);  -- int8
  SIGNAL Gain_out1                        : signed(15 DOWNTO 0);  -- sfix16_En5
  SIGNAL Add4_add_cast                    : signed(7 DOWNTO 0);  -- sfix8
  SIGNAL Switch                           : signed(7 DOWNTO 0);  -- int8
  SIGNAL id1_Enable                       : std_logic;
  SIGNAL delayMatch13_reg                 : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL id1_Enable_1                     : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL stateControl_3                   : std_logic;
  SIGNAL delayMatch14_reg                 : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL stateControl_4                   : std_logic;
  SIGNAL enb_gated_1                      : std_logic;
  SIGNAL switch_compare_1_1               : std_logic;
  SIGNAL stateControl_5                   : std_logic;
  SIGNAL stateControl_6                   : std_logic;
  SIGNAL enb_gated_2                      : std_logic;
  SIGNAL i_ph2_signed                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL i_ph2_1                          : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on3_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay4_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain1_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En28
  SIGNAL Gain1_factor                     : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain1_factor_1                   : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain1_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL switch_compare_1_2               : std_logic;
  SIGNAL stateControl_7                   : std_logic;
  SIGNAL stateControl_8                   : std_logic;
  SIGNAL enb_gated_3                      : std_logic;
  SIGNAL i_ph3_signed                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL i_ph3_1                          : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on4_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay5_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain2_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En28
  SIGNAL Gain2_factor                     : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain2_factor_1                   : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain2_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL AddBeta_out1                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL DelayValue2_out1                 : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL switch_compare_1_3               : std_logic;
  SIGNAL stateControl_9                   : std_logic;
  SIGNAL stateControl_10                  : std_logic;
  SIGNAL enb_gated_4                      : std_logic;
  SIGNAL i_ph1_signed                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL i_ph1_1                          : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_on2_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay2_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain6_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En28
  SIGNAL Gain6_factor                     : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain6_factor_1                   : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain6_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain4_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En29
  SIGNAL Gain4_factor                     : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain4_factor_1                   : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain4_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL AddAlpha_op_stage1               : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain5_mul_temp                   : signed(35 DOWNTO 0);  -- sfix36_En29
  SIGNAL Gain5_factor                     : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain5_factor_1                   : signed(35 DOWNTO 0);  -- sfix36
  SIGNAL Gain5_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL AddAlpha_out1                    : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Gain7_cast                       : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL Gain7_cast_1                     : signed(18 DOWNTO 0);  -- sfix19_En11
  SIGNAL Gain7_cast_2                     : signed(35 DOWNTO 0);  -- sfix36_En28
  SIGNAL Gain7_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL DelayValue4_out1                 : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL stateControl_11                  : std_logic;
  SIGNAL stateControl_12                  : std_logic;
  SIGNAL enb_gated_5                      : std_logic;
  SIGNAL Switch_id_out1                   : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay22_out1                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL delayMatch8_reg                  : vector_of_signed18(0 TO 3);  -- sfix18 [4]
  SIGNAL Switch_id_out1_1                 : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL reduced_reg                      : std_logic_vector(0 TO 3);  -- ufix1 [4]
  SIGNAL Saturation_out1_1                : std_logic;  -- ufix1
  SIGNAL switch_compare_1_4               : std_logic;
  SIGNAL stateControl_13                  : std_logic;
  SIGNAL delayMatch7_reg                  : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL stateControl_14                  : std_logic;
  SIGNAL enb_gated_6                      : std_logic;
  SIGNAL theta_signed                     : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL theta_1                          : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL theta_offset_AXI_signed          : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL theta_offset_AXI_1               : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add1_out1                        : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add1_out1_1                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Compare_Limit_Low_out1           : std_logic;
  SIGNAL Compare_Limit_High_out1          : std_logic;
  SIGNAL Compare_Limit_High_out1_1        : std_logic;
  SIGNAL switch_compare_1_5               : std_logic;
  SIGNAL Add1_out1_2                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Constant_out1                    : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add2_out1                        : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Compare_Limit_Low_out1_1         : std_logic;
  SIGNAL switch_compare_1_6               : std_logic;
  SIGNAL Add2_out1_1                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Switch_Limit_High_out1           : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Constant1_out1                   : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add3_out1                        : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Add3_out1_1                      : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Switch_Limit_Low_out1            : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL ScaleTheta_mul_temp              : signed(47 DOWNTO 0);  -- sfix48_En45
  SIGNAL ScaleTheta_out1                  : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL ScaleTheta_out1_1                : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL Cosine_out1                      : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Cosine_out2                      : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Cosine_out1_signed               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Cosine_out1_1                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_on7_out1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay7_out1                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL sin1_mul_temp                    : signed(33 DOWNTO 0);  -- sfix34_En25
  SIGNAL sin1_out1                        : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL DelayValue1_out1                 : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL stateControl_15                  : std_logic;
  SIGNAL stateControl_16                  : std_logic;
  SIGNAL enb_gated_7                      : std_logic;
  SIGNAL Switch_id1_out1                  : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay1_out1                      : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL delayMatch12_reg                 : vector_of_signed18(0 TO 3);  -- sfix18 [4]
  SIGNAL Switch_id1_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL switch_compare_1_7               : std_logic;
  SIGNAL stateControl_17                  : std_logic;
  SIGNAL delayMatch11_reg                 : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL stateControl_18                  : std_logic;
  SIGNAL enb_gated_8                      : std_logic;
  SIGNAL Cosine_out2_signed               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Cosine_out2_1                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Switch_on1_out1                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Delay3_out1                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL cos1_mul_temp                    : signed(33 DOWNTO 0);  -- sfix34_En25
  SIGNAL cos1_out1                        : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Add_1_out1                       : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_idpred1_out1              : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay10_out1                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_idpred1_out1_1            : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL delayMatch15_reg                 : vector_of_signed8(0 TO 3);  -- sfix8 [4]
  SIGNAL Switch_1                         : signed(7 DOWNTO 0);  -- int8
  SIGNAL switch_compare_1_8               : std_logic;
  SIGNAL stateControl_19                  : std_logic;
  SIGNAL delayMatch16_reg                 : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL stateControl_20                  : std_logic;
  SIGNAL enb_gated_9                      : std_logic;
  SIGNAL Switch_idpred2_out1              : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Delay16_out1                     : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL Switch_idpred2_out1_1            : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL DelayValid_reg                   : std_logic_vector(0 TO 1);  -- ufix1 [2]
  SIGNAL End_Cycle                        : std_logic;  -- ufix1
  SIGNAL shift6_out1                      : std_logic;  -- ufix1
  SIGNAL shift1_out1                      : std_logic;  -- ufix1
  SIGNAL shift2_out1                      : std_logic;  -- ufix1
  SIGNAL shift3_out1                      : std_logic;  -- ufix1
  SIGNAL Logical_Operator_out1            : std_logic;
  SIGNAL delayMatch17_reg                 : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL Logical_Operator_out1_1          : std_logic;
  SIGNAL Cosine_out1_2                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Cosine_out2_2                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL delayMatch18_reg                 : vector_of_signed18(0 TO 4);  -- sfix18 [5]
  SIGNAL Switch_on2_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL delayMatch19_reg                 : vector_of_signed18(0 TO 4);  -- sfix18 [5]
  SIGNAL Switch_on3_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL delayMatch20_reg                 : vector_of_signed18(0 TO 4);  -- sfix18 [5]
  SIGNAL Switch_on4_out1_1                : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL reduced_reg_1                    : vector_of_signed18(0 TO 4);  -- sfix18 [5]
  SIGNAL DelayValue1_out1_1               : signed(17 DOWNTO 0);  -- sfix18_En11
  SIGNAL reduced_reg_2                    : vector_of_signed18(0 TO 4);  -- sfix18 [5]
  SIGNAL DelayValue2_out1_1               : signed(17 DOWNTO 0);  -- sfix18_En11

BEGIN
  -- Delay to compensate the 1 pipeline before the multiplication.
  -- 1 Pipeline for the second repeating.
  -- 
  -- cosine -> Nur Look-Up,
  -- keine Multiplikatoren
  -- verwendet
  -- 
  -- - Ich lass den ganzen IP Core mit einem langsameren Clock laufen, 
  --  damit ich keine Timingverletzung durch die Trigonometrische 
  --  Funktion in Vivado bekomme.
  -- - Dadurch das ich unnütze Pipeline Stages einspare, sollte 
  --  die notwendige Gesamtzeit konstant bleiben.
  -- - Der cosine braucht bei (2^7)+1 circa 24ns Durchlaufzeit.
  -- - Zwischen (2^7)+1 und (2^13)+1 macht die Genauigkeit Sinn. Je mehr Bits
  --  desto Genauer, aber desto längere Durchlaufzeiten habe ich als auch mehr
  --   Ressourcen brauche ich. (Habe mich aktuell für (2^9)+1 entschieden.
  -- 
  -- Durch den Delay von 5, wird ab erkennen der Flanke,
  -- das Signal für 5 Takte high bleiben.
  -- Hierdurch kann man die Impuls Länge des Enables einstellen.
  -- Da ich diesen IP-Core mit 25MHz laufen lasse, bedeuten 5 Delays -> 20 Clocks at 100MHz
  -- 
  -- 1 for one cycle if edge recognized
  -- 
  -- Wir brauchen hier auf jeden Fall 4 Taktzyklen-Flag (@100MHz),
  -- damit ich es mit dem 25MHZ IP-Core sicher erkennen kann. Das hab 
  -- ich aber, da die Strommessung mit "CurrentValid" ein sehr langes Flag
  -- (345 Takte @100MHz) ausgibt!
  -- 
  -- Because of the subsequent VoltageVectors runs with 25MHz and this
  -- IP Core also runs with 25MHz, we need a DONE-Flag for at least 1 cycle.
  -- Now, since this block runs at 25MHz, i have 20 cycles (at 100MHz) in order
  -- to connect this dq-transformation also with other, slower, IP Cores such as
  -- FOC.
  -- 
  -- Threshold = 1
  -- 
  -- Threshold = 2

  u_Cosine : Trans_123_alphabeta_dq_V12_ip_src_Cosine
    PORT MAP( u => std_logic_vector(ScaleTheta_out1_1),  -- sfix24_En20
              sin_2_pi_u => Cosine_out1,  -- sfix16_En14
              cos_2_pi_u => Cosine_out2  -- sfix16_En14
              );

  enb <= clk_enable;

  in_5_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        CurrentValid_in_1 <= '0';
      ELSIF enb = '1' THEN
        CurrentValid_in_1 <= CurrentValid_in;
      END IF;
    END IF;
  END PROCESS in_5_pipe_process;


  stateControl_1 <= '1';

  delayMatch_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        stateControl_2 <= '0';
      ELSIF enb = '1' THEN
        stateControl_2 <= stateControl_1;
      END IF;
    END IF;
  END PROCESS delayMatch_process;


  enb_gated <= stateControl_2 AND clk_enable;

  
  reset_old_switch1_out1 <= reset_old2_out1 WHEN alpha1_for_one_cycle_if_edge_recognized = to_signed(16#00#, 8) ELSE
      CurrentValid_in_1;

  reset_old2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reset_old2_out1 <= '0';
      ELSIF enb_gated = '1' THEN
        reset_old2_out1 <= reset_old_switch1_out1;
      END IF;
    END IF;
  END PROCESS reset_old2_process;


  Detec_edge_sub_cast <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & CurrentValid_in_1;
  Detec_edge_sub_cast_1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & reset_old2_out1;
  alpha1_for_one_cycle_if_edge_recognized <= Detec_edge_sub_cast - Detec_edge_sub_cast_1;

  alpha1_for_one_cycle_if_edge_recognized_1 <= alpha1_for_one_cycle_if_edge_recognized;

  
  dtc_out <= '1' WHEN (alpha1_for_one_cycle_if_edge_recognized_1(7) = '0') AND (alpha1_for_one_cycle_if_edge_recognized_1(6 DOWNTO 1) /= "000000") ELSE
      '0' WHEN alpha1_for_one_cycle_if_edge_recognized_1(7) = '1' ELSE
      alpha1_for_one_cycle_if_edge_recognized_1(0);

  Saturation_out1 <= dtc_out;

  DelayValue3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        DelayValue3_out1 <= '0';
      ELSIF enb = '1' THEN
        DelayValue3_out1 <= Saturation_out1;
      END IF;
    END IF;
  END PROCESS DelayValue3_process;


  Data_Type_Conversion1_out1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & DelayValue3_out1;

  Delay36_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Second_value <= '0';
      ELSIF enb = '1' THEN
        Second_value <= DelayValue3_out1;
      END IF;
    END IF;
  END PROCESS Delay36_process;


  Data_Type_Conversion2_out1 <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & Second_value;

  Gain_out1 <= resize(Data_Type_Conversion2_out1 & '0' & '0' & '0' & '0' & '0' & '0', 16);

  Add4_add_cast <= Gain_out1(12 DOWNTO 5);
  Switch <= Data_Type_Conversion1_out1 + Add4_add_cast;

  
  id1_Enable <= '1' WHEN Switch = to_signed(16#01#, 8) ELSE
      '0';

  delayMatch13_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch13_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch13_reg(0) <= id1_Enable;
        delayMatch13_reg(1 TO 3) <= delayMatch13_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS delayMatch13_process;

  id1_Enable_1 <= delayMatch13_reg(3);

  
  switch_compare_1 <= '1' WHEN id1_Enable_1 = '1' ELSE
      '0';

  stateControl_3 <= '1';

  delayMatch14_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch14_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch14_reg(0) <= stateControl_3;
        delayMatch14_reg(1 TO 4) <= delayMatch14_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch14_process;

  stateControl_4 <= delayMatch14_reg(4);

  enb_gated_1 <= stateControl_4 AND clk_enable;

  
  switch_compare_1_1 <= '1' WHEN Saturation_out1 = '1' ELSE
      '0';

  stateControl_5 <= '1';

  delayMatch1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        stateControl_6 <= '0';
      ELSIF enb = '1' THEN
        stateControl_6 <= stateControl_5;
      END IF;
    END IF;
  END PROCESS delayMatch1_process;


  enb_gated_2 <= stateControl_6 AND clk_enable;

  i_ph2_signed <= signed(i_ph2);

  in_1_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        i_ph2_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        i_ph2_1 <= i_ph2_signed;
      END IF;
    END IF;
  END PROCESS in_1_pipe_process;


  Delay4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay4_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_2 = '1' THEN
        Delay4_out1 <= Switch_on3_out1;
      END IF;
    END IF;
  END PROCESS Delay4_process;


  
  Switch_on3_out1 <= Delay4_out1 WHEN switch_compare_1_1 = '0' ELSE
      i_ph2_1;

  -- FCSD for 75674 = 2 X 157 X 241; Total Cost = 5
  -- CSD Encoding (2) : 10; Cost (Adders) = 0
  Gain1_factor <= resize(Switch_on3_out1 & '0', 36);
  -- CSD Encoding (157) : 0101001'01; Cost (Adders) = 3
  Gain1_factor_1 <= ((resize(Gain1_factor & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) + resize(Gain1_factor & '0' & '0' & '0' & '0' & '0', 36)) - resize(Gain1_factor & '0' & '0', 36)) + Gain1_factor;
  -- CSD Encoding (241) : 10001'0001; Cost (Adders) = 2
  Gain1_mul_temp <= (resize(Gain1_factor_1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) - resize(Gain1_factor_1 & '0' & '0' & '0' & '0', 36)) + Gain1_factor_1;
  Gain1_out1 <= Gain1_mul_temp(34 DOWNTO 17);

  
  switch_compare_1_2 <= '1' WHEN Saturation_out1 = '1' ELSE
      '0';

  stateControl_7 <= '1';

  delayMatch2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        stateControl_8 <= '0';
      ELSIF enb = '1' THEN
        stateControl_8 <= stateControl_7;
      END IF;
    END IF;
  END PROCESS delayMatch2_process;


  enb_gated_3 <= stateControl_8 AND clk_enable;

  i_ph3_signed <= signed(i_ph3);

  in_2_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        i_ph3_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        i_ph3_1 <= i_ph3_signed;
      END IF;
    END IF;
  END PROCESS in_2_pipe_process;


  Delay5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay5_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_3 = '1' THEN
        Delay5_out1 <= Switch_on4_out1;
      END IF;
    END IF;
  END PROCESS Delay5_process;


  
  Switch_on4_out1 <= Delay5_out1 WHEN switch_compare_1_2 = '0' ELSE
      i_ph3_1;

  -- FCSD for 75674 = 2 X 157 X 241; Total Cost = 5
  -- CSD Encoding (2) : 10; Cost (Adders) = 0
  Gain2_factor <= resize(Switch_on4_out1 & '0', 36);
  -- CSD Encoding (157) : 0101001'01; Cost (Adders) = 3
  Gain2_factor_1 <= ((resize(Gain2_factor & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) + resize(Gain2_factor & '0' & '0' & '0' & '0' & '0', 36)) - resize(Gain2_factor & '0' & '0', 36)) + Gain2_factor;
  -- CSD Encoding (241) : 10001'0001; Cost (Adders) = 2
  Gain2_mul_temp <= (resize(Gain2_factor_1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) - resize(Gain2_factor_1 & '0' & '0' & '0' & '0', 36)) + Gain2_factor_1;
  Gain2_out1 <= Gain2_mul_temp(34 DOWNTO 17);

  AddBeta_out1 <= Gain1_out1 - Gain2_out1;

  DelayValue2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        DelayValue2_out1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        DelayValue2_out1 <= AddBeta_out1;
      END IF;
    END IF;
  END PROCESS DelayValue2_process;


  
  switch_compare_1_3 <= '1' WHEN Saturation_out1 = '1' ELSE
      '0';

  stateControl_9 <= '1';

  delayMatch3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        stateControl_10 <= '0';
      ELSIF enb = '1' THEN
        stateControl_10 <= stateControl_9;
      END IF;
    END IF;
  END PROCESS delayMatch3_process;


  enb_gated_4 <= stateControl_10 AND clk_enable;

  i_ph1_signed <= signed(i_ph1);

  in_0_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        i_ph1_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        i_ph1_1 <= i_ph1_signed;
      END IF;
    END IF;
  END PROCESS in_0_pipe_process;


  Delay2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay2_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_4 = '1' THEN
        Delay2_out1 <= Switch_on2_out1;
      END IF;
    END IF;
  END PROCESS Delay2_process;


  
  Switch_on2_out1 <= Delay2_out1 WHEN switch_compare_1_3 = '0' ELSE
      i_ph1_1;

  -- FCSD for 87381 = 511 X 9 X 19; Total Cost = 4
  -- CSD Encoding (511) : 1000000001'; Cost (Adders) = 1
  Gain6_factor <= resize(Switch_on2_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) - resize(Switch_on2_out1, 36);
  -- CSD Encoding (9) : 01001; Cost (Adders) = 1
  Gain6_factor_1 <= resize(Gain6_factor & '0' & '0' & '0', 36) + Gain6_factor;
  -- CSD Encoding (19) : 010011; Cost (Adders) = 2
  Gain6_mul_temp <= (resize(Gain6_factor_1 & '0' & '0' & '0' & '0', 36) + resize(Gain6_factor_1 & '0', 36)) + Gain6_factor_1;
  Gain6_out1 <= Gain6_mul_temp(34 DOWNTO 17);

  -- FCSD for 87381 = 511 X 9 X 19; Total Cost = 4
  -- CSD Encoding (511) : 1000000001'; Cost (Adders) = 1
  Gain4_factor <= resize(Switch_on3_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) - resize(Switch_on3_out1, 36);
  -- CSD Encoding (9) : 01001; Cost (Adders) = 1
  Gain4_factor_1 <= resize(Gain4_factor & '0' & '0' & '0', 36) + Gain4_factor;
  -- CSD Encoding (19) : 010011; Cost (Adders) = 2
  Gain4_mul_temp <= (resize(Gain4_factor_1 & '0' & '0' & '0' & '0', 36) + resize(Gain4_factor_1 & '0', 36)) + Gain4_factor_1;
  Gain4_out1 <= Gain4_mul_temp(35 DOWNTO 18);

  AddAlpha_op_stage1 <= Gain6_out1 - Gain4_out1;

  -- FCSD for 87381 = 511 X 9 X 19; Total Cost = 4
  -- CSD Encoding (511) : 1000000001'; Cost (Adders) = 1
  Gain5_factor <= resize(Switch_on4_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 36) - resize(Switch_on4_out1, 36);
  -- CSD Encoding (9) : 01001; Cost (Adders) = 1
  Gain5_factor_1 <= resize(Gain5_factor & '0' & '0' & '0', 36) + Gain5_factor;
  -- CSD Encoding (19) : 010011; Cost (Adders) = 2
  Gain5_mul_temp <= (resize(Gain5_factor_1 & '0' & '0' & '0' & '0', 36) + resize(Gain5_factor_1 & '0', 36)) + Gain5_factor_1;
  Gain5_out1 <= Gain5_mul_temp(35 DOWNTO 18);

  AddAlpha_out1 <= AddAlpha_op_stage1 - Gain5_out1;

  Gain7_cast <= resize(AddAlpha_out1, 19);
  Gain7_cast_1 <=  - (Gain7_cast);
  Gain7_cast_2 <= Gain7_cast_1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0';
  Gain7_out1 <= Gain7_cast_2(34 DOWNTO 17);

  DelayValue4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        DelayValue4_out1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        DelayValue4_out1 <= Gain7_out1;
      END IF;
    END IF;
  END PROCESS DelayValue4_process;


  stateControl_11 <= '1';

  delayMatch4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        stateControl_12 <= '0';
      ELSIF enb = '1' THEN
        stateControl_12 <= stateControl_11;
      END IF;
    END IF;
  END PROCESS delayMatch4_process;


  enb_gated_5 <= stateControl_12 AND clk_enable;

  Delay22_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay22_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_5 = '1' THEN
        Delay22_out1 <= Switch_id_out1;
      END IF;
    END IF;
  END PROCESS Delay22_process;


  
  Switch_id_out1 <= DelayValue2_out1 WHEN Switch = to_signed(16#01#, 8) ELSE
      DelayValue4_out1 WHEN Switch = to_signed(16#02#, 8) ELSE
      Delay22_out1;

  delayMatch8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch8_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        delayMatch8_reg(0) <= Switch_id_out1;
        delayMatch8_reg(1 TO 3) <= delayMatch8_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS delayMatch8_process;

  Switch_id_out1_1 <= delayMatch8_reg(3);

  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        reduced_reg(0) <= Saturation_out1;
        reduced_reg(1 TO 3) <= reduced_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS reduced_process;

  Saturation_out1_1 <= reduced_reg(3);

  
  switch_compare_1_4 <= '1' WHEN Saturation_out1_1 = '1' ELSE
      '0';

  stateControl_13 <= '1';

  delayMatch7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch7_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch7_reg(0) <= stateControl_13;
        delayMatch7_reg(1 TO 4) <= delayMatch7_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch7_process;

  stateControl_14 <= delayMatch7_reg(4);

  enb_gated_6 <= stateControl_14 AND clk_enable;

  theta_signed <= signed(theta);

  in_3_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        theta_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        theta_1 <= theta_signed;
      END IF;
    END IF;
  END PROCESS in_3_pipe_process;


  theta_offset_AXI_signed <= signed(theta_offset_AXI);

  in_4_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        theta_offset_AXI_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        theta_offset_AXI_1 <= theta_offset_AXI_signed;
      END IF;
    END IF;
  END PROCESS in_4_pipe_process;


  Add1_out1 <= theta_1 - theta_offset_AXI_1;

  Add1_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add1_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        Add1_out1_1 <= Add1_out1;
      END IF;
    END IF;
  END PROCESS Add1_out_pipe_process;


  
  Compare_Limit_Low_out1 <= '1' WHEN Add1_out1_1 < to_signed(16#000000#, 24) ELSE
      '0';

  
  Compare_Limit_High_out1 <= '1' WHEN Add1_out1_1 >= to_signed(16#6487ED#, 24) ELSE
      '0';

  Compare_Limit_High_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Compare_Limit_High_out1_1 <= '0';
      ELSIF enb = '1' THEN
        Compare_Limit_High_out1_1 <= Compare_Limit_High_out1;
      END IF;
    END IF;
  END PROCESS Compare_Limit_High_out_pipe_process;


  
  switch_compare_1_5 <= '1' WHEN Compare_Limit_High_out1_1 > '0' ELSE
      '0';

  delayMatch5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add1_out1_2 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        Add1_out1_2 <= Add1_out1_1;
      END IF;
    END IF;
  END PROCESS delayMatch5_process;


  Constant_out1 <= to_signed(16#6487ED#, 24);

  Add2_out1 <= Add1_out1_1 - Constant_out1;

  Compare_Limit_Low_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Compare_Limit_Low_out1_1 <= '0';
      ELSIF enb = '1' THEN
        Compare_Limit_Low_out1_1 <= Compare_Limit_Low_out1;
      END IF;
    END IF;
  END PROCESS Compare_Limit_Low_out_pipe_process;


  
  switch_compare_1_6 <= '1' WHEN Compare_Limit_Low_out1_1 > '0' ELSE
      '0';

  Add2_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add2_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        Add2_out1_1 <= Add2_out1;
      END IF;
    END IF;
  END PROCESS Add2_out_pipe_process;


  
  Switch_Limit_High_out1 <= Add1_out1_2 WHEN switch_compare_1_5 = '0' ELSE
      Add2_out1_1;

  Constant1_out1 <= to_signed(16#6487ED#, 24);

  Add3_out1 <= Add1_out1_1 + Constant1_out1;

  Add3_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Add3_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        Add3_out1_1 <= Add3_out1;
      END IF;
    END IF;
  END PROCESS Add3_out_pipe_process;


  
  Switch_Limit_Low_out1 <= Switch_Limit_High_out1 WHEN switch_compare_1_6 = '0' ELSE
      Add3_out1_1;

  -- CSD Encoding (5340354) : 01010001100001'0011000010; Cost (Adders) = 7
  ScaleTheta_mul_temp <= ((((((resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) - resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0' & '0' & '0' & '0' & '0' & '0', 48)) + resize(Switch_Limit_Low_out1 & '0', 48);
  ScaleTheta_out1 <= resize(ScaleTheta_mul_temp(47 DOWNTO 25), 24);

  Cosine_in_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        ScaleTheta_out1_1 <= to_signed(16#000000#, 24);
      ELSIF enb = '1' THEN
        ScaleTheta_out1_1 <= ScaleTheta_out1;
      END IF;
    END IF;
  END PROCESS Cosine_in_pipe_process;


  Cosine_out1_signed <= signed(Cosine_out1);

  Cosine_out_pipe0_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Cosine_out1_1 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        Cosine_out1_1 <= Cosine_out1_signed;
      END IF;
    END IF;
  END PROCESS Cosine_out_pipe0_process;


  Delay7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay7_out1 <= to_signed(16#0000#, 16);
      ELSIF enb_gated_6 = '1' THEN
        Delay7_out1 <= Switch_on7_out1;
      END IF;
    END IF;
  END PROCESS Delay7_process;


  
  Switch_on7_out1 <= Delay7_out1 WHEN switch_compare_1_4 = '0' ELSE
      Cosine_out1_1;

  sin1_mul_temp <= Switch_id_out1_1 * Switch_on7_out1;
  sin1_out1 <= sin1_mul_temp(31 DOWNTO 14);

  DelayValue1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        DelayValue1_out1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        DelayValue1_out1 <= AddAlpha_out1;
      END IF;
    END IF;
  END PROCESS DelayValue1_process;


  stateControl_15 <= '1';

  delayMatch9_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        stateControl_16 <= '0';
      ELSIF enb = '1' THEN
        stateControl_16 <= stateControl_15;
      END IF;
    END IF;
  END PROCESS delayMatch9_process;


  enb_gated_7 <= stateControl_16 AND clk_enable;

  Delay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay1_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_7 = '1' THEN
        Delay1_out1 <= Switch_id1_out1;
      END IF;
    END IF;
  END PROCESS Delay1_process;


  
  Switch_id1_out1 <= DelayValue1_out1 WHEN Switch = to_signed(16#01#, 8) ELSE
      DelayValue2_out1 WHEN Switch = to_signed(16#02#, 8) ELSE
      Delay1_out1;

  delayMatch12_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch12_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        delayMatch12_reg(0) <= Switch_id1_out1;
        delayMatch12_reg(1 TO 3) <= delayMatch12_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS delayMatch12_process;

  Switch_id1_out1_1 <= delayMatch12_reg(3);

  
  switch_compare_1_7 <= '1' WHEN Saturation_out1_1 = '1' ELSE
      '0';

  stateControl_17 <= '1';

  delayMatch11_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch11_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch11_reg(0) <= stateControl_17;
        delayMatch11_reg(1 TO 4) <= delayMatch11_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch11_process;

  stateControl_18 <= delayMatch11_reg(4);

  enb_gated_8 <= stateControl_18 AND clk_enable;

  Cosine_out2_signed <= signed(Cosine_out2);

  Cosine_out_pipe1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Cosine_out2_1 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        Cosine_out2_1 <= Cosine_out2_signed;
      END IF;
    END IF;
  END PROCESS Cosine_out_pipe1_process;


  Delay3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay3_out1 <= to_signed(16#0000#, 16);
      ELSIF enb_gated_8 = '1' THEN
        Delay3_out1 <= Switch_on1_out1;
      END IF;
    END IF;
  END PROCESS Delay3_process;


  
  Switch_on1_out1 <= Delay3_out1 WHEN switch_compare_1_7 = '0' ELSE
      Cosine_out2_1;

  cos1_mul_temp <= Switch_id1_out1_1 * Switch_on1_out1;
  cos1_out1 <= cos1_mul_temp(31 DOWNTO 14);

  Add_1_out1 <= sin1_out1 + cos1_out1;

  Delay10_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay10_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_1 = '1' THEN
        Delay10_out1 <= Switch_idpred1_out1;
      END IF;
    END IF;
  END PROCESS Delay10_process;


  
  Switch_idpred1_out1 <= Delay10_out1 WHEN switch_compare_1 = '0' ELSE
      Add_1_out1;

  reduced_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_idpred1_out1_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        Switch_idpred1_out1_1 <= Switch_idpred1_out1;
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  id <= std_logic_vector(Switch_idpred1_out1_1);

  delayMatch15_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch15_reg <= (OTHERS => to_signed(16#00#, 8));
      ELSIF enb = '1' THEN
        delayMatch15_reg(0) <= Switch;
        delayMatch15_reg(1 TO 3) <= delayMatch15_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS delayMatch15_process;

  Switch_1 <= delayMatch15_reg(3);

  
  switch_compare_1_8 <= '1' WHEN Switch_1 >= to_signed(16#02#, 8) ELSE
      '0';

  stateControl_19 <= '1';

  delayMatch16_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch16_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch16_reg(0) <= stateControl_19;
        delayMatch16_reg(1 TO 4) <= delayMatch16_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch16_process;

  stateControl_20 <= delayMatch16_reg(4);

  enb_gated_9 <= stateControl_20 AND clk_enable;

  Delay16_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay16_out1 <= to_signed(16#00000#, 18);
      ELSIF enb_gated_9 = '1' THEN
        Delay16_out1 <= Switch_idpred2_out1;
      END IF;
    END IF;
  END PROCESS Delay16_process;


  
  Switch_idpred2_out1 <= Delay16_out1 WHEN switch_compare_1_8 = '0' ELSE
      Add_1_out1;

  reduced_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch_idpred2_out1_1 <= to_signed(16#00000#, 18);
      ELSIF enb = '1' THEN
        Switch_idpred2_out1_1 <= Switch_idpred2_out1;
      END IF;
    END IF;
  END PROCESS reduced_2_process;


  iq <= std_logic_vector(Switch_idpred2_out1_1);

  id_AXI <= std_logic_vector(Switch_idpred1_out1_1);

  iq_AXI <= std_logic_vector(Switch_idpred2_out1_1);

  DelayValid_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        DelayValid_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        DelayValid_reg(0) <= Saturation_out1;
        DelayValid_reg(1) <= DelayValid_reg(0);
      END IF;
    END IF;
  END PROCESS DelayValid_process;

  End_Cycle <= DelayValid_reg(1);

  shift6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift6_out1 <= '0';
      ELSIF enb = '1' THEN
        shift6_out1 <= End_Cycle;
      END IF;
    END IF;
  END PROCESS shift6_process;


  shift1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift1_out1 <= '0';
      ELSIF enb = '1' THEN
        shift1_out1 <= shift6_out1;
      END IF;
    END IF;
  END PROCESS shift1_process;


  shift2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift2_out1 <= '0';
      ELSIF enb = '1' THEN
        shift2_out1 <= shift1_out1;
      END IF;
    END IF;
  END PROCESS shift2_process;


  shift3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        shift3_out1 <= '0';
      ELSIF enb = '1' THEN
        shift3_out1 <= shift2_out1;
      END IF;
    END IF;
  END PROCESS shift3_process;


  Logical_Operator_out1 <= shift3_out1 OR (shift2_out1 OR (shift1_out1 OR (End_Cycle OR shift6_out1)));

  delayMatch17_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch17_reg <= (OTHERS => '0');
      ELSIF enb = '1' THEN
        delayMatch17_reg(0) <= Logical_Operator_out1;
        delayMatch17_reg(1 TO 4) <= delayMatch17_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch17_process;

  Logical_Operator_out1_1 <= delayMatch17_reg(4);

  out_5_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Cosine_out1_2 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        Cosine_out1_2 <= Cosine_out1_1;
      END IF;
    END IF;
  END PROCESS out_5_pipe_process;


  sin <= std_logic_vector(Cosine_out1_2);

  out_6_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Cosine_out2_2 <= to_signed(16#0000#, 16);
      ELSIF enb = '1' THEN
        Cosine_out2_2 <= Cosine_out2_1;
      END IF;
    END IF;
  END PROCESS out_6_pipe_process;


  cos <= std_logic_vector(Cosine_out2_2);

  delayMatch18_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch18_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        delayMatch18_reg(0) <= Switch_on2_out1;
        delayMatch18_reg(1 TO 4) <= delayMatch18_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch18_process;

  Switch_on2_out1_1 <= delayMatch18_reg(4);

  i1_AXI <= std_logic_vector(Switch_on2_out1_1);

  delayMatch19_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch19_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        delayMatch19_reg(0) <= Switch_on3_out1;
        delayMatch19_reg(1 TO 4) <= delayMatch19_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch19_process;

  Switch_on3_out1_1 <= delayMatch19_reg(4);

  i2_AXI <= std_logic_vector(Switch_on3_out1_1);

  delayMatch20_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayMatch20_reg <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        delayMatch20_reg(0) <= Switch_on4_out1;
        delayMatch20_reg(1 TO 4) <= delayMatch20_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS delayMatch20_process;

  Switch_on4_out1_1 <= delayMatch20_reg(4);

  i3_AXI <= std_logic_vector(Switch_on4_out1_1);

  reduced_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg_1 <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        reduced_reg_1(0) <= DelayValue1_out1;
        reduced_reg_1(1 TO 4) <= reduced_reg_1(0 TO 3);
      END IF;
    END IF;
  END PROCESS reduced_3_process;

  DelayValue1_out1_1 <= reduced_reg_1(4);

  ialpha <= std_logic_vector(DelayValue1_out1_1);

  ialpha_AXI <= std_logic_vector(DelayValue1_out1_1);

  reduced_4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        reduced_reg_2 <= (OTHERS => to_signed(16#00000#, 18));
      ELSIF enb = '1' THEN
        reduced_reg_2(0) <= DelayValue2_out1;
        reduced_reg_2(1 TO 4) <= reduced_reg_2(0 TO 3);
      END IF;
    END IF;
  END PROCESS reduced_4_process;

  DelayValue2_out1_1 <= reduced_reg_2(4);

  ibeta <= std_logic_vector(DelayValue2_out1_1);

  ibeta_AXI <= std_logic_vector(DelayValue2_out1_1);

  ce_out <= clk_enable;

  dq_Done <= Logical_Operator_out1_1;

END rtl;

