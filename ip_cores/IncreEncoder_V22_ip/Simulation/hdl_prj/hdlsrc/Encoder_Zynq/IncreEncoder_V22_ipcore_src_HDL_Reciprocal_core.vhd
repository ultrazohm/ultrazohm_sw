-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\Encoder_Zynq\IncreEncoder_V22_ipcore_src_HDL_Reciprocal_core.vhd
-- Created: 2018-09-05 17:28:19
-- 
-- Generated by MATLAB 9.4 and HDL Coder 3.12
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: IncreEncoder_V22_ipcore_src_HDL_Reciprocal_core
-- Source Path: Encoder_Zynq/IncreEncoder_V22/HDL Reciprocal/HDL Reciprocal_core
-- Hierarchy Level: 2
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY IncreEncoder_V22_ipcore_src_HDL_Reciprocal_core IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb_1_100_0                       :   IN    std_logic;
        enb_1_50_0                        :   IN    std_logic;
        xin                               :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En30
        ain                               :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En32
        sel                               :   IN    std_logic;  -- ufix1
        xout                              :   OUT   std_logic_vector(31 DOWNTO 0);  -- ufix32_En30
        aout                              :   OUT   std_logic_vector(31 DOWNTO 0)  -- ufix32_En32
        );
END IncreEncoder_V22_ipcore_src_HDL_Reciprocal_core;


ARCHITECTURE rtl OF IncreEncoder_V22_ipcore_src_HDL_Reciprocal_core IS

  -- Signals
  SIGNAL xin_unsigned                     : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL ain_unsigned                     : unsigned(31 DOWNTO 0);  -- ufix32_En32
  SIGNAL ain_dtc                          : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL const2                           : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL mulout                           : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL delayout                         : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL subtractor_sub_cast              : unsigned(32 DOWNTO 0);  -- ufix33_En30
  SIGNAL subtractor_sub_cast_1            : unsigned(32 DOWNTO 0);  -- ufix33_En30
  SIGNAL subtractor_sub_temp              : unsigned(32 DOWNTO 0);  -- ufix33_En30
  SIGNAL subout                           : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL muxout                           : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL mul1_mul_temp                    : unsigned(63 DOWNTO 0);  -- ufix64_En60
  SIGNAL xout_tmp                         : unsigned(31 DOWNTO 0);  -- ufix32_En30
  SIGNAL aout_tmp                         : unsigned(31 DOWNTO 0);  -- ufix32_En32
  SIGNAL enb_2_100_0                      : std_logic;

BEGIN
  -- Iteration Core of the Recip Implementation using Newton Method

  xin_unsigned <= unsigned(xin);

  ain_unsigned <= unsigned(ain);

  ain_dtc <= resize(ain_unsigned(31 DOWNTO 2), 32);

  const2 <= unsigned'(X"80000000");

  reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        delayout <= to_unsigned(0, 32);
      ELSIF enb_1_50_0 = '1' THEN
        delayout <= mulout;
      END IF;
    END IF;
  END PROCESS reg_process;


  subtractor_sub_cast <= resize(const2, 33);
  subtractor_sub_cast_1 <= resize(delayout, 33);
  subtractor_sub_temp <= subtractor_sub_cast - subtractor_sub_cast_1;
  
  subout <= X"FFFFFFFF" WHEN subtractor_sub_temp(32) /= '0' ELSE
      subtractor_sub_temp(31 DOWNTO 0);

  
  muxout <= ain_dtc WHEN sel = '0' ELSE
      subout;

  mul1_mul_temp <= xin_unsigned * muxout;
  
  mulout <= X"FFFFFFFF" WHEN mul1_mul_temp(63 DOWNTO 62) /= "00" ELSE
      mul1_mul_temp(61 DOWNTO 30);

  xout_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        xout_tmp <= to_unsigned(0, 32);
      ELSIF enb_1_100_0 = '1' THEN
        xout_tmp <= mulout;
      END IF;
    END IF;
  END PROCESS xout_reg_process;


  xout <= std_logic_vector(xout_tmp);

  aout_reg_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        aout_tmp <= to_unsigned(0, 32);
      ELSIF enb_1_100_0 = '1' THEN
        aout_tmp <= ain_unsigned;
      END IF;
    END IF;
  END PROCESS aout_reg_process;


  aout <= std_logic_vector(aout_tmp);

END rtl;

