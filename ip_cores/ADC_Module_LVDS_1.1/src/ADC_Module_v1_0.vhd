-- -------------------------------------------------------------
-- Created: 2017-06-26 14:30:00
-- 
-- Generated by Herrmann, Wilhelmi g. H.
-- 
-- 
-- -------------------------------------------------------------
-- Description
-- -------------------------------------------------------------
-- ADC_Module
-- Top Level File of the ADC Block
-- Instantiation of the LVDS Buffers, SPI_Module and Calculate
-- Current and Calculate Voltage Module 
-- -------------------------------------------------------------
-- Version 1.0
-- -------------------------------------------------------------
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;


-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
library UNISIM;
use UNISIM.VComponents.all;


entity ADC_Module_v1_0 is
	generic(
		-- Users to add parameters here
        Number_of_ADCs           : integer := 1;
        INPUT_CLK_FREQUENCY : integer := 100000000; -- Hz 
        SPI_CLK_FREQUENCY   : integer :=  25000000; -- Hz / value will be used to calculate the Reload-Value of the Clock divider
        PRE_DELAY           : integer := 0; -- 0 := 10ns / DELAY BETWEEN CNV TO ACTIVE AND DATA TRANSMISSION
        -- Datasheet 9.5ns  => 0 := 10ns
        POST_DELAY          : integer := 1; -- 0 := 10ns / DELAY BETWEEN END OF DATA TRANSMISSION AND CNV TO DISABLE 
        -- Datasheet 19.1   => 1 := 20ns                       -- 1    
        CONV_DELAY          : integer := 2; -- 0 := 10ns / DELAY BETWEEN CS TO DISABLE AND CS TO ENABLE
        -- Datasheet 25     => 2 := 30ns    
        CONTINUOUS_TRIGGERED_MODE   : boolean := false; -- 0 := Continous Mode; 1 := Triggered Mode
        W_LENGTH            : integer := 16 -- WORDLENGTH
		-- User parameters ends
		-- Do not modify the parameters beyond this line      

		-- Parameters of Axi Slave Bus Interface S00_AXI
	);
	port (
		-- Users to add ports here
		clk             : in std_logic;
		reset_n         : in std_logic;
		enable_spi      : in std_logic;
		SCLK_spi_p      : out std_logic_vector(Number_of_ADCs-1 downto 0);
		SCLK_spi_n      : out std_logic_vector(Number_of_ADCs-1 downto 0);
		SS_N_spi        : out std_logic_vector(Number_of_ADCs-1 downto 0);
		DATA_IN_P	    : in std_logic_vector(Number_of_ADCs-1 downto 0);
		DATA_IN_N	    : in std_logic_vector(Number_of_ADCs-1 downto 0);
		TRIGGER_TRANSMISSION : in STD_LOGIC;
		ADC_set_offset : in STD_LOGIC;
		rx_data_16bit   : out std_logic_vector(Number_of_ADCs*16-1 downto 0);
		calculated_current : out std_logic_vector(Number_of_ADCs*16-1 downto 0);
		calculated_current_valid : out std_logic_vector(Number_of_ADCs-1 downto 0);
		calculated_voltage : out std_logic_vector(Number_of_ADCs*16-1 downto 0);
		calculated_voltage_valid : out std_logic_vector(Number_of_ADCs-1 downto 0)
		);
end ADC_Module_v1_0;

architecture arch_imp of ADC_Module_v1_0 is

    signal miso : std_logic_vector(Number_of_ADCs-1 downto 0);
    signal slv_spi_rx_data_16bit : std_logic_vector(Number_of_ADCs*16-1 downto 0);
    signal slv_calculated_voltage : std_logic_vector(Number_of_ADCs*16-1 downto 0);
    signal slv_calculated_current : std_logic_vector(Number_of_ADCs*16-1 downto 0);
    signal din : STD_LOGIC_VECTOR(15 DOWNTO 0);
    signal wr_en : STD_LOGIC;
    signal rd_en : STD_LOGIC;
    signal dout : STD_LOGIC_VECTOR(15 DOWNTO 0);
    signal full : STD_LOGIC;
    signal empty : STD_LOGIC;
    signal clk_en : STD_LOGIC := '1';
    signal spi_clk : STD_LOGIC_VECTOR(Number_of_ADCs DOWNTO 0);
    signal adc_data_valid : STD_LOGIC_VECTOR(Number_of_ADCs-1 DOWNTO 0);

	-- component declaration
--	component IBUFDS
--	        generic(DIFF_TERM : boolean :=TRUE);
--            port (
--                O: out std_logic;
--                I: in std_logic;
--                IB: in std_logic
--            );
--    end component;
    
    component OBUFDS
            port (
                I: in std_logic;
                O: out std_logic;
                OB: out std_logic
            );
    end component;
    
    -- component spi_master    
    component spi_master is
        generic(INPUT_CLK_FREQUENCY : integer := 200000000; -- Hz 
                SPI_CLK_FREQUENCY   : integer := 100000000; -- hz / value will be used to calculate the Reload-Value of the Clock divider
                PRE_DELAY           : integer := 1; -- 1 := 10 ns / DELAY BETWEEN CS TO ACTIVE AND DATA TRANSMISSION
                POST_DELAY          : integer := 0; -- 1 := 20 ns / DELAY BETWEEN END OF DATA TRANSMISSION AND CS TO DISABLE 
                CONV_DELAY          : integer := 0; -- us / DELAY BETWEEN CS TO DISABLE AND CS TO ENABLE
                CONTINUOUS_TRIGGERED_MODE : boolean := false;
                W_LENGTH            : integer := 16 -- WORDLENGTH
        );
        port(TX_DATA : in  STD_LOGIC_VECTOR(W_LENGTH - 1 downto 0); -- SENDWORD
             RX_DATA : out STD_LOGIC_VECTOR(W_LENGTH - 1 downto 0); -- RECEIVEDWORD
             CPHA    : in  STD_LOGIC;       -- Clock Phase
             CPOL    : in  STD_LOGIC;       -- Clock Polarity
             MOSI    : out STD_LOGIC;
             VALID   : out STD_LOGIC;
             TRIGGER_TRANSMISSION : in STD_LOGIC;
             MISO    : in  STD_LOGIC;
             SCLK    : out STD_LOGIC;
             SS_N    : out STD_LOGIC;
             BUSY    : out STD_LOGIC;
             ENABLE  : in  STD_LOGIC;
             RESET   : in  std_logic;
             --TX_Done  : out STD_LOGIC;
             CLOCK   : in  STD_LOGIC
        );
    end component spi_master;
    

   -- component adc_voltage_calculation    
    component ADC_VALUE_TO_VOLTAGE IS
      PORT(clk                               :   IN    std_logic;
           reset                             :   IN    std_logic;
           clk_enable                        :   IN    std_logic;
           ADC_IN                            :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
           ADC_DATA_VALID                    :   IN    std_logic;
        --   Voltage_0_Current_1               :   IN    std_logic;
           ce_out                            :   OUT   std_logic;
           CALC_VOLTAGE                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En12
           calculated_voltage_valid                :   OUT   std_logic
           );
    end component ADC_VALUE_TO_VOLTAGE;
    
      component ADC_VALUE_TO_CURRENT IS
      PORT(clk                               :   IN    std_logic;
           reset                             :   IN    std_logic;
           clk_enable                        :   IN    std_logic;
           ADC_IN                            :   IN    std_logic_vector(15 DOWNTO 0);  -- int16
           ADC_DATA_VALID                    :   IN    std_logic;
           ADC_SET_OFFSET                    :   IN    std_logic;
        --   Voltage_0_Current_1               :   IN    std_logic;
           ce_out                            :   OUT   std_logic;
           CALC_CURRENT                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En10
           CALC_CURRENT_VALID                :   OUT   std_logic
           );
    end component ADC_VALUE_TO_CURRENT;
    
begin

    rx_data_16bit <= slv_spi_rx_data_16bit;
    calculated_voltage <= slv_calculated_voltage;
    calculated_current <= slv_calculated_current;
    
-- Instantiation of the IBUFDS
GEN_IBUFDS: for I in 0 to Number_of_ADCs-1 generate
    instantiation_IBUFDS: IBUFDS
        generic map (DIFF_TERM=>TRUE)
        port map (
            O => miso(I),
            I => DATA_IN_P(I),
            IB => DATA_IN_N(I)
        );
end generate GEN_IBUFDS;

-- Instantiation of the OBUFDS
GEN_OBUFDS: for I in 0 to Number_of_ADCs-1 generate
    instantiation_OBUFDS: OBUFDS
            port map (
                I => spi_clk(I),
                O => SCLK_spi_p(I),
                OB => SCLK_spi_n(I)
            );
end generate GEN_OBUFDS;

-- Instantiation of the spi_master module
GEN_SPI: for I in 0 to Number_of_ADCs-1 generate
    instantiation_spi: spi_master
         generic map(INPUT_CLK_FREQUENCY => INPUT_CLK_FREQUENCY, -- Hz 
                     SPI_CLK_FREQUENCY => SPI_CLK_FREQUENCY, -- hz / value will be used to calculate the Reload-Value of the Clock divider
                     PRE_DELAY => PRE_DELAY, -- us / DELAY BETWEEN CS TO ACTIVE AND DATA TRANSMISSION
                     POST_DELAY => POST_DELAY, -- us / DELAY BETWEEN END OF DATA TRANSMISSION AND CS TO DISABLE 
                     CONV_DELAY => CONV_DELAY, -- us / DELAY BETWEEN CS TO DISABLE AND CS TO ENABLE
                     CONTINUOUS_TRIGGERED_MODE => CONTINUOUS_TRIGGERED_MODE,
                     W_LENGTH => W_LENGTH
                     )
        port map(
             TX_DATA => x"0000",
             RX_DATA => slv_spi_rx_data_16bit((I+1)*16-1 downto I*16),
             CPHA    => '0',  -- datatransmission at the first edge -> falling edge (CPHA=0, CPOL=1)
             CPOL    => '1',  -- Clock IDLE HIGH
             MOSI    => open,
             MISO    => miso(I),
             SCLK    => spi_clk(I),       
             SS_N    => SS_N_spi(I),
             VALID   =>  adc_data_valid(I),
             TRIGGER_TRANSMISSION => TRIGGER_TRANSMISSION,
             BUSY    => open,
             ENABLE  => enable_spi,
             RESET   => not(reset_n), 
             --TX_Done  
             CLOCK   => clk
        );
end generate GEN_SPI;

GEN_calc: for I in 0 to Number_of_ADCs-1 generate
    calc: ADC_VALUE_TO_VOLTAGE 
          port map(ADC_IN => slv_spi_rx_data_16bit((I+1)*16-1 downto I*16),
                   ADC_DATA_VALID => adc_data_valid(I), 
                   CALC_VOLTAGE  => slv_calculated_voltage((I+1)*16-1 downto I*16),
                   clk => clk,
               --    Voltage_0_Current_1 => Voltage_0_Current_1,
                   reset => not(reset_n),
                   clk_enable => clk_en,
                   calculated_voltage_valid => calculated_voltage_valid(I),                       
                   ce_out => open                         
          );
end generate GEN_calc;

GEN_calc_current: for I in 0 to Number_of_ADCs-1 generate
    calc_current: ADC_VALUE_TO_CURRENT 
          port map(ADC_IN => slv_spi_rx_data_16bit((I+1)*16-1 downto I*16),
                   ADC_DATA_VALID => adc_data_valid(I), 
                   CALC_CURRENT  => slv_calculated_current((I+1)*16-1 downto I*16),
                   clk => clk,
                   ADC_SET_OFFSET => ADC_set_offset,
               --    Voltage_0_Current_1 => Voltage_0_Current_1,
                   reset => not(reset_n),
                   clk_enable => clk_en,
                   CALC_CURRENT_VALID => calculated_current_valid(I),                       
                   ce_out => open                         
          );
end generate GEN_calc_current;

end arch_imp;
