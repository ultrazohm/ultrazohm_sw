-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\Encoder_Zynq_V24\IncreEncoder_V24_ip_src_IncreEncoder_V24.vhd
-- Created: 2020-06-13 11:16:19
-- 
-- Generated by MATLAB 9.4 and HDL Coder 3.12
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1e-10
-- Target subsystem base rate: 1e-08
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- omega                         ce_out        2e-08
-- omega_AXI4                    ce_out        2e-08
-- theta_el                      ce_out        2e-08
-- theta_el_AXI4                 ce_out        2e-08
-- position                      ce_out        2e-08
-- position_AXI4                 ce_out        2e-08
-- edge_rsvd                     ce_out        2e-08
-- count                         ce_out        2e-08
-- direction_AXI4                ce_out        2e-08
-- countPerPeriod_AXI4           ce_out        2e-08
-- OverSamplFactor               ce_out        2e-08
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: IncreEncoder_V24_ip_src_IncreEncoder_V24
-- Source Path: Encoder_Zynq_V24/IncreEncoder_V24
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY IncreEncoder_V24_ip_src_IncreEncoder_V24 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        A                                 :   IN    std_logic;
        B                                 :   IN    std_logic;
        I                                 :   IN    std_logic;
        PI2_Inc_AXI4                      :   IN    std_logic_vector(23 DOWNTO 0);  -- ufix24_En24
        Timer_FPGA_ms_AXI4                :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En32
        IncPerTurn_mech_AXI4              :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        IncPerTurn_elek_AXI4              :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        OmegaPerOverSampl_AXI4            :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        PeriodEnd                         :   IN    std_logic;
        ce_out                            :   OUT   std_logic;
        omega                             :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        omega_AXI4                        :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
        theta_el                          :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        theta_el_AXI4                     :   OUT   std_logic_vector(23 DOWNTO 0);  -- sfix24_En20
        position                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
        position_AXI4                     :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
        edge_rsvd                         :   OUT   std_logic;  -- ufix1
        count                             :   OUT   std_logic;
        direction_AXI4                    :   OUT   std_logic_vector(3 DOWNTO 0);  -- sfix4
        countPerPeriod_AXI4               :   OUT   std_logic_vector(15 DOWNTO 0);  -- int16
        OverSamplFactor                   :   OUT   std_logic_vector(15 DOWNTO 0)  -- uint16
        );
END IncreEncoder_V24_ip_src_IncreEncoder_V24;


ARCHITECTURE rtl OF IncreEncoder_V24_ip_src_IncreEncoder_V24 IS

  -- Component Declarations
  COMPONENT IncreEncoder_V24_ip_src_IncreEncoder_V24_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb_2_100_0                     :   OUT   std_logic;
          enb_1_100_0                     :   OUT   std_logic;
          enb_1_100_1                     :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V24_ip_src_Check_Direction
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          A                               :   IN    std_logic;
          B                               :   IN    std_logic;
          Dir                             :   OUT   std_logic_vector(3 DOWNTO 0)  -- sfix4
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V24_ip_src_omega_by_measure_time
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          Edge_rsvd                       :   IN    std_logic;
          T                               :   IN    std_logic_vector(37 DOWNTO 0);  -- sfix38_En32
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          ReadBack_Omega                  :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          OverSamplOmega                  :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En11
          one_Omega                       :   OUT   std_logic_vector(37 DOWNTO 0);  -- sfix38_En32
          OverSamplingFactor              :   OUT   std_logic_vector(15 DOWNTO 0);  -- uint16
          NewMeasurement                  :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V24_ip_src_HDL_Reciprocal
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          enb_2_100_0                     :   IN    std_logic;
          din                             :   IN    std_logic_vector(31 DOWNTO 0);  -- sfix32_En18
          dout                            :   OUT   std_logic_vector(31 DOWNTO 0)  -- sfix32_En12
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V24_ip_src_Counter
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          Enable_ctr                      :   IN    std_logic;
          I_line                          :   IN    std_logic;
          Edge_rsvd                       :   OUT   std_logic_vector(7 DOWNTO 0);  -- int8
          Reset_1                         :   OUT   std_logic_vector(7 DOWNTO 0)  -- uint8
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V24_ip_src_Counter_theta_ele
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          Edge_rsvd                       :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          Reset_1                         :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V24_ip_src_Counter_position
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          Edge_rsvd                       :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          Reset_1                         :   IN    std_logic_vector(7 DOWNTO 0);  -- uint8
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          Dir                             :   IN    std_logic_vector(3 DOWNTO 0);  -- sfix4
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- uint16
          );
  END COMPONENT;

  COMPONENT IncreEncoder_V24_ip_src_omega_by_count_lines
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_100_0                     :   IN    std_logic;
          Edge_rsvd                       :   IN    std_logic_vector(7 DOWNTO 0);  -- int8
          Reset_1                         :   IN    std_logic;
          IncsPerTurn                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          count                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- int16
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : IncreEncoder_V24_ip_src_IncreEncoder_V24_tc
    USE ENTITY work.IncreEncoder_V24_ip_src_IncreEncoder_V24_tc(rtl);

  FOR ALL : IncreEncoder_V24_ip_src_Check_Direction
    USE ENTITY work.IncreEncoder_V24_ip_src_Check_Direction(rtl);

  FOR ALL : IncreEncoder_V24_ip_src_omega_by_measure_time
    USE ENTITY work.IncreEncoder_V24_ip_src_omega_by_measure_time(rtl);

  FOR ALL : IncreEncoder_V24_ip_src_HDL_Reciprocal
    USE ENTITY work.IncreEncoder_V24_ip_src_HDL_Reciprocal(rtl);

  FOR ALL : IncreEncoder_V24_ip_src_Counter
    USE ENTITY work.IncreEncoder_V24_ip_src_Counter(rtl);

  FOR ALL : IncreEncoder_V24_ip_src_Counter_theta_ele
    USE ENTITY work.IncreEncoder_V24_ip_src_Counter_theta_ele(rtl);

  FOR ALL : IncreEncoder_V24_ip_src_Counter_position
    USE ENTITY work.IncreEncoder_V24_ip_src_Counter_position(rtl);

  FOR ALL : IncreEncoder_V24_ip_src_omega_by_count_lines
    USE ENTITY work.IncreEncoder_V24_ip_src_omega_by_count_lines(rtl);

  -- Signals
  SIGNAL enb_1_100_0                      : std_logic;
  SIGNAL enb_2_100_0                      : std_logic;
  SIGNAL enb_1_100_1                      : std_logic;
  SIGNAL Logical2_out1                    : std_logic;
  SIGNAL Timer_FPGA_ms_AXI4_unsigned      : unsigned(31 DOWNTO 0);  -- ufix32_En32
  SIGNAL Pipeline6_out1                   : unsigned(31 DOWNTO 0);  -- ufix32_En32
  SIGNAL Data_Type_Conversion3_out1       : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL Logical2_out1_1                  : std_logic;
  SIGNAL Pipeline7_out1                   : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL Check_Direction_out1             : std_logic_vector(3 DOWNTO 0);  -- ufix4
  SIGNAL Check_Direction_out1_signed      : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL hold1_out1                       : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL OmegaPerOverSampl_AXI4_signed    : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL Pipeline4_out1                   : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL omega_by_measure_time_out2       : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL omega_by_measure_time_out2_unsigned : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL hold5_out1                       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL hold5_out1_1                     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL omega_oversampled                : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL rps                              : std_logic_vector(37 DOWNTO 0);  -- ufix38
  SIGNAL NewMeasurement                   : std_logic;
  SIGNAL rps_signed                       : signed(37 DOWNTO 0);  -- sfix38_En32
  SIGNAL Data_Type_Conversion4_out1       : signed(31 DOWNTO 0);  -- sfix32_En18
  SIGNAL hold2_out1                       : signed(31 DOWNTO 0);  -- sfix32_En18
  SIGNAL HDL_Reciprocal_out1              : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL HDL_Reciprocal_out1_signed       : signed(31 DOWNTO 0);  -- sfix32_En12
  SIGNAL omega_oversampled_1              : signed(23 DOWNTO 0);  -- sfix24_En12
  SIGNAL Div_i1_cast                      : signed(16 DOWNTO 0);  -- sfix17
  SIGNAL Div_i1_mul_temp                  : signed(40 DOWNTO 0);  -- sfix41_En12
  SIGNAL Div_i1_cast_1                    : signed(39 DOWNTO 0);  -- sfix40_En12
  SIGNAL omega_oversampled_2              : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL PI2_Inc_AXI4_unsigned            : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL Pipeline1_out1                   : unsigned(23 DOWNTO 0);  -- ufix24_En24
  SIGNAL count_1                          : std_logic;
  SIGNAL count_2                          : std_logic;
  SIGNAL edge_rsvd_1                      : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL Counter_out2                     : std_logic_vector(7 DOWNTO 0);  -- ufix8
  SIGNAL IncPerTurn_elek_AXI4_unsigned    : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Pipeline2_out1                   : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_el                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL count_el_signed                  : signed(15 DOWNTO 0);  -- int16
  SIGNAL Pipeline5_out1                   : signed(15 DOWNTO 0);  -- int16
  SIGNAL Product_theta_el_cast            : signed(24 DOWNTO 0);  -- sfix25_En24
  SIGNAL Product_theta_el_mul_temp        : signed(40 DOWNTO 0);  -- sfix41_En24
  SIGNAL Product_theta_el_cast_1          : signed(39 DOWNTO 0);  -- sfix40_En24
  SIGNAL theta_el_1                       : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL theta_el_tmp                     : signed(23 DOWNTO 0);  -- sfix24_En20
  SIGNAL IncPerTurn_mech_AXI4_unsigned    : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Pipeline3_out1                   : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL count_mech                       : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL count_mech_unsigned              : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL position_tmp                     : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL edge_signed                      : signed(7 DOWNTO 0);  -- int8
  SIGNAL Abs_y                            : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL edge_rsvd_2                      : std_logic;  -- ufix1
  SIGNAL hold1_out1_1                     : signed(3 DOWNTO 0);  -- sfix4
  SIGNAL countPerPEriod                   : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL countPerPEriod_signed            : signed(15 DOWNTO 0);  -- int16
  SIGNAL countPerPEriod_1                 : signed(15 DOWNTO 0);  -- int16
  SIGNAL position_1                       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL omega_oversampled_3              : signed(23 DOWNTO 0);  -- sfix24_En11
  SIGNAL theta_el_2                       : signed(23 DOWNTO 0);  -- sfix24_En20

BEGIN
  -- At high speed, e.g. at 6000rpm, an steady-state error occurs of around 2.5rpm. I would need more iterrations in 
  -- the division to get it accurate
  -- However, i also tried to do a multiplication befor the division, so that the Oversampling factor do not gain the 
  -- steady-state error.
  -- But after a try, i still had a steady-state error, which was even bigger (3,2rpm). So i keep it so far. 
  -- However, the problem is not the fixed-point fromat. The problem is the number of itterations in the division!
  -- 
  -- omega by counting lines, can be used for high-speed, but is not recommended for small drives! 
  -- However, for using this approach, we need a quite long time window in order to get an accurate speed. 
  -- For small drives a long time window is not acceptable, since the mechanical time constant is small.
  -- e.g. using just 100us (since the speed control has this period at 10kHz) we can calculate as following:
  -- speed = 5034rpm, Increments = 5000, QuadratureFactor = 4, f_cc = 10000 kHz
  -- In the test, 169 lines are counted in 100us in the described example.
  -- -> 169*(10000/(4*5000))*60 = 5070rpm (so this is not accurate!) 
  -- However, a longer time window is not acceptabel for speed control with10kHz. More increments is not common, since 
  -- 5000 are already a lot
  -- 
  -- Speed
  -- 
  -- position
  -- This functionality gives the mechanical position of the encoder. The range of the output is "0-Increments", whereby 
  -- the increments depend on the used encoder
  -- - By doing so, the mechanical position is still available. However, the multiplication for scaling to 2PI is avoided 
  -- (resource efficient). The position can be used e.g. for position control
  -- - If the mechanical angle is required, e.g. for an asynchronous machine, theta can be used after parameterization 
  -- with pole pair 1
  -- 
  -- theta
  -- This functionality gives theta of the encoder. The range of the output is "0-2PI".
  -- - The pole pair number and incrments are necessary in order to result the electrical angle (theta).
  -- - If the mechanical angle is required, e.g. for an asynchronous machine, theta can be used after parameterization 
  -- with pole pair 1

  u_IncreEncoder_V24_tc : IncreEncoder_V24_ip_src_IncreEncoder_V24_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              enb_2_100_0 => enb_2_100_0,
              enb_1_100_0 => enb_1_100_0,
              enb_1_100_1 => enb_1_100_1
              );

  u_Check_Direction : IncreEncoder_V24_ip_src_Check_Direction
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              A => A,
              B => B,
              Dir => Check_Direction_out1  -- sfix4
              );

  u_omega_by_measure_time : IncreEncoder_V24_ip_src_omega_by_measure_time
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              Edge_rsvd => Logical2_out1_1,
              T => std_logic_vector(Pipeline7_out1),  -- sfix38_En32
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              ReadBack_Omega => std_logic_vector(omega_oversampled),  -- sfix24_En11
              OverSamplOmega => std_logic_vector(Pipeline4_out1),  -- sfix24_En11
              one_Omega => rps,  -- sfix38_En32
              OverSamplingFactor => omega_by_measure_time_out2,  -- uint16
              NewMeasurement => NewMeasurement
              );

  u_HDL_Reciprocal : IncreEncoder_V24_ip_src_HDL_Reciprocal
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              enb_2_100_0 => enb_2_100_0,
              din => std_logic_vector(hold2_out1),  -- sfix32_En18
              dout => HDL_Reciprocal_out1  -- sfix32_En12
              );

  u_Counter : IncreEncoder_V24_ip_src_Counter
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              Enable_ctr => count_2,
              I_line => I,
              Edge_rsvd => edge_rsvd_1,  -- int8
              Reset_1 => Counter_out2  -- uint8
              );

  u_Counter_theta_ele : IncreEncoder_V24_ip_src_Counter_theta_ele
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              Edge_rsvd => edge_rsvd_1,  -- int8
              Reset_1 => Counter_out2,  -- uint8
              IncsPerTurn => std_logic_vector(Pipeline2_out1),  -- uint16
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              count => count_el  -- int16
              );

  u_Counter_position : IncreEncoder_V24_ip_src_Counter_position
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              Edge_rsvd => edge_rsvd_1,  -- int8
              Reset_1 => Counter_out2,  -- uint8
              IncsPerTurn => std_logic_vector(Pipeline3_out1),  -- uint16
              Dir => std_logic_vector(hold1_out1),  -- sfix4
              count => count_mech  -- uint16
              );

  u_omega_by_count_lines : IncreEncoder_V24_ip_src_omega_by_count_lines
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_100_0 => enb_1_100_0,
              Edge_rsvd => edge_rsvd_1,  -- int8
              Reset_1 => PeriodEnd,
              IncsPerTurn => std_logic_vector(Pipeline3_out1),  -- uint16
              count => countPerPEriod  -- int16
              );

  Logical2_out1 <=  NOT A;

  Timer_FPGA_ms_AXI4_unsigned <= unsigned(Timer_FPGA_ms_AXI4);

  Pipeline6_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Pipeline6_out1 <= to_unsigned(0, 32);
      ELSIF enb_1_100_0 = '1' THEN
        Pipeline6_out1 <= Timer_FPGA_ms_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS Pipeline6_process;


  Data_Type_Conversion3_out1 <= signed(resize(Pipeline6_out1, 38));

  Logical2_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Logical2_out1_1 <= '0';
      ELSIF enb_1_100_0 = '1' THEN
        Logical2_out1_1 <= Logical2_out1;
      END IF;
    END IF;
  END PROCESS Logical2_out_pipe_process;


  Pipeline7_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Pipeline7_out1 <= to_signed(0, 38);
      ELSIF enb_1_100_0 = '1' THEN
        Pipeline7_out1 <= Data_Type_Conversion3_out1;
      END IF;
    END IF;
  END PROCESS Pipeline7_process;


  Check_Direction_out1_signed <= signed(Check_Direction_out1);

  hold1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hold1_out1 <= to_signed(16#0#, 4);
      ELSIF enb_1_100_0 = '1' THEN
        hold1_out1 <= Check_Direction_out1_signed;
      END IF;
    END IF;
  END PROCESS hold1_process;


  OmegaPerOverSampl_AXI4_signed <= signed(OmegaPerOverSampl_AXI4);

  Pipeline4_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Pipeline4_out1 <= to_signed(16#000000#, 24);
      ELSIF enb_1_100_0 = '1' THEN
        Pipeline4_out1 <= OmegaPerOverSampl_AXI4_signed;
      END IF;
    END IF;
  END PROCESS Pipeline4_process;


  omega_by_measure_time_out2_unsigned <= unsigned(omega_by_measure_time_out2);

  hold5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hold5_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        hold5_out1 <= omega_by_measure_time_out2_unsigned;
      END IF;
    END IF;
  END PROCESS hold5_process;


  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hold5_out1_1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        hold5_out1_1 <= hold5_out1;
      END IF;
    END IF;
  END PROCESS reduced_process;


  rps_signed <= signed(rps);

  Data_Type_Conversion4_out1 <= resize(rps_signed(37 DOWNTO 14), 32);

  hold2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hold2_out1 <= to_signed(0, 32);
      ELSIF enb_1_100_0 = '1' THEN
        hold2_out1 <= Data_Type_Conversion4_out1;
      END IF;
    END IF;
  END PROCESS hold2_process;


  HDL_Reciprocal_out1_signed <= signed(HDL_Reciprocal_out1);

  omega_oversampled_1 <= HDL_Reciprocal_out1_signed(23 DOWNTO 0);

  Div_i1_cast <= signed(resize(hold5_out1_1, 17));
  Div_i1_mul_temp <= omega_oversampled_1 * Div_i1_cast;
  Div_i1_cast_1 <= Div_i1_mul_temp(39 DOWNTO 0);
  
  omega_oversampled_2 <= X"7FFFFF" WHEN (Div_i1_cast_1(39) = '0') AND (Div_i1_cast_1(38 DOWNTO 24) /= "000000000000000") ELSE
      X"800000" WHEN (Div_i1_cast_1(39) = '1') AND (Div_i1_cast_1(38 DOWNTO 24) /= "111111111111111") ELSE
      Div_i1_cast_1(24 DOWNTO 1);

  reduced_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        omega_oversampled <= to_signed(16#000000#, 24);
      ELSIF enb_1_100_0 = '1' THEN
        omega_oversampled <= omega_oversampled_2;
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  omega <= std_logic_vector(omega_oversampled);

  omega_AXI4 <= std_logic_vector(omega_oversampled);

  PI2_Inc_AXI4_unsigned <= unsigned(PI2_Inc_AXI4);

  Pipeline1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Pipeline1_out1 <= to_unsigned(16#000000#, 24);
      ELSIF enb_1_100_0 = '1' THEN
        Pipeline1_out1 <= PI2_Inc_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS Pipeline1_process;


  count_1 <= A XOR B;

  Logical1_out_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        count_2 <= '0';
      ELSIF enb_1_100_0 = '1' THEN
        count_2 <= count_1;
      END IF;
    END IF;
  END PROCESS Logical1_out_pipe_process;


  IncPerTurn_elek_AXI4_unsigned <= unsigned(IncPerTurn_elek_AXI4);

  Pipeline2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Pipeline2_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        Pipeline2_out1 <= IncPerTurn_elek_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS Pipeline2_process;


  count_el_signed <= signed(count_el);

  Pipeline5_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Pipeline5_out1 <= to_signed(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        Pipeline5_out1 <= count_el_signed;
      END IF;
    END IF;
  END PROCESS Pipeline5_process;


  Product_theta_el_cast <= signed(resize(Pipeline1_out1, 25));
  Product_theta_el_mul_temp <= Product_theta_el_cast * Pipeline5_out1;
  Product_theta_el_cast_1 <= Product_theta_el_mul_temp(39 DOWNTO 0);
  theta_el_1 <= Product_theta_el_cast_1(27 DOWNTO 4);

  reduced_2_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        theta_el_tmp <= to_signed(16#000000#, 24);
      ELSIF enb_1_100_0 = '1' THEN
        theta_el_tmp <= theta_el_1;
      END IF;
    END IF;
  END PROCESS reduced_2_process;


  theta_el <= std_logic_vector(theta_el_tmp);

  theta_el_AXI4 <= std_logic_vector(theta_el_tmp);

  IncPerTurn_mech_AXI4_unsigned <= unsigned(IncPerTurn_mech_AXI4);

  Pipeline3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Pipeline3_out1 <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        Pipeline3_out1 <= IncPerTurn_mech_AXI4_unsigned;
      END IF;
    END IF;
  END PROCESS Pipeline3_process;


  count_mech_unsigned <= unsigned(count_mech);

  reduced_3_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        position_tmp <= to_unsigned(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        position_tmp <= count_mech_unsigned;
      END IF;
    END IF;
  END PROCESS reduced_3_process;


  position <= std_logic_vector(position_tmp);

  position_AXI4 <= std_logic_vector(position_tmp);

  edge_signed <= signed(edge_rsvd_1);

  
  Abs_y <=  - (resize(edge_signed, 9)) WHEN edge_signed < to_signed(16#00#, 8) ELSE
      resize(edge_signed, 9);
  edge_rsvd_2 <= Abs_y(0);

  out_6_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        edge_rsvd <= '0';
      ELSIF enb_1_100_0 = '1' THEN
        edge_rsvd <= edge_rsvd_2;
      END IF;
    END IF;
  END PROCESS out_6_pipe_process;


  out_7_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        count <= '0';
      ELSIF enb_1_100_0 = '1' THEN
        count <= count_2;
      END IF;
    END IF;
  END PROCESS out_7_pipe_process;


  out_8_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        hold1_out1_1 <= to_signed(16#0#, 4);
      ELSIF enb_1_100_0 = '1' THEN
        hold1_out1_1 <= hold1_out1;
      END IF;
    END IF;
  END PROCESS out_8_pipe_process;


  direction_AXI4 <= std_logic_vector(hold1_out1_1);

  countPerPEriod_signed <= signed(countPerPEriod);

  out_9_pipe_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        countPerPEriod_1 <= to_signed(16#0000#, 16);
      ELSIF enb_1_100_0 = '1' THEN
        countPerPEriod_1 <= countPerPEriod_signed;
      END IF;
    END IF;
  END PROCESS out_9_pipe_process;


  countPerPeriod_AXI4 <= std_logic_vector(countPerPEriod_1);

  OverSamplFactor <= std_logic_vector(hold5_out1_1);

  ce_out <= enb_1_100_1;


END rtl;

