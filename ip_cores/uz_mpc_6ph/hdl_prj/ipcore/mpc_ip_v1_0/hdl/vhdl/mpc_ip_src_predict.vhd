-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\test_RS_flipflop_statemachine\mpc_ip_src_predict.vhd
-- Created: 2022-08-29 16:54:27
-- 
-- Generated by MATLAB 9.10 and HDL Coder 3.18
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: mpc_ip_src_predict
-- Source Path: test_RS_flipflop_statemachine/mpc/predict
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY mpc_ip_src_predict IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        voltages_done                     :   IN    std_logic;
        adc_trigger                       :   IN    std_logic;
        done                              :   OUT   std_logic;
        last_prediciton_done              :   OUT   std_logic
        );
END mpc_ip_src_predict;


ARCHITECTURE rtl OF mpc_ip_src_predict IS

  -- Component Declarations
  COMPONENT mpc_ip_src_Detect_Rise_Positive_block1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          U                               :   IN    std_logic;
          Y                               :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT mpc_ip_src_Detect_Rise_Positive1_block
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          U                               :   IN    std_logic;
          Y                               :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT mpc_ip_src_Detect_Rise_Positive2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          U                               :   IN    std_logic;
          Y                               :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT mpc_ip_src_Subsystem_block
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          Set                             :   IN    std_logic;
          Reset_1                         :   IN    std_logic;
          Q                               :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : mpc_ip_src_Detect_Rise_Positive_block1
    USE ENTITY work.mpc_ip_src_Detect_Rise_Positive_block1(rtl);

  FOR ALL : mpc_ip_src_Detect_Rise_Positive1_block
    USE ENTITY work.mpc_ip_src_Detect_Rise_Positive1_block(rtl);

  FOR ALL : mpc_ip_src_Detect_Rise_Positive2
    USE ENTITY work.mpc_ip_src_Detect_Rise_Positive2(rtl);

  FOR ALL : mpc_ip_src_Subsystem_block
    USE ENTITY work.mpc_ip_src_Subsystem_block(rtl);

  -- Signals
  SIGNAL Delay_out1                       : std_logic;
  SIGNAL Detect_Rise_Positive_out1        : std_logic;
  SIGNAL Delay12_out1                     : std_logic;
  SIGNAL Delay6_ctrl_const_out            : std_logic;
  SIGNAL Delay6_ctrl_delay_out            : std_logic;
  SIGNAL Delay6_Initial_Val_out           : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Constant1_out1                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay8_out1                      : std_logic;
  SIGNAL Detect_Rise_Positive1_out1       : std_logic;
  SIGNAL Delay5_ctrl_const_out            : std_logic;
  SIGNAL Delay5_ctrl_delay_out            : std_logic;
  SIGNAL Delay5_Initial_Val_out           : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay7_ctrl_const_out            : std_logic;
  SIGNAL Delay7_ctrl_delay_out            : std_logic;
  SIGNAL Delay7_Initial_Val_out           : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Constant_out1                    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL TmpGroundAtSwitch4Inport3_out1   : std_logic;
  SIGNAL Delay5_out1                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Add1_out1                        : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Switch1_out1                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay7_out1                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Add2_out1                        : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Switch1_out1_1                   : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay6_out1                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Relational_Operator_relop1       : std_logic;
  SIGNAL Logical_Operator_out1            : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Switch2_out1                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL trigger_predict                  : std_logic;
  SIGNAL switch_compare_1_1               : std_logic;
  SIGNAL Relational_Operator1_relop1      : std_logic;
  SIGNAL predict_done                     : std_logic;
  SIGNAL Logical_Operator1_out1           : std_logic;
  SIGNAL Logical_Operator1_out1_1         : std_logic;
  SIGNAL Detect_Rise_Positive2_out1       : std_logic;
  SIGNAL Q                                : std_logic;
  SIGNAL switch_compare_1_2               : std_logic;
  SIGNAL predict_done_1                   : std_logic;

BEGIN
  -- counter with adjustable reset
  -- 
  -- mpc state machine

  u_Detect_Rise_Positive : mpc_ip_src_Detect_Rise_Positive_block1
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              U => Delay_out1,
              Y => Detect_Rise_Positive_out1
              );

  u_Detect_Rise_Positive1 : mpc_ip_src_Detect_Rise_Positive1_block
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              U => Delay8_out1,
              Y => Detect_Rise_Positive1_out1
              );

  u_Detect_Rise_Positive2 : mpc_ip_src_Detect_Rise_Positive2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              U => Logical_Operator1_out1_1,
              Y => Detect_Rise_Positive2_out1
              );

  u_Subsystem : mpc_ip_src_Subsystem_block
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              Set => Delay12_out1,
              Reset_1 => Detect_Rise_Positive2_out1,
              Q => Q
              );

  Delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay_out1 <= voltages_done;
      END IF;
    END IF;
  END PROCESS Delay_process;


  Delay12_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay12_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay12_out1 <= Detect_Rise_Positive_out1;
      END IF;
    END IF;
  END PROCESS Delay12_process;


  Delay6_ctrl_const_out <= '1';

  Delay6_ctrl_delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay6_ctrl_delay_out <= '0';
      ELSIF enb = '1' THEN
        Delay6_ctrl_delay_out <= Delay6_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS Delay6_ctrl_delay_process;


  Delay6_Initial_Val_out <= to_unsigned(1, 32);

  Constant1_out1 <= to_unsigned(64, 32);

  Delay8_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay8_out1 <= '0';
      ELSIF enb = '1' THEN
        Delay8_out1 <= adc_trigger;
      END IF;
    END IF;
  END PROCESS Delay8_process;


  Delay5_ctrl_const_out <= '1';

  Delay5_ctrl_delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay5_ctrl_delay_out <= '0';
      ELSIF enb = '1' THEN
        Delay5_ctrl_delay_out <= Delay5_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS Delay5_ctrl_delay_process;


  Delay5_Initial_Val_out <= to_unsigned(1, 32);

  Delay7_ctrl_const_out <= '1';

  Delay7_ctrl_delay_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Delay7_ctrl_delay_out <= '0';
      ELSIF enb = '1' THEN
        Delay7_ctrl_delay_out <= Delay7_ctrl_const_out;
      END IF;
    END IF;
  END PROCESS Delay7_ctrl_delay_process;


  Delay7_Initial_Val_out <= to_unsigned(1, 32);

  Constant_out1 <= to_unsigned(1, 32);

  TmpGroundAtSwitch4Inport3_out1 <= '0';

  Add1_out1 <= Delay5_out1 + Constant_out1;

  
  Delay7_out1 <= Delay7_Initial_Val_out WHEN Delay7_ctrl_delay_out = '0' ELSE
      Switch1_out1;

  Add2_out1 <= Delay7_out1 - Constant1_out1;

  
  Delay5_out1 <= Delay5_Initial_Val_out WHEN Delay5_ctrl_delay_out = '0' ELSE
      Switch1_out1;

  reduced_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Switch1_out1 <= to_unsigned(0, 32);
      ELSIF enb = '1' THEN
        Switch1_out1 <= Switch1_out1_1;
      END IF;
    END IF;
  END PROCESS reduced_process;


  
  Delay6_out1 <= Delay6_Initial_Val_out WHEN Delay6_ctrl_delay_out = '0' ELSE
      Switch1_out1;

  
  Relational_Operator_relop1 <= '1' WHEN Delay6_out1 >= Constant1_out1 ELSE
      '0';

  Logical_Operator_out1 <= Relational_Operator_relop1 AND Detect_Rise_Positive1_out1;

  
  switch_compare_1 <= '1' WHEN Logical_Operator_out1 > '0' ELSE
      '0';

  
  Switch2_out1 <= Delay5_out1 WHEN switch_compare_1 = '0' ELSE
      Add2_out1;

  
  switch_compare_1_1 <= '1' WHEN trigger_predict > '0' ELSE
      '0';

  
  Switch1_out1_1 <= Switch2_out1 WHEN switch_compare_1_1 = '0' ELSE
      Add1_out1;

  
  Relational_Operator1_relop1 <= '1' WHEN Switch1_out1_1 > Constant1_out1 ELSE
      '0';

  Logical_Operator1_out1 <= predict_done AND Relational_Operator1_relop1;

  reduced_1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        Logical_Operator1_out1_1 <= '0';
      ELSIF enb = '1' THEN
        Logical_Operator1_out1_1 <= Logical_Operator1_out1;
      END IF;
    END IF;
  END PROCESS reduced_1_process;


  
  switch_compare_1_2 <= '1' WHEN Q > '0' ELSE
      '0';

  
  trigger_predict <= TmpGroundAtSwitch4Inport3_out1 WHEN switch_compare_1_2 = '0' ELSE
      Detect_Rise_Positive_out1;

  Delay1_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF reset = '1' THEN
        predict_done <= '0';
      ELSIF enb = '1' THEN
        predict_done <= trigger_predict;
      END IF;
    END IF;
  END PROCESS Delay1_process;


  done <= predict_done;

  last_prediciton_done <= Logical_Operator1_out1_1;

END rtl;

